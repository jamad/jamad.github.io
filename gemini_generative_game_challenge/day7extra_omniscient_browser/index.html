<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deca-Search v5.1: Final Release</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;600&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">

    <!-- Google Analytics (GA4) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QEJBQQMWT9"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QEJBQQMWT9');
    </script>

    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; background-color: #020617; color: #e2e8f0; overflow: hidden; touch-action: none; }
        .mono-font { font-family: 'Share Tech Mono', monospace; }
        
        /* Scanline Effect */
        .scanline { background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 100%); background-size: 100% 4px; pointer-events: none; }
        
        /* Grid Animations */
        .grid-cell { transition: all 0.2s ease-out; border: 1px solid #1e293b; }
        .grid-cell:hover { background-color: #0f172a; border-color: #06b6d4; transform: translateY(-2px); z-index: 20; }
        .btn-active { background-color: rgba(6, 182, 212, 0.2); border-color: #06b6d4; color: #22d3ee; box-shadow: 0 0 15px rgba(6, 182, 212, 0.3); }

        /* Search Input */
        .search-input:focus { outline: none; border-color: #06b6d4; box-shadow: 0 0 10px rgba(6, 182, 212, 0.2); }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const BASE = 10;
        const STEPS = 100;

        const SECTORS = [
            { id: 0, label: "GEN", full: "GENERAL", desc: "Standard English" },
            { id: 1, label: "MED", full: "MEDICAL", desc: "Diseases & Anatomy" },
            { id: 2, label: "BIO", full: "BIOLOGY", desc: "Taxonomy & Species" },
            { id: 3, label: "CHEM", full: "CHEMICAL", desc: "Elements & Compounds" },
        ];

        const SLIDERS = [
            { idx: 1, name: "GRAND", pow: 7, color: "from-indigo-950 to-blue-900", freq: 60 },
            { idx: 2, name: "MAJOR", pow: 5, color: "from-blue-900 to-cyan-900", freq: 100 },
            { idx: 3, name: "MINOR", pow: 3, color: "from-cyan-900 to-teal-900", freq: 200 },
            { idx: 4, name: "PATCH", pow: 1, color: "from-teal-900 to-emerald-900", freq: 400 },
        ];

        const MULTIPLIERS = [1000000000, 10000000, 100000, 1000, 10];

        const AudioEngine = {
            ctx: null,
            init: () => { if (!AudioEngine.ctx) AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume(); },
            playTick: (freq) => {
                if (!AudioEngine.ctx) return;
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, t);
                osc.frequency.exponentialRampToValueAtTime(freq * 0.5, t + 0.1);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t); osc.stop(t + 0.15);
            },
            playFound: () => {
                if (!AudioEngine.ctx) return;
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, t);
                osc.frequency.linearRampToValueAtTime(880, t + 0.1);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t); osc.stop(t + 0.3);
            }
        };

        const hasDataInRange = (sortedIds, min, max) => {
            let left = 0;
            let right = sortedIds.length - 1;
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (sortedIds[mid] >= min && sortedIds[mid] < max) return true;
                if (sortedIds[mid] < min) left = mid + 1;
                else right = mid - 1;
            }
            return false;
        };

        const App = () => {
            const [positions, setPositions] = useState([0, 0, 0, 0, 0]);
            const [dataMap, setDataMap] = useState({});
            const [sortedIds, setSortedIds] = useState([]);
            const [audioReady, setAudioReady] = useState(false);
            const [activeRow, setActiveRow] = useState(null);
            
            const [loadState, setLoadState] = useState("INITIALIZING");
            const [totalCount, setTotalCount] = useState(0);
            
            const [searchQuery, setSearchQuery] = useState("");
            const [isAutoPiloting, setIsAutoPiloting] = useState(false);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        setLoadState("LOADING DATABASE...");
                        const response = await fetch('data.json');
                        if (response.ok) {
                            const json = await response.json();
                            if (json && json.items) {
                                setDataMap(json.items);
                                const keys = Object.keys(json.items).map(Number).sort((a, b) => a - b);
                                setSortedIds(keys);
                                setTotalCount(keys.length);
                                setLoadState("ONLINE");
                            }
                        } else { setLoadState("ERR: CONN"); }
                    } catch (err) { setLoadState("OFFLINE"); }
                };
                loadData();
            }, []);

            const enableAudio = () => { if (!audioReady) { AudioEngine.init(); setAudioReady(true); } };

            const globalIndex = useMemo(() => {
                return positions.reduce((acc, pos, idx) => acc + (pos * MULTIPLIERS[idx]), 0);
            }, [positions]);

            const getHeatmap = (levelIdx) => {
                if (sortedIds.length === 0) return [];
                let base = 0;
                for (let i = 0; i < levelIdx; i++) {
                    base += positions[i] * MULTIPLIERS[i];
                }
                const multiplier = MULTIPLIERS[levelIdx];
                const map = [];
                for (let step = 0; step < STEPS; step++) {
                    const min = base + (step * multiplier);
                    const max = base + ((step + 1) * multiplier);
                    if (hasDataInRange(sortedIds, min, max)) map.push(true);
                    else map.push(false);
                }
                return map;
            };

            const handleSectorClick = (sectorId) => {
                enableAudio();
                const newPos = [...positions];
                newPos[0] = sectorId;
                setPositions(newPos);
                AudioEngine.playTick(40);

                // GA Event: Sector Change
                if (typeof gtag === 'function') {
                    gtag('event', 'select_content', {
                        content_type: 'sector',
                        item_id: SECTORS[sectorId].full
                    });
                }
            };

            // --- Custom Touch/Pointer Handler (iPad Fix) ---
            const handlePointerDown = (e, arrIdx) => {
                e.preventDefault();
                enableAudio();
                e.currentTarget.setPointerCapture(e.pointerId);
                setActiveRow(arrIdx);
                updateSliderFromPointer(e, arrIdx);
            };

            const handlePointerMove = (e, arrIdx) => {
                if (activeRow === arrIdx) {
                    updateSliderFromPointer(e, arrIdx);
                }
            };

            const handlePointerUp = (e) => {
                 e.currentTarget.releasePointerCapture(e.pointerId);
                 setActiveRow(null);
            };

            const updateSliderFromPointer = (e, arrIdx) => {
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                let percent = x / rect.width;
                percent = Math.max(0, Math.min(1, percent));
                const newVal = Math.floor(percent * (STEPS - 1));
                
                if (positions[arrIdx] !== newVal) {
                    const newPos = [...positions];
                    newPos[arrIdx] = newVal;
                    setPositions(newPos);
                    const freq = SLIDERS.find(s => s.idx === arrIdx)?.freq || 100;
                    AudioEngine.playTick(freq);
                }
            };

            const performSearch = (e) => {
                e.preventDefault();
                if (!searchQuery) return;
                enableAudio();
                const q = searchQuery.toLowerCase().trim();

                // GA Event: Search
                if (typeof gtag === 'function') {
                    gtag('event', 'search', { search_term: q });
                }

                const foundId = Object.keys(dataMap).find(key => {
                    const item = dataMap[key];
                    return item.en && item.en.toLowerCase() === q;
                });
                if (foundId) startAutoPilot(Number(foundId));
                else alert("NOT FOUND");
            };

            const startAutoPilot = (targetId) => {
                setIsAutoPiloting(true);
                AudioEngine.playFound();
                let remain = targetId;
                const newPos = [0,0,0,0,0];
                newPos[0] = Math.floor(remain / MULTIPLIERS[0]); remain %= MULTIPLIERS[0];
                newPos[1] = Math.floor(remain / MULTIPLIERS[1]); remain %= MULTIPLIERS[1];
                newPos[2] = Math.floor(remain / MULTIPLIERS[2]); remain %= MULTIPLIERS[2];
                newPos[3] = Math.floor(remain / MULTIPLIERS[3]); remain %= MULTIPLIERS[3];
                newPos[4] = Math.floor(remain / MULTIPLIERS[4]);
                setPositions(newPos);
                setTimeout(() => setIsAutoPiloting(false), 500);
            };

            const getDisplayData = (offset) => {
               