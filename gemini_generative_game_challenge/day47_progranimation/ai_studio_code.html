<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deuce Pro - Custom Spawn & Arena v16</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://shared-components-be4c86.gitlab.io/debug-overlay.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #0f172a; touch-action: none; user-select: none; }
        #canvas-container { position: absolute; inset: 0; z-index: 1; }
        #param-panel {
            position: absolute; top: 15px; right: 15px; z-index: 20;
            width: 270px; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 15px;
            color: white; pointer-events: auto; font-family: monospace;
        }
        .slider-group { margin-bottom: 10px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; color: #94a3b8; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #3b82f6; }
        #ui-layer { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; }
        .btn-interactive { pointer-events: auto; transition: 0.2s; background: rgba(30, 41, 59, 0.9); border: 2px solid rgba(255,255,255,0.1); color: white; border-radius: 12px; }
        .selected { border-color: #3b82f6; background: #1d4ed8; box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="param-panel">
        <div class="text-xs font-bold mb-3 border-b border-white/20 pb-2 text-blue-400 uppercase text-center font-sans tracking-widest">Arena Tuner v16</div>
        
        <div class="slider-group"><div class="slider-label"><span>Gravity</span><span id="val-gravity">-13.8</span></div><input type="range" id="sld-gravity" min="-30" max="-1" step="0.5" value="-13.8"></div>
        <div class="slider-group"><div class="slider-label"><span>Upright Power</span><span id="val-upright">5350</span></div><input type="range" id="sld-upright" min="0" max="8000" step="50" value="5350"></div>
        <div class="slider-group"><div class="slider-label"><span>Heading Stability</span><span id="val-heading">2300</span></div><input type="range" id="sld-heading" min="0" max="5000" step="50" value="2300"></div>
        
        <!-- 追加: 召喚時の向き -->
        <div class="slider-group">
            <div class="slider-label"><span class="text-blue-300 font-bold">SPAWN ANGLE</span><span id="val-spawnAngle">0°</span></div>
            <input type="range" id="sld-spawnAngle" min="0" max="360" step="1" value="0">
        </div>

        <div class="slider-group"><div class="slider-label"><span>Walk Speed</span><span id="val-speed">7.8</span></div><input type="range" id="sld-speed" min="0" max="15" step="0.1" value="7.8"></div>
        <div class="slider-group"><div class="slider-label"><span>Walk Range</span><span id="val-amp">0.8</span></div><input type="range" id="sld-amp" min="0" max="1.5" step="0.05" value="0.8"></div>
        <div class="slider-group"><div class="slider-label"><span>Joint Torque</span><span id="val-power">3000</span></div><input type="range" id="sld-power" min="50" max="8000" step="50" value="3000"></div>
        <div class="slider-group"><div class="slider-label"><span>Hip Center Bias</span><span id="val-hipBias">0.3</span></div><input type="range" id="sld-hipBias" min="-1.0" max="1.0" step="0.05" value="0.3"></div>

        <div class="text-[9px] text-emerald-400 font-bold text-center uppercase tracking-tighter italic">Wide Stairs & Distant Fog: ENABLED</div>
    </div>

    <div id="ui-layer">
        <div class="flex gap-3">
            <button id="btn-deuce" class="btn-interactive w-28 h-16 flex items-center justify-center selected font-bold uppercase tracking-widest text-xl">Deuce</button>
            <button class="btn-interactive bg-red-600/50 w-16 h-16 flex items-center justify-center" onclick="resetWorld()"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
        </div>
    </div>

    <script>
        const CONFIG = { gravity: -13.8, upright: 5350, headingPower: 2300, walkSpeed: 7.8, walkAmp: 0.8, jointPower: 3000, hipBias: 0.3, spawnAngle: 0 };
        const GROUP_GROUND = 1, GROUP_CHAR = 2;

        let scene, camera, renderer, world, controls, objectsToUpdate = [], autonomousBodies = [], lastTime = 0;

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a1420);
            // フォグの調整: 100m先から始まり500mで完全に隠れる（遠方効果）
            scene.fog = new THREE.Fog(0x0a1420, 100, 500);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 40, 70);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 5, 0);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(60, 100, 60); sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            sun.shadow.camera.left = sun.shadow.camera.bottom = -120;
            sun.shadow.camera.right = sun.shadow.camera.top = 120;
            scene.add(sun);

            world = new CANNON.World(); world.gravity.set(0, CONFIG.gravity, 0);
            world.solver.iterations = 100;
            
            const groundMat = new CANNON.Material("ground");
            const charMat = new CANNON.Material("char");
            world.addContactMaterial(new CANNON.ContactMaterial(groundMat, charMat, { friction: 1.0, restitution: 0.0 }));

            buildWorld(groundMat);
            setupInteractions();
            setupSliders();

            window.addEventListener('keydown', (e) => {
                if (e.altKey && e.key.toLowerCase() === 'd') {
                    e.preventDefault(); 
                    if (window.toggleDebugOverlay) window.toggleDebugOverlay();
                }
            }, true);
            if (window.initDebugOverlay) window.initDebugOverlay();

            renderer.setAnimationLoop(animate);
        }

        function addStaticBox(w,h,d, px,py,pz, rx=0,ry=0,rz=0, color=0x1b263b, mat) {
            const body = new CANNON.Body({ mass:0, material:mat, collisionFilterGroup:GROUP_GROUND, collisionFilterMask:GROUP_CHAR | GROUP_GROUND });
            body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
            body.position.set(px, py, pz);
            if(rx||ry||rz) body.quaternion.setFromEuler(rx, ry, rz);
            world.addBody(body);

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshLambertMaterial({color}));
            mesh.position.set(px, py, pz);
            if(rx||ry||rz) mesh.rotation.set(rx, ry, rz);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            objectsToUpdate.push({ mesh, body });
            clickObjects.push(mesh);
        }

        let clickObjects = [];
        function buildWorld(groundMat) {
            objectsToUpdate.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            objectsToUpdate = []; autonomousBodies = []; clickObjects = [];

            // 1. 無限床 (突き抜け防止)
            const groundPlane = new CANNON.Body({ mass: 0, material: groundMat, collisionFilterGroup: GROUP_GROUND, collisionFilterMask: GROUP_CHAR | GROUP_GROUND });
            groundPlane.addShape(new CANNON.Plane());
            groundPlane.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundPlane);
            
            const visualFloor = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), new THREE.MeshPhongMaterial({color: 0x1b263b}));
            visualFloor.rotation.x = -Math.PI/2; visualFloor.receiveShadow = true; scene.add(visualFloor);
            scene.add(new THREE.GridHelper(300, 100, 0x334155, 0x1e293b));
            clickObjects.push(visualFloor);

            // 2. 外周の急斜面
            const wallTilt = Math.PI / 3.5;
            addStaticBox(160, 2, 60, 0, 10, 120, -wallTilt, 0, 0, 0x0d1b2a, groundMat);
            addStaticBox(160, 2, 60, 0, 10, -120, wallTilt, 0, 0, 0x0d1b2a, groundMat);
            addStaticBox(60, 2, 160, 120, 10, 0, 0, 0, wallTilt, 0x0d1b2a, groundMat);
            addStaticBox(60, 2, 160, -120, 10, 0, 0, 0, -wallTilt, 0x0d1b2a, groundMat);

            // 3. 幅の広い大階段
            for(let i=0; i<10; i++) {
                addStaticBox(40, 1.2, 6, 0, i*0.6, -60 - i*5, 0, 0, 0, 0x243447, groundMat);
            }

            // 4. アスレチック
            addStaticBox(2, 12, 2, -30, 6, 30, 0, 0, 0, 0x415a77, groundMat);
            addStaticBox(2, 12, 2, 30, 6, 30, 0, 0, 0, 0x415a77, groundMat);
            addStaticBox(80, 0.5, 8, 0, 12, 30, 0, 0, 0, 0x778da9, groundMat);
        }

        function spawnCharacter(pos) {
            const y = pos.y + 4.0;
            const torso = createPart({x: 1.4, y: 1.6, z: 0.8}, {x: 1.0, y: 1.6, z: 0.7}, {x: pos.x, y: y + 1.5, z: pos.z}, 3.0, 0x10b981, true);
            
            // SPAWN ANGLE スライダーの値を反映
            const angleRad = (CONFIG.spawnAngle * Math.PI) / 180;
            torso.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angleRad);

            // スライダーで指定した方向を「維持すべき正面」として記憶
            const heading = new CANNON.Vec3(0, 0, 1);
            torso.quaternion.vmult(heading, heading);
            heading.y = 0; heading.normalize();
            torso.targetHeading = heading;

            const createLeg = (side) => {
                const thigh = createPart({x: 0.5, y: 1.4, z: 0.5}, {x: 0.15, y: 1.4, z: 0.15}, {x: pos.x + side*0.6, y: y + 0.5, z: pos.z}, 1.0, 0x059669, true);
                const shin = createPart({x: 0.4, y: 1.4, z: 0.4}, {x: 0.15, y: 1.4, z: 0.15}, {x: pos.x + side*0.6, y: y - 0.5, z: pos.z}, 0.8, 0x047857, true);
                const foot = createPart({x: 0.8, y: 0.4, z: 1.4}, {x: 0.7, y: 0.4, z: 1.2}, {x: pos.x + side*0.6, y: y - 1.2, z: pos.z + 0.2}, 1.0, 0x064e3b, true);
                
                thigh.quaternion.copy(torso.quaternion); shin.quaternion.copy(torso.quaternion); foot.quaternion.copy(torso.quaternion);

                const hj = new CANNON.HingeConstraint(torso, thigh, { pivotA: new CANNON.Vec3(side*0.6, -0.8, 0), pivotB: new CANNON.Vec3(0, 0.7, 0), axisA: new CANNON.Vec3(1,0,0), axisB: new CANNON.Vec3(1,0,0), collideConnected: false });
                const kj = new CANNON.HingeConstraint(thigh, shin, { pivotA: new CANNON.Vec3(0, -0.7, 0), pivotB: new CANNON.Vec3(0, 0.7, 0), axisA: new CANNON.Vec3(1,0,0), axisB: new CANNON.Vec3(1,0,0), collideConnected: false });
                const aj = new CANNON.HingeConstraint(shin, foot, { pivotA: new CANNON.Vec3(0, -0.7, 0), pivotB: new CANNON.Vec3(0, 0.2, -0.3), axisA: new CANNON.Vec3(1,0,0), axisB: new CANNON.Vec3(1,0,0), collideConnected: false });
                
                [hj, kj, aj].forEach(j => { j.enableMotor(); world.addConstraint(j); });
                return { hj, kj, aj, thigh, shin, foot };
            };
            torso.charType = 'deuce'; torso.legs = { left: createLeg(-1), right: createLeg(1) };
            autonomousBodies.push(torso);
        }

        function createPart(vDim, pDim, pos, mass, color, isChar = false) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(vDim.x, vDim.y, vDim.z), new THREE.MeshPhongMaterial({ color }));
            mesh.castShadow = true; mesh.receiveShadow = true; scene.add(mesh);
            const body = new CANNON.Body({
                mass, shape: new CANNON.Box(new CANNON.Vec3(pDim.x/2, pDim.y/2, pDim.z/2)),
                collisionFilterGroup: isChar ? GROUP_CHAR : GROUP_GROUND,
                collisionFilterMask: GROUP_GROUND
            });
            body.position.set(pos.x, pos.y, pos.z); body.angularDamping = 0.5; world.addBody(body);
            objectsToUpdate.push({ mesh, body });
            return body;
        }

        function getSafeAngle(parent, child) {
            const down = new CANNON.Vec3(0, -1, 0);
            const childDownInWorld = child.quaternion.vmult(down);
            const parentInvQ = parent.quaternion.inverse();
            const relDown = parentInvQ.vmult(childDownInWorld);
            return Math.atan2(relDown.z, -relDown.y);
        }

        function animate(time) {
            const dt = lastTime ? (time - lastTime) / 1000 : 1/60; lastTime = time;
            world.step(1/60, dt, 15); 

            autonomousBodies.forEach(body => {
                const up = new CANNON.Vec3(0,1,0); const curUp = body.quaternion.vmult(up);
                const tiltForward = CONFIG.walkSpeed > 0.1 ? 0.2 : 0;
                const targetUp = new CANNON.Vec3(0, 1, tiltForward).unit();
                body.torque.vadd(curUp.cross(targetUp).scale(CONFIG.upright), body.torque);

                if (body.targetHeading) {
                    const currentForward = new CANNON.Vec3(0, 0, 1);
                    body.quaternion.vmult(currentForward, currentForward);
                    currentForward.y = 0; currentForward.normalize();
                    const headingError = currentForward.cross(body.targetHeading);
                    body.torque.vadd(new CANNON.Vec3(0, headingError.y * CONFIG.headingPower, 0), body.torque);
                }

                const cycle = Math.sin(performance.now() / 1000 * CONFIG.walkSpeed);
                const ctrl = (leg, ph) => {
                    const isStance = ph < 0; 
                    const ha = getSafeAngle(body, leg.thigh);
                    const targetHa = (ph * CONFIG.walkAmp) + CONFIG.hipBias;
                    let hs = (targetHa - ha) * 10.0;
                    leg.hj.setMotorSpeed(hs); leg.hj.setMotorMaxForce(CONFIG.jointPower);
                    
                    const ka = getSafeAngle(leg.thigh, leg.shin);
                    let ks = isStance ? (0.0 - ka) * 5.0 : (-0.8 - ka) * 10.0;
                    if (ka > 0 && ks > 0) ks = -5.0; if (ka < -2.8 && ks < 0) ks = 5.0; 
                    leg.kj.setMotorSpeed(ks); leg.kj.setMotorMaxForce(CONFIG.jointPower);

                    const aa = getSafeAngle(leg.shin, leg.foot);
                    let as = (0.0 - aa) * 10.0;
                    if (aa > 0.52) as = -15.0; if (aa < -0.52) as = 15.0; 
                    leg.aj.setMotorSpeed(as); leg.aj.setMotorMaxForce(CONFIG.jointPower);
                };
                ctrl(body.legs.left, cycle); ctrl(body.legs.right, -cycle);
            });

            objectsToUpdate.forEach(obj => { obj.mesh.position.copy(obj.body.position); obj.mesh.quaternion.copy(obj.body.quaternion); });
            controls.update(); renderer.render(scene, camera);
        }

        function setupSliders() {
            const bind = (id, key) => {
                const sld = document.getElementById(`sld-${id}`); const val = document.getElementById(`val-${id}`);
                sld.addEventListener('input', (e) => { 
                    let v = parseFloat(e.target.value); CONFIG[key] = v; val.innerText = (key==='spawnAngle' ? v+'°' : v.toFixed(1));
                    if(key === 'gravity') world.gravity.set(0, v, 0);
                });
            };
            [['gravity','gravity'],['upright','upright'],['heading','headingPower'],['speed','walkSpeed'],['amp','walkAmp'],['power','jointPower'],['hipBias','hipBias'],['spawnAngle','spawnAngle']].forEach(a => bind(a[0], a[1]));
        }

        function setupInteractions() {
            const raycaster = new THREE.Raycaster();
            renderer.domElement.addEventListener('pointerdown', (e) => {
                if (e.clientY > window.innerHeight - 100 || e.clientX > window.innerWidth - 270) return;
                const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(clickObjects);
                if (intersects.length > 0) spawnCharacter(intersects[0].point);
            });
        }
        function resetWorld() { init(); }
        init();
    </script>
</body>
</html>