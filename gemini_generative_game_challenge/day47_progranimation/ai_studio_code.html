<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deuce Pro - Error Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0f172a; touch-action: none; user-select: none; }
        #start-screen { position: absolute; inset: 0; background: rgba(15, 23, 42, 0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; cursor: pointer; }
        .ui-panel { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; display: flex; gap: 10px; }
        .btn { pointer-events: auto; background: rgba(30, 41, 59, 0.85); color: white; padding: 12px 24px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.1); transition: 0.2s; font-weight: bold; backdrop-filter: blur(10px); }
        .btn.selected { border-color: #3b82f6; background: #1d4ed8; box-shadow: 0 0 20px rgba(59, 130, 246, 0.6); }
        .btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="start-screen" onclick="initApp()">
        <h1 class="text-5xl font-black mb-2 italic">PHYSICS LAB</h1>
        <p class="text-blue-400 tracking-widest mb-8 uppercase text-sm font-mono text-center">Deuce Pro: PD Controller Fixed</p>
        <div class="px-10 py-4 bg-blue-600 rounded-full font-bold text-xl shadow-2xl animate-pulse">CLICK TO START</div>
    </div>

    <div class="ui-panel">
        <button id="btn-pogo" class="btn" onclick="selectChar('pogo')">Pogo</button>
        <button id="btn-uno" class="btn" onclick="selectChar('uno')">Uno</button>
        <button id="btn-deuce" class="btn selected" onclick="selectChar('deuce')">Deuce Pro</button>
        <button class="btn bg-red-600/50" onclick="resetWorld()">Reset</button>
    </div>

    <script>
        let scene, camera, renderer, world, controls;
        let objectsToUpdate = [];
        let characters = [];
        let clickTargets = []; 
        let selectedCharacter = 'deuce';
        let isStarted = false;

        // --- Helper: Apply Local Torque in Cannon.js ---
        // Cannon.jsに存在しないapplyLocalTorqueを再現する関数
        function applyLocalTorque(body, localTorque) {
            const worldTorque = new CANNON.Vec3();
            body.quaternion.vmult(localTorque, worldTorque);
            body.torque.vadd(worldTorque, body.torque);
        }

        // --- Blenderロジック: PD制御 (角度誤差からトルクを算出) ---
        function calculatePDTorque(currentAngle, currentVel, targetAngle, p, d) {
            let error = targetAngle - currentAngle;
            while (error >  Math.PI) error -= Math.PI * 2;
            while (error < -Math.PI) error += Math.PI * 2;
            return (p * error) - (d * currentVel);
        }

        function initApp() {
            if(isStarted) return;
            isStarted = true;
            document.getElementById('start-screen').style.display = 'none';
            setupPhysics();
            setupGraphics();
            buildWorld();
            animate();
        }

        function setupPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -15, 0);
            world.solver.iterations = 25; 
            world.defaultContactMaterial.friction = 0.8;
        }

        function setupGraphics() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            scene.fog = new THREE.Fog(0x0f172a, 20, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 10, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            scene.add(sun);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', handlePointerDown);
        }

        function handlePointerDown(e) {
            if (!isStarted || e.clientY > window.innerHeight - 100) return;
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickTargets);
            if (intersects.length > 0) {
                spawnCharacter(selectedCharacter, intersects[0].point);
            }
        }

        function createBox(w, h, d, pos, mass, color, canClick = true) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color }));
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const body = new CANNON.Body({ mass, shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)) });
            body.position.set(pos.x, pos.y, pos.z);
            world.addBody(body);
            objectsToUpdate.push({ mesh, body });
            if (canClick) clickTargets.push(mesh);
            return { mesh, body };
        }

        function buildWorld() {
            // Ground
            const ground = createBox(100, 0.1, 100, {x:0, y:-0.05, z:0}, 0, 0x1e293b, true);
            scene.add(new THREE.GridHelper(100, 50, 0x334155, 0x1e293b));
            
            // Seesaw
            const pivot = createBox(1, 1, 1, {x: 5, y: 0.5, z: 0}, 0, 0x475569);
            const plank = createBox(10, 0.25, 3, {x: 5, y: 1.2, z: 0}, 5, 0x3b82f6);
            world.addConstraint(new CANNON.HingeConstraint(pivot.body, plank.body, {
                pivotA: new CANNON.Vec3(0, 0.5, 0), pivotB: new CANNON.Vec3(0, 0, 0),
                axisA: new CANNON.Vec3(0, 0, 1), axisB: new CANNON.Vec3(0, 0, 1)
            }));

            // Blocks
            createBox(4, 1, 4, {x: -8, y: 0.5, z: -5}, 0, 0x334155);
            createBox(4, 2, 4, {x: -12, y: 1.0, z: -5}, 0, 0x334155);
        }

        function spawnCharacter(type, pos) {
            const y = pos.y + 3.5;
            if (type === 'pogo') {
                const p = createBox(0.8, 2.5, 0.8, {x: pos.x, y: y, z: pos.z}, 2, 0x3b82f6, false);
                p.charType = 'pogo'; characters.push(p);
            } else if (type === 'uno') {
                const foot = createBox(1.2, 0.4, 1.2, {x: pos.x, y: y - 1.5, z: pos.z}, 1, 0xef4444, false);
                const head = createBox(1, 1, 1, {x: pos.x, y: y + 1, z: pos.z}, 2, 0xef4444, false);
                world.addConstraint(new CANNON.DistanceConstraint(foot.body, head.body, 2.5));
                characters.push({ type: 'uno', head, foot });
            } else if (type === 'deuce') {
                const torso = createBox(1.4, 1.6, 0.9, {x:pos.x, y:y+1.5, z:pos.z}, 3.0, 0x9ca3af, false);
                const createLeg = (side) => {
                    const thigh = createBox(0.5, 1.4, 0.5, {x:pos.x + side*0.6, y:y, z:pos.z}, 0.8, 0x6b7280, false);
                    const shin = createBox(0.4, 1.4, 0.4, {x:pos.x + side*0.6, y:y-1, z:pos.z}, 0.6, 0x4b5563, false);
                    const foot = createBox(0.8, 0.4, 1.4, {x:pos.x + side*0.6, y:y-2, z:pos.z+0.3}, 0.8, 0x1e2937, false);
                    world.addConstraint(new CANNON.HingeConstraint(torso.body, thigh.body, { pivotA: new CANNON.Vec3(side*0.6, -0.8, 0), pivotB: new CANNON.Vec3(0, 0.7, 0), axisA: new CANNON.Vec3(1, 0, 0), axisB: new CANNON.Vec3(1, 0, 0) }));
                    world.addConstraint(new CANNON.HingeConstraint(thigh.body, shin.body, { pivotA: new CANNON.Vec3(0, -0.7, 0), pivotB: new CANNON.Vec3(0, 0.7, 0), axisA: new CANNON.Vec3(1, 0, 0), axisB: new CANNON.Vec3(1, 0, 0) }));
                    world.addConstraint(new CANNON.HingeConstraint(shin.body, foot.body, { pivotA: new CANNON.Vec3(0, -0.7, 0), pivotB: new CANNON.Vec3(0, 0.2, -0.4), axisA: new CANNON.Vec3(1, 0, 0), axisB: new CANNON.Vec3(1, 0, 0) }));
                    return { thigh, shin, foot };
                };
                characters.push({ type: 'deuce_pro', torso, leftLeg: createLeg(-1), rightLeg: createLeg(1), state: 0, timer: 0 });
            }
        }

        function updateAI() {
            characters.forEach(c => {
                if (c.charType === 'pogo') {
                    const tq = calculatePDTorque(c.body.quaternion.x, c.body.angularVelocity.x, 0, 150, 15);
                    applyLocalTorque(c.body, new CANNON.Vec3(tq, 0, 0));
                    if(c.body.position.y < 1.6 && Math.abs(c.body.velocity.y) < 1) c.body.applyImpulse(new CANNON.Vec3(0, 18, 0), c.body.position);
                } 
                else if (c.type === 'uno') {
                    const diff = c.head.body.position.vsub(c.foot.body.position);
                    c.foot.body.applyForce(new CANNON.Vec3(diff.x * 60, 0, diff.z * 60), c.foot.body.position);
                    const tq = calculatePDTorque(c.foot.body.quaternion.x, c.foot.body.angularVelocity.x, 0, 80, 10);
                    applyLocalTorque(c.foot.body, new CANNON.Vec3(tq, 0, 0));
                }
                else if (c.type === 'deuce_pro') {
                    c.timer += 0.016;
                    if (c.timer > 0.7) { c.state = 1 - c.state; c.timer = 0; }
                    const torso = c.torso.body;
                    const tilt = torso.quaternion.x;
                    const isLeft = c.state === 0;
                    const sta = isLeft ? c.leftLeg : c.rightLeg;
                    const swi = isLeft ? c.rightLeg : c.leftLeg;

                    const pdLeg = (leg, hTar, kTar, aTar) => {
                        const ht = calculatePDTorque(leg.thigh.body.quaternion.x, leg.thigh.body.angularVelocity.x, hTar + tilt, 250, 25);
                        applyLocalTorque(leg.thigh.body, new CANNON.Vec3(ht, 0, 0));
                        const kt = calculatePDTorque(leg.shin.body.quaternion.x, leg.shin.body.angularVelocity.x, kTar, 200, 20);
                        applyLocalTorque(leg.shin.body, new CANNON.Vec3(kt, 0, 0));
                        const at = calculatePDTorque(leg.foot.body.quaternion.x, leg.foot.body.angularVelocity.x, aTar - tilt, 100, 10);
                        applyLocalTorque(leg.foot.body, new CANNON.Vec3(at, 0, 0));
                    };

                    const swing = Math.sin(c.timer * Math.PI * 1.4) * 0.7;
                    pdLeg(sta, -0.15, 0.2, 0); 
                    pdLeg(swi, swing + 0.3, -0.5, 0.3);

                    applyLocalTorque(torso, new CANNON.Vec3(calculatePDTorque(torso.quaternion.x, torso.angularVelocity.x, 0, 400, 40), 0, 0));
                    applyLocalTorque(torso, new CANNON.Vec3(0, 0, calculatePDTorque(torso.quaternion.z, torso.angularVelocity.z, 0, 300, 30)));
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isStarted) {
                world.step(1/60);
                updateAI();
                objectsToUpdate.forEach(obj => {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                });
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function selectChar(type) {
            selectedCharacter = type;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('selected'));
            document.getElementById(`btn-${type}`).classList.add('selected');
        }

        function resetWorld() {
            objectsToUpdate.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            objectsToUpdate = []; characters = []; clickTargets = []; buildWorld();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>