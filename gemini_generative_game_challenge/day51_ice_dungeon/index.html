<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>わんわん足跡迷路 (Paw Print Dungeon)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #main-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ミニマップ */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: min(270px, 32vw);
            height: min(270px, 32vw);
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.7);
            z-index: 10;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .minimap-hint {
            position: absolute;
            bottom: 4px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 10px;
            pointer-events: none;
        }

        /* Legend */
        #minimap-legend {
            position: absolute;
            top: 6px;
            left: 8px;
            display: flex;
            flex-direction: column;
            gap: 3px;
            pointer-events: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            display: inline-block;
            flex-shrink: 0;
        }

        /* D-Pad */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            z-index: 10;
        }

        .btn {
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }
        
        .btn:active { background-color: rgba(255, 255, 255, 0.6); }

        #btn-w { grid-column: 2; grid-row: 1; }
        #btn-a { grid-column: 1; grid-row: 2; }
        #btn-s { grid-column: 2; grid-row: 3; }
        #btn-d { grid-column: 3; grid-row: 2; }

        /* UIオーバーレイ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 20;
            transition: opacity 0.3s;
        }

        h1 {
            color: #ffdd00;
            font-size: 48px;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            margin-bottom: 20px;
            text-align: center;
        }

        p {
            color: white;
            font-size: 18px;
            text-align: center;
            margin-bottom: 30px;
            max-width: 80%;
            white-space: pre-line;
        }

        .action-btn {
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            background-color: #ffdd00;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        .action-btn:active { transform: scale(0.95); }

        .hidden { display: none !important; }

        #hud {
            position: absolute;
            bottom: 22px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 3px black, 0 0 8px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.35);
            padding: 4px 16px;
            border-radius: 20px;
            z-index: 10;
            white-space: nowrap;
            pointer-events: none;
        }

        /* 言語切り替えボタン */
        #lang-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            z-index: 30;
        }

        .lang-btn {
            padding: 5px 9px;
            font-size: 12px;
            font-weight: bold;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }

        .lang-btn.active {
            background: rgba(255,255,255,0.25);
            color: #fff;
            border-color: rgba(255,255,255,0.8);
        }

        @media (hover: hover) and (pointer: fine) {
            #controls { opacity: 0.5; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="main-canvas"></canvas>

    <div id="hud"><span id="floor-label">階: </span><span id="floor-display">3</span></div>

    <div id="lang-buttons">
        <button class="lang-btn" data-lang="EN">EN</button>
        <button class="lang-btn active" data-lang="JA">JA</button>
        <button class="lang-btn" data-lang="FI">FI</button>
        <button class="lang-btn" data-lang="DA">DA</button>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
        <div id="minimap-legend">
            <div class="legend-item">
                <span class="legend-dot" style="background:#2299ff;"></span>
                <span data-i18n="legend_start">スタート</span>
            </div>
            <div class="legend-item">
                <span class="legend-dot" style="background:#ff2222;"></span>
                <span data-i18n="legend_goal">ゴール</span>
            </div>
        </div>
        <div class="minimap-hint" data-i18n="minimap_hint">ドラッグで回転</div>
    </div>

    <div id="controls">
        <div class="btn" id="btn-w">▲</div>
        <div class="btn" id="btn-a">↶</div>
        <div class="btn" id="btn-s">▼</div>
        <div class="btn" id="btn-d">↷</div>
    </div>

    <div id="ui-layer">
        <h1 id="ui-title">わんわん足跡迷路</h1>
        <p id="ui-desc">3階建ての迷路です。\n自分の足跡をたどって、1階のゴールを目指そう！\nPC: WASDキー / スマホ: 画面ボタン</p>
        <button class="action-btn" id="start-btn">ゲームスタート</button>
    </div>
</div>

<script>
// =============================================
// 多言語テキスト
// =============================================
const TRANSLATIONS = {
    EN: {
        title: 'Paw Print Maze',
        desc: '3-floor maze.\nFollow your paw prints to the 1st floor goal!\nPC: WASD keys / Mobile: Buttons',
        start: 'GAME START',
        complete_title: 'COMPLETE!',
        complete_desc: 'You conquered the maze!\nCongratulations!',
        restart: 'RESTART',
        floor_label: 'Floor: ',
        legend_start: 'Start',
        legend_goal: 'Goal',
        minimap_hint: 'Drag to rotate',
    },
    JA: {
        title: 'わんわん足跡迷路',
        desc: '3階建ての迷路です。\n自分の足跡をたどって、1階のゴールを目指そう！\nPC: WASDキー / スマホ: 画面ボタン',
        start: 'ゲームスタート',
        complete_title: 'クリア！',
        complete_desc: '迷路を制覇しました！\nおめでとうございます。',
        restart: 'もう一度',
        floor_label: '階: ',
        legend_start: 'スタート',
        legend_goal: 'ゴール',
        minimap_hint: 'ドラッグで回転',
    },
    FI: {
        title: 'Tassujen Jäljillä',
        desc: '3-kerroksinen labyrintti.\nSeuraa tassujäljkiä 1. kerroksen maaliin!\nPC: WASD-näppäimet / Mobiili: Napit',
        start: 'ALOITA PELI',
        complete_title: 'VALMIS!',
        complete_desc: 'Selvitit labyrintin!\nOnnittelut!',
        restart: 'UUDELLEEN',
        floor_label: 'Kerros: ',
        legend_start: 'Lähtö',
        legend_goal: 'Maali',
        minimap_hint: 'Vedä kiertääksesi',
    },
    DA: {
        title: 'Potelabyrinth',
        desc: '3-etagers labyrint.\nFølg dine poter til 1. etages mål!\nPC: WASD-taster / Mobil: Knapper',
        start: 'START SPIL',
        complete_title: 'FULDFØRT!',
        complete_desc: 'Du klarede labyrinten!\nTillykke!',
        restart: 'GENSTART',
        floor_label: 'Etage: ',
        legend_start: 'Start',
        legend_goal: 'Mål',
        minimap_hint: 'Træk for at rotere',
    }
};

let currentLang = 'JA';

function applyLanguage(lang, gameState) {
    currentLang = lang;
    const t = TRANSLATIONS[lang];

    document.querySelectorAll('.lang-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.lang === lang);
    });

    document.getElementById('ui-title').innerText = t.title;
    document.getElementById('ui-desc').innerText = t.desc;
    document.getElementById('floor-label').innerText = t.floor_label;

    const startBtn = document.getElementById('start-btn');
    if (gameState === 'COMPLETE') {
        startBtn.innerText = t.restart;
    } else {
        startBtn.innerText = t.start;
    }

    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (t[key]) el.innerText = t[key];
    });
}

document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const gs = window.currentGame ? window.currentGame.gameState : 'TITLE';
        applyLanguage(btn.dataset.lang, gs);
    });
});

// =============================================
// 効果音
// =============================================
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, duration, vol=0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playWalk()  { this.playTone(150, 'triangle', 0.1, 0.05); },
    playTurn()  { this.playTone(400, 'sine', 0.05, 0.02); },
    playBump()  { this.playTone(100, 'square', 0.15, 0.1); },
    playStairs() {
        setTimeout(() => this.playTone(300, 'square', 0.1, 0.05), 0);
        setTimeout(() => this.playTone(400, 'square', 0.1, 0.05), 100);
        setTimeout(() => this.playTone(500, 'square', 0.1, 0.05), 200);
    },
    playPaw()  { this.playTone(800, 'sine', 0.05, 0.03); },
    playGoal() {
        setTimeout(() => this.playTone(440, 'square', 0.2, 0.1), 0);
        setTimeout(() => this.playTone(440, 'square', 0.2, 0.1), 200);
        setTimeout(() => this.playTone(440, 'square', 0.2, 0.1), 400);
        setTimeout(() => this.playTone(587.33, 'square', 0.4, 0.1), 600);
    }
};

// =============================================
// 迷路生成
// =============================================
const MAZE_SIZE = 8;
const FLOORS = 3;

class Maze {
    constructor() {
        this.grid = [];
        this.start = {x: 0, y: 0, z: 2};
        this.goal = {x: 7, y: 7, z: 0};
        this.stairs = [];
        this.generate();
    }

    generate() {
        this.grid = [];
        for (let z = 0; z < FLOORS; z++) {
            let floor = [];
            for (let y = 0; y < MAZE_SIZE; y++) {
                let row = [];
                for (let x = 0; x < MAZE_SIZE; x++) {
                    row.push({ x, y, z, n: true, e: true, s: true, w: true, visited: false, stairDown: false, stairUp: false });
                }
                floor.push(row);
            }
            this.grid.push(floor);
        }

        for (let z = 0; z < FLOORS; z++) {
            this.carvePassagesFrom(0, 0, z);
        }

        this.stairs = [];
        for (let z = 2; z >= 1; z--) {
            let sx, sy;
            do {
                sx = Math.floor(Math.random() * MAZE_SIZE);
                sy = Math.floor(Math.random() * MAZE_SIZE);
            } while (sx === this.goal.x && sy === this.goal.y && z-1 === this.goal.z);
            this.grid[z][sy][sx].stairDown = true;
            this.grid[z-1][sy][sx].stairUp = true;
            this.stairs.push({z, x: sx, y: sy});
        }

        this.calculateStartPoint();
    }

    carvePassagesFrom(cx, cy, cz) {
        let directions = [
            {nx: 0, ny: -1, wall: 'n', opp: 's'},
            {nx: 1, ny: 0,  wall: 'e', opp: 'w'},
            {nx: 0, ny: 1,  wall: 's', opp: 'n'},
            {nx: -1, ny: 0, wall: 'w', opp: 'e'}
        ];
        directions.sort(() => Math.random() - 0.5);
        this.grid[cz][cy][cx].visited = true;

        for (let dir of directions) {
            let nx = cx + dir.nx;
            let ny = cy + dir.ny;
            if (nx >= 0 && nx < MAZE_SIZE && ny >= 0 && ny < MAZE_SIZE && !this.grid[cz][ny][nx].visited) {
                this.grid[cz][cy][cx][dir.wall] = false;
                this.grid[cz][ny][nx][dir.opp] = false;
                this.carvePassagesFrom(nx, ny, cz);
            }
        }
    }

    calculateStartPoint() {
        let queue = [{x: this.goal.x, y: this.goal.y, z: this.goal.z, dist: 0}];
        let visited = new Set([`${this.goal.x},${this.goal.y},${this.goal.z}`]);
        let maxDistNode = queue[0];

        while (queue.length > 0) {
            let curr = queue.shift();
            if (curr.z === 2 && curr.dist > maxDistNode.dist) {
                maxDistNode = curr;
            } else if (maxDistNode.z !== 2 && curr.z === 2) {
                maxDistNode = curr;
            }
            let cell = this.grid[curr.z][curr.y][curr.x];
            let neighbors = [];
            if (!cell.n) neighbors.push({x: curr.x, y: curr.y-1, z: curr.z});
            if (!cell.s) neighbors.push({x: curr.x, y: curr.y+1, z: curr.z});
            if (!cell.w) neighbors.push({x: curr.x-1, y: curr.y, z: curr.z});
            if (!cell.e) neighbors.push({x: curr.x+1, y: curr.y, z: curr.z});
            if (cell.stairDown) neighbors.push({x: curr.x, y: curr.y, z: curr.z-1});
            if (cell.stairUp)   neighbors.push({x: curr.x, y: curr.y, z: curr.z+1});

            for (let n of neighbors) {
                let key = `${n.x},${n.y},${n.z}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    queue.push({x: n.x, y: n.y, z: n.z, dist: curr.dist+1});
                }
            }
        }
        this.start = {x: maxDistNode.x, y: maxDistNode.y, z: 2};
    }
}

// =============================================
// テクスチャ
// =============================================
function createWallTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#99ccff';
    ctx.fillRect(0, 0, 256, 256);
    ctx.strokeStyle = '#55aaff';
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            let offset = i % 2 === 0 ? 0 : 32;
            ctx.fillStyle = '#bbedff';
            ctx.fillRect(j*64+offset, i*64, 64, 64);
            ctx.strokeRect(j*64+offset, i*64, 64, 64);
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillRect(j*64+offset+2, i*64+2, 60, 10);
        }
    }
    return new THREE.CanvasTexture(canvas);
}

function createFloorTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');

    // ベース: 柔らかい雪白
    ctx.fillStyle = '#eef5ff';
    ctx.fillRect(0, 0, 256, 256);

    // 積雪の重なりを表すグラデーション層
    const grad = ctx.createRadialGradient(128, 128, 10, 128, 128, 160);
    grad.addColorStop(0,   'rgba(255,255,255,0.55)');
    grad.addColorStop(0.6, 'rgba(220,235,255,0.2)');
    grad.addColorStop(1,   'rgba(180,210,240,0.0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 256, 256);

    // 雪の小さな凹み・でこぼこ (大)
    for (let i = 0; i < 18; i++) {
        const bx = Math.random() * 256;
        const by = Math.random() * 256;
        const br = Math.random() * 18 + 8;
        const bg = ctx.createRadialGradient(bx, by, 0, bx, by, br);
        bg.addColorStop(0,   'rgba(160,195,230,0.22)');
        bg.addColorStop(0.5, 'rgba(180,215,245,0.10)');
        bg.addColorStop(1,   'rgba(200,230,255,0.0)');
        ctx.beginPath();
        ctx.ellipse(bx, by, br, br * 0.55, Math.random()*Math.PI, 0, Math.PI*2);
        ctx.fillStyle = bg;
        ctx.fill();
    }

    // 細かい雪粒 (小)
    for (let i = 0; i < 70; i++) {
        const sx = Math.random() * 256;
        const sy = Math.random() * 256;
        const sr = Math.random() * 3.5 + 0.5;
        const alpha = Math.random() * 0.18 + 0.04;
        ctx.beginPath();
        ctx.arc(sx, sy, sr, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 225, 255, ${alpha})`;
        ctx.fill();
    }

    // 雪の表面のきらめき（ハイライト点）
    for (let i = 0; i < 30; i++) {
        const gx = Math.random() * 256;
        const gy = Math.random() * 256;
        const gr = Math.random() * 2 + 0.5;
        ctx.beginPath();
        ctx.arc(gx, gy, gr, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
        ctx.fill();
    }

    // 端のほんのり影（セルの境界感）
    const edge = ctx.createLinearGradient(0, 0, 0, 256);
    edge.addColorStop(0,    'rgba(150,180,220,0.12)');
    edge.addColorStop(0.08, 'rgba(150,180,220,0.0)');
    edge.addColorStop(0.92, 'rgba(150,180,220,0.0)');
    edge.addColorStop(1,    'rgba(150,180,220,0.12)');
    ctx.fillStyle = edge;
    ctx.fillRect(0, 0, 256, 256);

    return new THREE.CanvasTexture(canvas);
}

function createSlopeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    // 雪のスロープ - 少し影を入れて傾き感
    const grad = ctx.createLinearGradient(0, 0, 0, 128);
    grad.addColorStop(0, '#ddeeff');
    grad.addColorStop(1, '#c8dff5');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 128, 128);
    // 筋
    ctx.strokeStyle = 'rgba(180,210,240,0.7)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * 18);
        ctx.lineTo(128, i * 18 + 10);
        ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
}

// 足跡テクスチャ — 半分サイズ、雪のくぼみ風の陰カラー
function drawPaw(ctx, x, y, size, angle) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    const makeShadowGrad = (cx2, cy2, rx, ry) => {
        // 楕円の中心に合わせたラジアルグラデ (影っぽい)
        const r = Math.max(rx, ry);
        const g = ctx.createRadialGradient(cx2, cy2, 0, cx2, cy2, r * 1.1);
        g.addColorStop(0,   'rgba(45, 55, 70, 0.70)');
        g.addColorStop(0.5, 'rgba(60, 75, 95, 0.45)');
        g.addColorStop(1,   'rgba(80, 100, 130, 0.05)');
        return g;
    };

    // メイン肉球
    ctx.beginPath();
    ctx.ellipse(0, size*0.2, size*0.4, size*0.3, 0, 0, Math.PI*2);
    ctx.fillStyle = makeShadowGrad(0, size*0.2, size*0.4, size*0.3);
    ctx.fill();

    // 指4つ
    const toes = [
        [-size*0.35, -size*0.1],
        [-size*0.15, -size*0.3],
        [ size*0.15, -size*0.3],
        [ size*0.35, -size*0.1],
    ];
    for (const [tx, ty] of toes) {
        ctx.beginPath();
        ctx.ellipse(tx, ty, size*0.15, size*0.20, 0, 0, Math.PI*2);
        ctx.fillStyle = makeShadowGrad(tx, ty, size*0.15, size*0.20);
        ctx.fill();
    }

    ctx.restore();
}

function createPawTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 256, 256);

    // 半分サイズ (20 vs 元の40)
    drawPaw(ctx,  96, 224, 20, -0.1);
    drawPaw(ctx, 160, 160, 20,  0.1);
    drawPaw(ctx,  96,  96, 20, -0.1);
    drawPaw(ctx, 160,  32, 20,  0.1);

    return new THREE.CanvasTexture(canvas);
}

// =============================================
// ゲームクラス
// =============================================
class Game {
    constructor() {
        this.cellSize  = 10;
        this.wallHeight = 10;
        this.maze = new Maze();
        this.player = {x: 0, y: 0, z: 2, dir: 0};
        this.isAnimating  = false;
        this.visitedTiles = new Set();
        this.pawMeshes    = [];
        this.gameState    = 'TITLE';

        window.currentGame = this;

        this.initThree();
        this.initMinimap();
        this.buildLevel();
        this.setupInputs();

        this.animate = this.animate.bind(this);
        requestAnimationFrame(this.animate);
    }

    initThree() {
        const canvas = document.getElementById('main-canvas');
        this.renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xeef4ff);
        this.scene.fog = new THREE.Fog(0xeef4ff, 1, this.cellSize * 4);

        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);

        this.scene.add(new THREE.AmbientLight(0xddeeff, 1.0));
        this.pointLight = new THREE.PointLight(0xffffff, 1.2, this.cellSize * 4);
        this.scene.add(this.pointLight);

        this.wallMat      = new THREE.MeshLambertMaterial({map: createWallTexture()});
        this.floorMat     = new THREE.MeshLambertMaterial({map: createFloorTexture()});
        this.slopeMat     = new THREE.MeshLambertMaterial({map: createSlopeTexture(), side: THREE.DoubleSide});
        this.pawMat       = new THREE.MeshBasicMaterial({map: createPawTexture(), transparent: true, depthWrite: false});
        this.stairDownMat = new THREE.MeshLambertMaterial({color: 0x4477dd});
        this.stairUpMat   = new THREE.MeshLambertMaterial({color: 0x88ccff});
        this.goalMat      = new THREE.MeshLambertMaterial({color: 0xff2222, emissive: 0x550000});

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    initMinimap() {
        const canvas = document.getElementById('minimap-canvas');
        // 270x270 内部解像度
        this.miniRenderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
        this.miniRenderer.setSize(270, 270);

        this.miniScene = new THREE.Scene();
        const d = MAZE_SIZE * 1.5;
        this.miniCamera = new THREE.OrthographicCamera(-d, d, d, -d, 1, 1000);
        this.miniCamera.position.set(0, 50, 0);
        this.miniCamera.lookAt(0, 0, 0);

        this.minimapGroup = new THREE.Group();
        this.miniScene.add(this.minimapGroup);
        this.minimapGroup.rotation.x = Math.PI / 6;
        this.minimapGroup.rotation.y = -Math.PI / 4;

        // ドラッグ回転
        let isDragging = false;
        let prevX = 0, prevY = 0;
        const mc = document.getElementById('minimap-container');
        mc.addEventListener('pointerdown', (e) => {
            isDragging = true;
            prevX = e.clientX; prevY = e.clientY;
            e.stopPropagation();
        });
        window.addEventListener('pointermove', (e) => {
            if (isDragging) {
                this.minimapGroup.rotation.y += (e.clientX - prevX) * 0.01;
                this.minimapGroup.rotation.x += (e.clientY - prevY) * 0.01;
                this.minimapGroup.rotation.x = Math.max(0, Math.min(Math.PI/2, this.minimapGroup.rotation.x));
                prevX = e.clientX; prevY = e.clientY;
            }
        });
        window.addEventListener('pointerup', () => { isDragging = false; });
    }

    buildLevel() {
        while (this.scene.children.length > 0) this.scene.remove(this.scene.children[0]);
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        this.scene.add(this.pointLight);
        this.pawMeshes = [];
        this.visitedTiles.clear();

        while (this.minimapGroup.children.length > 0) this.minimapGroup.remove(this.minimapGroup.children[0]);

        const floorHeight = this.wallHeight;
        this.levelGroup = new THREE.Group();
        this.scene.add(this.levelGroup);

        const miniOffset = (MAZE_SIZE - 1) / 2;

        for (let z = 0; z < FLOORS; z++) {
            const zPos = z * floorHeight;
            const miniZPos = (z - 1) * 3;

            // ミニマップ用フロア半透明板
            const miniFloorMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(MAZE_SIZE, MAZE_SIZE),
                new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.08, side: THREE.DoubleSide})
            );
            miniFloorMesh.rotation.x = -Math.PI / 2;
            miniFloorMesh.position.y = miniZPos;
            this.minimapGroup.add(miniFloorMesh);

            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cell = this.maze.grid[z][y][x];
                    const px = (x - MAZE_SIZE/2 + 0.5) * this.cellSize;
                    const pz = (y - MAZE_SIZE/2 + 0.5) * this.cellSize;
                    const mpx = x - miniOffset;
                    const mpz = y - miniOffset;

                    // ---- 床 ----
                    {
                        let fMat = this.floorMat;
                        if (cell.stairDown) fMat = this.stairDownMat;
                        else if (cell.stairUp) fMat = this.stairUpMat;
                        else if (z === this.maze.goal.z && x === this.maze.goal.x && y === this.maze.goal.y) fMat = this.goalMat;
                        const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.cellSize, this.cellSize), fMat);
                        floorMesh.rotation.x = -Math.PI / 2;
                        floorMesh.position.set(px, zPos, pz);
                        this.levelGroup.add(floorMesh);
                    }

                    // ---- 天井 ----
                    {
                        const ceilMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.cellSize, this.cellSize), this.floorMat);
                        ceilMesh.rotation.x = Math.PI / 2;
                        ceilMesh.position.set(px, zPos + this.wallHeight, pz);
                        this.levelGroup.add(ceilMesh);
                    }

                    // ---- 壁（厚みあり boxGeometry）----
                    const wallThick = this.wallHeight * 0.1; // 厚み = wallHeight の10%
                    const miniLineMat = new THREE.LineBasicMaterial({color: 0x888888});

                    const addWall = (wx, wy, wz, ry, p1, p2) => {
                        // N/S壁: BoxGeometry(cellSize, wallHeight, wallThick), rotate ry
                        const wallBox = new THREE.BoxGeometry(this.cellSize, this.wallHeight, wallThick);
                        const w = new THREE.Mesh(wallBox, this.wallMat);
                        w.rotation.y = ry;
                        w.position.set(wx, wy, wz);
                        this.levelGroup.add(w);
                        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), miniLineMat);
                        this.minimapGroup.add(line);
                    };

                    if (cell.n) addWall(px, zPos+this.wallHeight/2, pz-this.cellSize/2, 0,
                        new THREE.Vector3(mpx-0.5, miniZPos, mpz-0.5),
                        new THREE.Vector3(mpx+0.5, miniZPos, mpz-0.5));
                    if (cell.s) addWall(px, zPos+this.wallHeight/2, pz+this.cellSize/2, Math.PI,
                        new THREE.Vector3(mpx-0.5, miniZPos, mpz+0.5),
                        new THREE.Vector3(mpx+0.5, miniZPos, mpz+0.5));
                    if (cell.e) addWall(px+this.cellSize/2, zPos+this.wallHeight/2, pz, -Math.PI/2,
                        new THREE.Vector3(mpx+0.5, miniZPos, mpz-0.5),
                        new THREE.Vector3(mpx+0.5, miniZPos, mpz+0.5));
                    if (cell.w) addWall(px-this.cellSize/2, zPos+this.wallHeight/2, pz, Math.PI/2,
                        new THREE.Vector3(mpx-0.5, miniZPos, mpz-0.5),
                        new THREE.Vector3(mpx-0.5, miniZPos, mpz+0.5));
                }
            }
        }

        // ミニマップ スタート・ゴール・プレイヤー
        const mkBox = (color) => new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshBasicMaterial({color}));

        this.miniStart = mkBox(0x2299ff);
        this.miniStart.position.set(
            this.maze.start.x - miniOffset,
            (this.maze.start.z - 1) * 3,
            this.maze.start.y - miniOffset
        );
        this.minimapGroup.add(this.miniStart);

        this.miniGoal = mkBox(0xff2222);
        this.miniGoal.position.set(
            this.maze.goal.x - miniOffset,
            (this.maze.goal.z - 1) * 3,
            this.maze.goal.y - miniOffset
        );
        this.minimapGroup.add(this.miniGoal);

        this.miniPlayer = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({color: 0xffff00}));
        this.minimapGroup.add(this.miniPlayer);

        this.resetPlayer();
    }

    resetPlayer() {
        this.player.x = this.maze.start.x;
        this.player.y = this.maze.start.y;
        this.player.z = this.maze.start.z;

        // スタート地点で壁がない方向を向く
        const startCell = this.maze.grid[this.player.z][this.player.y][this.player.x];
        const dirOptions = [
            {wall: 'n', dir: 0},
            {wall: 'e', dir: 1},
            {wall: 's', dir: 2},
            {wall: 'w', dir: 3},
        ];
        const openDir = dirOptions.find(d => !startCell[d.wall]);
        this.player.dir = openDir ? openDir.dir : 0;

        this.leavePawPrint();
        this.updateCameraInstant();
    }

    updateCameraInstant() {
        const px = (this.player.x - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const pz = (this.player.y - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const py = this.player.z * this.wallHeight + this.wallHeight * 0.5;

        this.camera.position.set(px, py, pz);
        this.pointLight.position.set(px, py, pz);

        const rotY = [0, -Math.PI/2, Math.PI, Math.PI/2][this.player.dir];
        this.camera.rotation.set(0, rotY, 0, 'YXZ');
        this.updateMinimapPlayer();
        document.getElementById('floor-display').innerText = this.player.z + 1;
    }

    updateMinimapPlayer() {
        const miniOffset = (MAZE_SIZE - 1) / 2;
        this.miniPlayer.position.set(
            this.player.x - miniOffset,
            (this.player.z - 1) * 3 + 0.5,
            this.player.y - miniOffset
        );
    }

    leavePawPrint() {
        const key = `${this.player.x},${this.player.y},${this.player.z}`;
        if (this.visitedTiles.has(key)) return;
        this.visitedTiles.add(key);

        const px = (this.player.x - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const pz = (this.player.y - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const py = this.player.z * this.wallHeight + 0.06;

        // 半分のサイズ
        const pawMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(this.cellSize * 0.5, this.cellSize * 0.5),
            this.pawMat
        );
        pawMesh.rotation.x = -Math.PI / 2;
        pawMesh.rotation.z = [0, -Math.PI/2, Math.PI, Math.PI/2][this.player.dir];
        pawMesh.position.set(px, py, pz);
        this.levelGroup.add(pawMesh);

        if (this.visitedTiles.size > 1) AudioSys.playPaw();
    }

    setupInputs() {
        window.addEventListener('keydown', (e) => {
            if (this.gameState !== 'PLAYING') return;
            switch (e.key.toLowerCase()) {
                case 'w': case 'arrowup':    this.moveForward();  break;
                case 's': case 'arrowdown':  this.moveBackward(); break;
                case 'a': case 'arrowleft':  this.turnLeft();     break;
                case 'd': case 'arrowright': this.turnRight();    break;
            }
        });

        const btnEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
        const bindBtn = (id, fn) => {
            document.getElementById(id).addEventListener(btnEvent, (e) => {
                e.preventDefault();
                if (this.gameState === 'PLAYING') fn.call(this);
            });
        };
        bindBtn('btn-w', this.moveForward);
        bindBtn('btn-s', this.moveBackward);
        bindBtn('btn-a', this.turnLeft);
        bindBtn('btn-d', this.turnRight);

        document.getElementById('start-btn').addEventListener('click', () => {
            AudioSys.init();
            if (this.gameState === 'TITLE' || this.gameState === 'COMPLETE') {
                this.startGame();
            }
        });
    }

    startGame() {
        document.getElementById('ui-layer').classList.add('hidden');
        if (this.gameState === 'COMPLETE') {
            this.maze.generate();
            this.buildLevel();
        }
        this.gameState = 'PLAYING';
    }

    winGame() {
        this.gameState = 'COMPLETE';
        AudioSys.playGoal();
        const t = TRANSLATIONS[currentLang];
        document.getElementById('ui-title').innerText = t.complete_title;
        document.getElementById('ui-desc').innerText  = t.complete_desc;
        document.getElementById('start-btn').innerText = t.restart;
        document.getElementById('ui-layer').classList.remove('hidden');
    }

    getDirVector(dir) {
        return [{x:0,y:-1,wall:'n'},{x:1,y:0,wall:'e'},{x:0,y:1,wall:'s'},{x:-1,y:0,wall:'w'}][dir];
    }

    moveForward()  { if (!this.isAnimating) { const v = this.getDirVector(this.player.dir); this.tryMove(v.x, v.y, v.wall); } }
    moveBackward() { if (!this.isAnimating) { const v = this.getDirVector((this.player.dir+2)%4); this.tryMove(v.x, v.y, v.wall); } }

    tryMove(dx, dy, wallDir) {
        const cell = this.maze.grid[this.player.z][this.player.y][this.player.x];
        if (!cell[wallDir]) {
            this.player.x += dx;
            this.player.y += dy;
            AudioSys.playWalk();
            this.animateMove();
        } else {
            AudioSys.playBump();
        }
    }

    turnLeft()  { if (!this.isAnimating) { this.player.dir = (this.player.dir+3)%4; AudioSys.playTurn(); this.animateTurn( Math.PI/2); } }
    turnRight() { if (!this.isAnimating) { this.player.dir = (this.player.dir+1)%4; AudioSys.playTurn(); this.animateTurn(-Math.PI/2); } }

    animateMove() {
        this.isAnimating = true;
        const targetX = (this.player.x - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const targetZ = (this.player.y - MAZE_SIZE/2 + 0.5) * this.cellSize;
        const startX = this.camera.position.x;
        const startZ = this.camera.position.z;
        const duration = 250;
        const startTime = performance.now();

        const anim = (time) => {
            let t = Math.min((time - startTime) / duration, 1);
            const e = 1 - Math.pow(1-t, 3);
            this.camera.position.x = startX + (targetX - startX) * e;
            this.camera.position.z = startZ + (targetZ - startZ) * e;
            this.pointLight.position.x = this.camera.position.x;
            this.pointLight.position.z = this.camera.position.z;
            if (t < 1) { requestAnimationFrame(anim); }
            else { this.isAnimating = false; this.onMoveComplete(); }
        };
        requestAnimationFrame(anim);
    }

    animateTurn(angleDelta) {
        this.isAnimating = true;
        const startRot  = this.camera.rotation.y;
        const targetRot = startRot + angleDelta;
        const duration  = 200;
        const startTime = performance.now();

        const anim = (time) => {
            let t = Math.min((time - startTime) / duration, 1);
            const e = 1 - Math.pow(1-t, 3);
            this.camera.rotation.y = startRot + (targetRot - startRot) * e;
            if (t < 1) { requestAnimationFrame(anim); }
            else {
                this.camera.rotation.y = [0, -Math.PI/2, Math.PI, Math.PI/2][this.player.dir];
                this.isAnimating = false;
            }
        };
        requestAnimationFrame(anim);
    }

    onMoveComplete() {
        this.leavePawPrint();
        this.updateMinimapPlayer();

        const cell = this.maze.grid[this.player.z][this.player.y][this.player.x];

        if (cell.stairDown) {
            AudioSys.playStairs();
            this.player.z--;
            this.animateFloorChange();
        } else if (cell.stairUp) {
            AudioSys.playStairs();
            this.player.z++;
            this.animateFloorChange();
        }

        if (this.player.x === this.maze.goal.x &&
            this.player.y === this.maze.goal.y &&
            this.player.z === this.maze.goal.z) {
            setTimeout(() => this.winGame(), 200);
        }
    }

    // エレベータ演出（オリジナル）
    animateFloorChange() {
        this.isAnimating = true;
        const targetY = this.player.z * this.wallHeight + this.wallHeight * 0.5;
        const startY  = this.camera.position.y;
        const duration  = 400;
        const startTime = performance.now();

        const anim = (time) => {
            let t = Math.min((time - startTime) / duration, 1);
            const eInOut = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
            this.camera.position.y  = startY + (targetY - startY) * eInOut;
            this.pointLight.position.y = this.camera.position.y;
            if (t < 1) {
                requestAnimationFrame(anim);
            } else {
                this.isAnimating = false;
                document.getElementById('floor-display').innerText = this.player.z + 1;
                this.updateMinimapPlayer();
                this.leavePawPrint();
            }
        };
        requestAnimationFrame(anim);
    }

    animate() {
        this.renderer.render(this.scene, this.camera);
        this.miniRenderer.render(this.miniScene, this.miniCamera);
        requestAnimationFrame(this.animate);
    }
}

window.onload = () => {
    // 初期言語適用
    applyLanguage('JA', 'TITLE');
    new Game();
};
</script>
</body>
</html>
