<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deca-Search v20260118.2 (Split Architecture) </title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;600&family=Noto+Sans+JP:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- Google Analytics (GA4) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QEJBQQMWT9"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QEJBQQMWT9');
    </script>

    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #020617;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: none;
        }

        .mono-font {
            font-family: 'Share Tech Mono', monospace;
        }

        .scanline {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 100%);
            background-size: 100% 4px;
            pointer-events: none;
        }

        .grid-cell {
            transition: all 0.2s ease-out;
            border: 1px solid #1e293b;
        }

        .grid-cell:hover {
            background-color: #0f172a;
            border-color: #06b6d4;
            transform: translateY(-2px);
            z-index: 20;
        }

        .btn-active {
            background-color: rgba(6, 182, 212, 0.2);
            border-color: #06b6d4;
            color: #22d3ee;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
        }

        .search-input:focus {
            outline: none;
            border-color: #06b6d4;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.2);
        }

        .loading-bar {
            transition: width 0.2s ease-out;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const BASE = 10;
        const STEPS = 100;
        const APP_VERSION = "v20260118.2";

        const SECTORS = [
            { id: 0, label: "GEN", full: "GENERAL", desc: "Standard English", file: "data_gen.json" },
            { id: 1, label: "MED", full: "MEDICAL", desc: "Diseases & Anatomy", file: "data_med.json" },
            { id: 2, label: "BIO", full: "BIOLOGY", desc: "Taxonomy & Species", file: "data_bio.json" },
            { id: 3, label: "CHEM", full: "CHEMICAL", desc: "Elements & Compounds", file: "data_chem.json" },
        ];

        const SLIDERS = [
            { idx: 1, name: "GRAND", pow: 7, color: "from-indigo-950 to-blue-900", freq: 60 },
            { idx: 2, name: "MAJOR", pow: 5, color: "from-blue-900 to-cyan-900", freq: 100 },
            { idx: 3, name: "MINOR", pow: 3, color: "from-cyan-900 to-teal-900", freq: 200 },
            { idx: 4, name: "PATCH", pow: 1, color: "from-teal-900 to-emerald-900", freq: 400 },
        ];

        const MULTIPLIERS = [1000000000, 10000000, 100000, 1000, 10];

        const AudioEngine = {
            ctx: null,
            init: () => { if (!AudioEngine.ctx) AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume(); },
            playTick: (freq) => {
                if (!AudioEngine.ctx) return;
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, t);
                osc.frequency.exponentialRampToValueAtTime(freq * 0.5, t + 0.1);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t); osc.stop(t + 0.15);
            },
            playFound: () => {
                if (!AudioEngine.ctx) return;
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, t);
                osc.frequency.linearRampToValueAtTime(880, t + 0.1);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t); osc.stop(t + 0.3);
            }
        };

        const hasDataInRange = (sortedIds, min, max) => {
            if (sortedIds.length === 0) return false;
            let left = 0;
            let right = sortedIds.length - 1;
            // Optimize: check if range is completely outside
            if (max <= sortedIds[0] || min > sortedIds[right]) return false;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (sortedIds[mid] >= min && sortedIds[mid] < max) return true;
                if (sortedIds[mid] < min) left = mid + 1;
                else right = mid - 1;
            }
            return false;
        };

        const App = () => {
            const [positions, setPositions] = useState([0, 0, 0, 0, 0]);
            const [dataMap, setDataMap] = useState({});
            const [sortedIds, setSortedIds] = useState([]);
            const [loadedSectors, setLoadedSectors] = useState(new Set()); // Track loaded sectors

            const [audioReady, setAudioReady] = useState(false);
            const [activeRow, setActiveRow] = useState(null);

            // Loading State
            const [isSystemReady, setIsSystemReady] = useState(false); // Initial load done?
            const [isDownloading, setIsDownloading] = useState(false); // Currently downloading?
            const [loadState, setLoadState] = useState("INITIALIZING");
            const [loadProgress, setLoadProgress] = useState(0);

            const [searchQuery, setSearchQuery] = useState("");
            const [isAutoPiloting, setIsAutoPiloting] = useState(false);

            // --- Generic File Loader ---
            const loadSectorData = async (sectorId) => {
                if (loadedSectors.has(sectorId)) return true; // Already loaded

                setIsDownloading(true);
                setLoadProgress(0);
                const sector = SECTORS[sectorId];
                setLoadState(`ACCESSING ${sector.full}...`);

                try {
                    const response = await fetch(sector.file);
                    if (!response.ok) throw new Error("File not found");

                    const contentLength = response.headers.get('Content-Length');
                    const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;
                    const reader = response.body.getReader();
                    let receivedLength = 0;
                    const chunks = [];

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        receivedLength += value.length;
                        if (totalBytes > 0) {
                            setLoadProgress(Math.round((receivedLength / totalBytes) * 100));
                        } else {
                            setLoadProgress(prev => Math.min(prev + 5, 90)); // Fake progress
                        }
                    }

                    // Decode
                    const chunksAll = new Uint8Array(receivedLength);
                    let position = 0;
                    for (let chunk of chunks) {
                        chunksAll.set(chunk, position);
                        position += chunk.length;
                    }
                    const text = new TextDecoder("utf-8").decode(chunksAll);
                    const json = JSON.parse(text);

                    // Merge Data
                    if (json && json.items) {
                        setDataMap(prev => {
                            const newMap = { ...prev, ...json.items };
                            // Update Sorted IDs for Heatmap
                            const newKeys = Object.keys(newMap).map(Number).sort((a, b) => a - b);
                            setSortedIds(newKeys);
                            return newMap;
                        });
                        setLoadedSectors(prev => new Set(prev).add(sectorId));
                    }

                    setIsDownloading(false);
                    return true;

                } catch (err) {
                    console.error(err);
                    setLoadState("DOWNLOAD FAILED");
                    setIsDownloading(false);
                    return false;
                }
            };

            // --- Initial Load (GEN only) ---
            useEffect(() => {
                const init = async () => {
                    const success = await loadSectorData(0); // Load General
                    if (success) {
                        setLoadState("SYSTEM ONLINE");
                        setIsSystemReady(true);
                    }
                };
                init();
            }, []);

            const enableAudio = () => { if (!audioReady) { AudioEngine.init(); setAudioReady(true); } };

            const globalIndex = useMemo(() => {
                return positions.reduce((acc, pos, idx) => acc + (pos * MULTIPLIERS[idx]), 0);
            }, [positions]);

            const getHeatmap = (levelIdx) => {
                if (sortedIds.length === 0) return [];
                let base = 0;
                for (let i = 0; i < levelIdx; i++) {
                    base += positions[i] * MULTIPLIERS[i];
                }
                const multiplier = MULTIPLIERS[levelIdx];
                const map = [];
                for (let step = 0; step < STEPS; step++) {
                    const min = base + (step * multiplier);
                    const max = base + ((step + 1) * multiplier);
                    if (hasDataInRange(sortedIds, min, max)) map.push(true);
                    else map.push(false);
                }
                return map;
            };

            const handleSectorClick = async (sectorId) => {
                enableAudio();

                // If data not loaded, load it first
                if (!loadedSectors.has(sectorId)) {
                    await loadSectorData(sectorId);
                }

                setPositions([sectorId, 0, 0, 0, 0]);
                AudioEngine.playTick(40);

                if (typeof gtag === 'function') {
                    gtag('event', 'select_content', { content_type: 'sector', item_id: SECTORS[sectorId].full });
                }
            };

            // ... (Pointer Events logic remains same) ...
            const handlePointerDown = (e, arrIdx) => { e.preventDefault(); enableAudio(); e.currentTarget.setPointerCapture(e.pointerId); setActiveRow(arrIdx); updateSliderFromPointer(e, arrIdx); };
            const handlePointerMove = (e, arrIdx) => { if (activeRow === arrIdx) updateSliderFromPointer(e, arrIdx); };
            const handlePointerUp = (e) => { e.currentTarget.releasePointerCapture(e.pointerId); setActiveRow(null); };
            const updateSliderFromPointer = (e, arrIdx) => {
                const rect = e.currentTarget.getBoundingClientRect();
                let percent = (e.clientX - rect.left) / rect.width;
                percent = Math.max(0, Math.min(1, percent));
                const newVal = Math.floor(percent * (STEPS - 1));
                if (positions[arrIdx] !== newVal) {
                    const newPos = [...positions]; newPos[arrIdx] = newVal; setPositions(newPos);
                    const freq = SLIDERS.find(s => s.idx === arrIdx)?.freq || 100; AudioEngine.playTick(freq);
                }
            };

            // ... (Search Logic: Auto load sector if needed) ...
            const performSearch = (e) => {
                e.preventDefault();
                if (!searchQuery) return;
                enableAudio();
                const q = searchQuery.toLowerCase().trim();
                if (typeof gtag === 'function') { gtag('event', 'search', { search_term: q }); }

                // Search in loaded data first
                const foundId = Object.keys(dataMap).find(key => {
                    const item = dataMap[key];
                    return item.en && item.en.toLowerCase() === q;
                });

                if (foundId) {
                    startAutoPilot(Number(foundId));
                } else {
                    // Note: Ideally we should ask server/index where the word is. 
                    // Since we are client-side only, we can't search unloaded sectors without loading them.
                    alert("NOT FOUND IN LOADED SECTORS");
                }
            };

            const startAutoPilot = (targetId) => {
                setIsAutoPiloting(true);
                AudioEngine.playFound();
                let remain = targetId;
                const newPos = [0, 0, 0, 0, 0];
                newPos[0] = Math.floor(remain / MULTIPLIERS[0]); remain %= MULTIPLIERS[0];
                newPos[1] = Math.floor(remain / MULTIPLIERS[1]); remain %= MULTIPLIERS[1];
                newPos[2] = Math.floor(remain / MULTIPLIERS[2]); remain %= MULTIPLIERS[2];
                newPos[3] = Math.floor(remain / MULTIPLIERS[3]); remain %= MULTIPLIERS[3];
                newPos[4] = Math.floor(remain / MULTIPLIERS[4]);
                setPositions(newPos);
                setTimeout(() => setIsAutoPiloting(false), 500);
            };

            const getDisplayData = (offset) => {
                const targetIdx = globalIndex + offset;
                const key = targetIdx.toString();
                if (dataMap[key]) {
                    return { value: dataMap[key], type: dataMap[key].sector || 'DATA', highlight: true, isDict: true };
                }
                return { value: `SEC::${(targetIdx * 12345).toString(16).toUpperCase().slice(0, 8)}`, type: 'VOID', highlight: false, isDict: false };
            };

            const currentSector = SECTORS.find(s => s.id === positions[0]) || SECTORS[0];

            return (
                <div className="flex flex-col h-screen w-screen bg-slate-950 text-slate-300 relative" onClick={enableAudio}>
                    {/* Header */}
                    <header className="flex-none h-14 border-b border-slate-800 flex items-center justify-between px-4 z-20 bg-slate-950/90 backdrop-blur gap-4">
                        <div className="flex items-center gap-2 flex-none">
                            <div className={`w-2 h-2 rounded-full ${audioReady ? 'bg-cyan-500 shadow-[0_0_10px_cyan]' : 'bg-slate-600 animate-pulse'}`}></div>
                            <h1 className="mono-font text-base md:text-lg font-bold text-cyan-500 tracking-wider hidden md:block">DECA-SEARCH {APP_VERSION}</h1>
                            <h1 className="mono-font text-base font-bold text-cyan-500 tracking-wider md:hidden">DS-v2026</h1>
                        </div>
                        <form onSubmit={performSearch} className="flex-1 max-w-md flex relative">
                            <input type="text" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} placeholder="SEARCH..." className="w-full bg-slate-900 border border-slate-700 rounded-l px-3 py-1 text-sm text-cyan-300 mono-font focus:outline-none focus:border-cyan-500 placeholder-slate-600 search-input" />
                            <button type="submit" className="bg-slate-800 border-y border-r border-slate-700 px-3 text-cyan-500 hover:bg-slate-700 rounded-r"><span className="mono-font text-xs font-bold">GO</span></button>
                        </form>
                        <div className="text-right flex-none hidden md:block">
                            <div className="text-xs text-cyan-400 mono-font font-bold">{currentSector.full}</div>
                            <div className="text-[10px] text-slate-500 mono-font">{sortedIds.length > 0 ? `${sortedIds.length.toLocaleString()} RECS` : loadState}</div>
                        </div>
                    </header>

                    {/* --- CONTROL --- */}
                    <section className="flex-1 flex flex-col relative z-10 min-h-0 border-b border-slate-800 shadow-xl">
                        {/* SECTOR BUTTONS */}
                        <div className="h-16 flex border-b border-slate-800/50 bg-slate-900/50">
                            {SECTORS.map((s) => {
                                const isActive = positions[0] === s.id;
                                // Visual indicator if sector is loaded
                                const isLoaded = loadedSectors.has(s.id);
                                return (
                                    <button key={s.id} onClick={() => handleSectorClick(s.id)} className={`flex-1 flex flex-col items-center justify-center border-r border-slate-800/50 transition-all duration-200 group ${isActive ? 'btn-active z-10' : 'hover:bg-slate-800/50 text-slate-500'}`}>
                                        <span className={`text-xs md:text-sm font-bold tracking-widest ${isActive ? 'text-cyan-300' : 'text-slate-400'}`}>
                                            {s.label} {isLoaded && <span className="text-[8px] text-cyan-700">‚óè</span>}
                                        </span>
                                        <span className="text-[8px] md:text-[9px] opacity-70 mono-font mt-1">{s.desc}</span>
                                    </button>
                                );
                            })}
                        </div>

                        {/* SLIDERS */}
                        {SLIDERS.map((lvl) => {
                            const val = positions[lvl.idx];
                            const heatmap = useMemo(() => getHeatmap(lvl.idx), [positions.slice(0, lvl.idx), sortedIds]);
                            const p = val / (STEPS - 1);

                            return (
                                <div key={lvl.idx} className="flex-1 relative border-b border-slate-800/50 last:border-0 group">
                                    <div className={`absolute inset-0 bg-gradient-to-r ${lvl.color} opacity-10 ${activeRow === lvl.idx ? 'opacity-30' : ''}`}></div>
                                    <div className="absolute left-0 top-0 bottom-0 w-24 bg-slate-950/30 border-r border-slate-800/30 flex flex-col justify-center px-3 z-10 pointer-events-none">
                                        <span className="text-[10px] font-bold text-cyan-700 tracking-widest leading-none">L{lvl.idx}</span>
                                        <span className="text-xs md:text-sm font-semibold text-slate-400 mt-1">{lvl.name}</span>
                                        <span className="text-[9px] text-slate-600 mono-font mt-0.5">x10^{lvl.pow}</span>
                                    </div>
                                    <div className="absolute left-24 right-0 top-0 bottom-0 px-8 cursor-ew-resize" style={{ touchAction: 'none' }} onPointerDown={(e) => handlePointerDown(e, lvl.idx)} onPointerMove={(e) => handlePointerMove(e, lvl.idx)} onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp}>
                                        <div className="absolute inset-x-8 top-1/2 -translate-y-1/2 h-1 flex pointer-events-none opacity-50">
                                            {heatmap.map((hasData, i) => (<div key={i} className={`flex-1 h-full mx-[1px] rounded-sm ${hasData ? 'bg-cyan-500 shadow-[0_0_4px_cyan]' : 'bg-slate-800'}`}></div>))}
                                        </div>
                                        <div className="absolute inset-x-8 h-[1px] bg-slate-700/30 top-1/2 -translate-y-1/2 pointer-events-none"></div>
                                        <div className="absolute top-0 bottom-0 pointer-events-none transition-all duration-75 ease-out" style={{ left: `${p * 100}%`, transform: `translateX(-${p * 100}%)`, width: '60px' }}>
                                            <div className={`h-full w-1 mx-auto transition-colors ${activeRow === lvl.idx ? 'bg-cyan-400' : 'bg-cyan-600/50 group-hover:bg-cyan-500/80'}`}></div>
                                            <div className={`absolute -top-3 left-1/2 -translate-x-1/2 bg-slate-900 border border-cyan-800 text-cyan-400 text-xl md:text-2xl font-bold px-3 py-1 rounded shadow-[0_0_15px_rgba(0,0,0,0.8)] mono-font z-40 transition-all ${activeRow === lvl.idx || isAutoPiloting ? 'scale-110 border-cyan-500 text-cyan-200' : ''}`}>{String(val).padStart(2, '0')}</div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </section>

                    {/* --- GRID --- */}
                    <section className="h-[35vh] bg-slate-950 relative z-10 p-2 border-t border-cyan-900/30">
                        <div className="h-full w-full grid grid-cols-5 grid-rows-2 gap-2">
                            {Array.from({ length: 10 }).map((_, offset) => {
                                const data = getDisplayData(offset);
                                const isDict = data.isDict;
                                return (
                                    <div key={offset} className={`grid-cell relative rounded p-2 flex flex-col justify-between overflow-hidden ${data.highlight ? 'bg-cyan-950/30 border-cyan-700' : 'bg-slate-900/50'} ${isAutoPiloting && data.highlight ? 'animate-pulse' : ''}`}>
                                        <div className="flex justify-between items-start text-[8px] md:text-[10px] text-slate-500"><span className="mono-font text-slate-400">+{offset}</span><span className="mono-font opacity-50">{data.type}</span></div>
                                        <div className="flex-1 flex flex-col items-center justify-center text-center overflow-hidden w-full">
                                            {isDict ? (
                                                <div className="w-full animate-in fade-in duration-75"><div className="text-cyan-100 text-sm md:text-lg font-bold mb-1 truncate leading-none pb-1">{data.value.en}</div><div className="text-cyan-500 text-[10px] md:text-xs truncate leading-tight">{data.value.fi}</div><div className="text-slate-400 text-[10px] md:text-xs truncate leading-tight font-sans">{data.value.ja}</div></div>
                                            ) : (<div className="text-slate-600 text-xs md:text-sm mono-font font-bold break-all leading-tight opacity-50">{data.value}</div>)}
                                        </div>
                                        <div className="text-[8px] text-slate-700 text-center truncate">ID: {(globalIndex + offset).toString()}</div>
                                        {data.highlight && <div className="absolute top-0 right-0 w-2 h-2 bg-cyan-500 shadow-[0_0_10px_rgba(6,182,212,0.8)]"></div>}
                                    </div>
                                );
                            })}
                        </div>
                    </section>

                    <footer className="h-6 bg-slate-950 border-t border-slate-900 flex items-center justify-end px-4 z-20">
                        <div className="text-[9px] md:text-[10px] text-slate-600 mono-font">
                            <span className="opacity-50">SYSTEM:</span> <a href="https://gitlab.com/junichiyamada/junichiyamada.gitlab.io" target="_blank" className="text-cyan-800 hover:text-cyan-500 transition-colors">JAMAD aka junichi.yamada</a>
                            <span className="mx-1 opacity-20">|</span>
                            <span className="opacity-50">DATA:</span> <a href="https://github.com/dwyl/english-words" target="_blank" className="text-slate-600 hover:text-slate-400">Open Source</a>
                            <span className="ml-2 opacity-30">| Built with React & Tailwind</span>
                        </div>
                    </footer>

                    <div className="absolute inset-0 pointer-events-none z-30 scanline opacity-20"></div>

                    {/* --- LOADING OVERLAY (Dual Mode) --- */}
                    {(!audioReady || isDownloading) && (
                        <div className="absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center">
                            <div className="border border-cyan-900 bg-slate-900/90 p-8 max-w-sm text-center shadow-2xl rounded-sm w-full mx-4">
                                <h2 className="text-cyan-500 text-xl font-bold mb-2 mono-font tracking-widest">DECA-SEARCH {APP_VERSION}</h2>
                                <div className="text-slate-400 text-sm mb-6 leading-relaxed mono-font">{loadState}</div>

                                {isDownloading || !isSystemReady ? (
                                    <div className="w-full h-1 bg-slate-800 mb-6 relative overflow-hidden">
                                        <div className="h-full bg-cyan-500 shadow-[0_0_10px_cyan] loading-bar" style={{ width: `${loadProgress}%` }}></div>
                                    </div>
                                ) : (
                                    <button onClick={() => { AudioEngine.init(); setAudioReady(true); }} className="px-6 py-2 bg-cyan-900/50 hover:bg-cyan-800 text-cyan-200 text-sm font-bold border border-cyan-700 tracking-wider transition-all shadow-[0_0_15px_rgba(6,182,212,0.3)] w-full">[ ACTIVATE SYSTEM ]</button>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>