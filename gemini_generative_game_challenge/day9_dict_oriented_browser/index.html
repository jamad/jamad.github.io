<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordGrower Browser v1.4</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (JSX変換用) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { touch-action: manipulation; }
        /* スクロールバーのカスタマイズ */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        
        .animate-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 font-sans h-screen overflow-hidden">

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- Icons (SVG Components) ---
    // Lucideアイコンを単独HTMLで動かすためにコンポーネント化しています
    const IconWrapper = ({ children, className, ...props }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
    );
    const BookOpen = (p) => <IconWrapper {...p}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconWrapper>;
    const Search = (p) => <IconWrapper {...p}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></IconWrapper>;
    const Volume2 = (p) => <IconWrapper {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></IconWrapper>;
    const VolumeX = (p) => <IconWrapper {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></IconWrapper>;
    const Download = (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></IconWrapper>;
    const RefreshCw = (p) => <IconWrapper {...p}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></IconWrapper>;
    const Languages = (p) => <IconWrapper {...p}><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></IconWrapper>;
    const XIcon = (p) => <IconWrapper {...p}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconWrapper>;
    const Check = (p) => <IconWrapper {...p}><polyline points="20 6 9 17 4 12"/></IconWrapper>;
    const XCircle = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></IconWrapper>;

    // --- Audio System ---
    const playSound = (type) => {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gainNode = ctx.createGain();
            osc.connect(gainNode);
            gainNode.connect(ctx.destination);
            const now = ctx.currentTime;

            switch (type) {
                case 'tap': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                case 'levelup': osc.type = 'triangle'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.1); osc.frequency.linearRampToValueAtTime(1200, now + 0.2); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); break;
                case 'menu': osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.15); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.15); osc.start(now); osc.stop(now + 0.15); break;
                case 'reset': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.3); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); break;
                case 'load': osc.type = 'square'; osc.frequency.setValueAtTime(220, now); osc.frequency.setValueAtTime(440, now + 0.1); osc.frequency.setValueAtTime(880, now + 0.2); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.6); osc.start(now); osc.stop(now + 0.6); break;
            }
        } catch (e) { console.error(e); }
    };

    // --- Color Helper ---
    const getWordColor = (count) => {
        const maxCount = 10;
        const startColor = { r: 239, g: 68, b: 68 };
        const endColor = { r: 31, g: 41, b: 55 };
        if (count <= 0) return `rgb(${startColor.r}, ${startColor.g}, ${startColor.b})`;
        if (count >= maxCount) return `rgb(${endColor.r}, ${endColor.g}, ${endColor.b})`;
        const ratio = count / maxCount;
        const r = Math.round(startColor.r + (endColor.r - startColor.r) * ratio);
        const g = Math.round(startColor.g + (endColor.g - startColor.g) * ratio);
        const b = Math.round(startColor.b + (endColor.b - startColor.b) * ratio);
        return `rgb(${r}, ${g}, ${b})`;
    };

    const DEMO_TEXT = `Welcome to the WordGrower Browser. This is a prototype designed to help you learn new vocabulary. URLを入力して記事を読み込んでみてください。`;

    // --- Main Component ---
    function WordGrowerApp() {
        const [url, setUrl] = useState('');
        const [content, setContent] = useState([]);
        const [dictionary, setDictionary] = useState({});
        const [popup, setPopup] = useState({ visible: false, x: 0, y: 0, word: '' });
        const [isLoading, setIsLoading] = useState(false);
        const [soundEnabled, setSoundEnabled] = useState(true);
        
        // メニュー外クリック判定用の参照
        const popupRef = useRef(null);
        // 初回ロード完了フラグ（無限ループ防止）
        const [isLoaded, setIsLoaded] = useState(false);

        // --- 1. LocalStorage Loading (起動時1回のみ) ---
        useEffect(() => {
            const savedData = localStorage.getItem('wordGrowerDictionary');
            if (savedData) {
                try {
                    setDictionary(JSON.parse(savedData));
                } catch(e) { console.error("Load failed", e); }
            } else {
                // 初回のみデモデータをセット
                setDictionary({ "WordGrower": 10, "Browser": 5 });
            }
            processText(DEMO_TEXT);
            setIsLoaded(true);
        }, []);

        // --- 2. LocalStorage Saving (辞書更新時毎回) ---
        useEffect(() => {
            if (isLoaded) {
                localStorage.setItem('wordGrowerDictionary', JSON.stringify(dictionary));
            }
        }, [dictionary, isLoaded]);

        const processText = (text, lang = 'ja-JP') => {
            setIsLoading(true);
            let segments = [];
            
            // Intl.Segmenter対応チェック
            if (typeof Intl.Segmenter !== 'undefined') {
                const segmenter = new Intl.Segmenter(lang, { granularity: 'word' });
                segments = Array.from(segmenter.segment(text)).map(seg => ({
                    text: seg.segment,
                    isWordLike: seg.isWordLike
                }));
            } else {
                // フォールバック（空白区切り）
                segments = text.split(/(\s+)/).map(s => ({
                    text: s,
                    isWordLike: /\S/.test(s) // 空白以外を単語とみなす
                }));
            }

            setTimeout(() => {
                setContent(segments);
                setIsLoading(false);
                if(soundEnabled) playSound('load');
            }, 600);
        };

        const handleExtract = async (e) => {
            e.preventDefault();
            if (!url) return;
            setIsLoading(true);

            try {
                // AllOrigins Proxyを使用
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);
                const data = await response.json();

                if (data.contents) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(data.contents, 'text/html');
                    
                    // 不要タグ削除
                    doc.querySelectorAll('script, style, noscript, iframe, nav, footer, header, svg').forEach(el => el.remove());
                    
                    const text = doc.body.innerText || "";
                    
                    let lang = 'en-US';
                    if (url.includes('.jp') || url.includes('jp')) lang = 'ja-JP';
                    else if (url.includes('.fi') || url.includes('fi')) lang = 'fi-FI';

                    processText(text, lang);
                } else {
                    throw new Error("No content");
                }
            } catch (error) {
                console.error("Fetch failed:", error);
                alert("記事を取得できませんでした。セキュリティ制限の強いサイトの可能性があります。");
                setIsLoading(false);
            }
        };

        const handleWordClick = (word) => {
            if (!word) return;
            setDictionary(prev => {
                const currentCount = prev[word] || 0;
                if (currentCount >= 10) return prev;
                const newCount = currentCount + 1;
                if (soundEnabled) {
                    if (newCount === 10) playSound('levelup');
                    else playSound('tap');
                }
                return { ...prev, [word]: newCount };
            });
        };

        const handleMaster = () => {
            if (!popup.word) return;
            setDictionary(prev => ({ ...prev, [popup.word]: 10 }));
            if (soundEnabled) playSound('levelup');
            setPopup({ ...popup, visible: false });
        };

        const handleReset = () => {
            if (!popup.word) return;
            setDictionary(prev => ({ ...prev, [popup.word]: 0 }));
            if (soundEnabled) playSound('reset');
            setPopup({ ...popup, visible: false });
        };

        const exportDictionary = () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dictionary, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "my_word_dictionary.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        };

        // --- Long Press Logic ---
        const longPressTimer = useRef(null);
        const isLongPress = useRef(false);

        const startPress = (e, word) => {
            isLongPress.current = false;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            longPressTimer.current = setTimeout(() => {
                isLongPress.current = true;
                if (navigator.vibrate) navigator.vibrate(50);

                setPopup({
                    visible: true,
                    x: clientX,
                    y: clientY,
                    word: word
                });
                if (soundEnabled) playSound('menu');
            }, 600);
        };

        const endPress = (e, word) => {
            clearTimeout(longPressTimer.current);
            if (!isLongPress.current) {
                handleWordClick(word);
            }
            // 長押し判定済みの場合は何もしない
        };

        // --- Menu Outside Click (Fixed) ---
        useEffect(() => {
            const handleClickOutside = (event) => {
                if (popup.visible && popupRef.current && !popupRef.current.contains(event.target)) {
                    setPopup(p => ({ ...p, visible: false }));
                }
            };
            
            if (popup.visible) {
                // イベント登録を少し遅延させずとも、mousedown/touchstartで判定すれば
                // 直前のタッチ終了イベントによる誤動作を防げることが多い
                document.addEventListener('mousedown', handleClickOutside);
                document.addEventListener('touchstart', handleClickOutside);
            }

            return () => {
                document.removeEventListener('mousedown', handleClickOutside);
                document.removeEventListener('touchstart', handleClickOutside);
            };
        }, [popup.visible]);


        return (
            <div className="flex flex-col h-screen bg-gray-50">
                {/* Header */}
                <header className="bg-white shadow-sm p-4 sticky top-0 z-10 flex-shrink-0">
                    <div className="max-w-4xl mx-auto flex gap-2 items-center">
                        <div className="flex-1 flex items-center bg-gray-100 rounded-lg px-3 py-2">
                            <BookOpen className="w-5 h-5 text-gray-400 mr-2 flex-shrink-0" />
                            <input type="text" placeholder="URLを入力 (例: https://example.com)"
                                className="bg-transparent border-none outline-none w-full text-sm" value={url} onChange={(e)=> setUrl(e.target.value)}
                            />
                        </div>
                        <button onClick={handleExtract}
                            className="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 active:scale-95 transition flex-shrink-0">
                            <Search className="w-5 h-5" />
                        </button>
                        <div className="w-px h-6 bg-gray-300 mx-1 flex-shrink-0"></div>
                        <button onClick={()=> setSoundEnabled(!soundEnabled)}
                            className={`p-2 rounded-lg transition flex-shrink-0 ${soundEnabled ? 'text-blue-600 bg-blue-50' : 'text-gray-400'}`}>
                            {soundEnabled ? <Volume2 className="w-5 h-5" /> : <VolumeX className="w-5 h-5" />}
                        </button>
                        <button onClick={exportDictionary} className="p-2 rounded-lg text-gray-600 hover:bg-gray-100 flex-shrink-0" title="辞書を保存">
                            <Download className="w-5 h-5" />
                        </button>
                    </div>
                </header>

                {/* Main Content */}
                <main className="flex-1 overflow-y-auto p-4 md:p-8">
                    <div className="max-w-3xl mx-auto bg-white min-h-[500px] shadow-sm rounded-xl p-6 md:p-10 leading-relaxed text-lg relative">
                        {isLoading && (
                            <div className="absolute inset-0 bg-white/80 flex flex-col items-center justify-center z-10 rounded-xl">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
                                <p className="text-gray-500 font-medium">Loading...</p>
                            </div>
                        )}
                        <div className="text-justify break-words">
                            {content.length > 0 ? content.map((item, index) => {
                                if (!item.isWordLike) return <span key={index}>{item.text}</span>;
                                
                                const count = dictionary[item.text] || 0;
                                const color = getWordColor(count);
                                const isMastered = count >= 10;

                                return (
                                    <span key={index} className={`inline-block cursor-pointer select-none transition-colors duration-300 rounded px-0.5 mx-0.5 ${isMastered ? '' : 'font-medium'} active:bg-gray-100`}
                                        style={{ color: color }}
                                        onMouseDown={(e)=> startPress(e, item.text)}
                                        onMouseUp={(e) => endPress(e, item.text)}
                                        onMouseLeave={() => clearTimeout(longPressTimer.current)}
                                        onTouchStart={(e) => startPress(e, item.text)}
                                        onTouchEnd={(e) => {
                                            if(isLongPress.current) e.preventDefault();
                                            endPress(e, item.text);
                                        }}
                                        onContextMenu={(e) => e.preventDefault()}
                                    >{item.text}</span>
                                );
                            }) : (
                                <div className="text-center text-gray-400 mt-20">
                                    <p>URLを入力してボタンを押してください。</p>
                                </div>
                            )}
                        </div>
                    </div>
                </main>

                {/* Popup Menu */}
                {popup.visible && (
                    <div ref={popupRef}
                        className="fixed z-50 bg-white rounded-lg shadow-xl border border-gray-200 w-64 overflow-hidden animate-in"
                        style={{ 
                            top: Math.min(popup.y + 10, window.innerHeight - 300), 
                            left: Math.min(popup.x - 100, window.innerWidth - 260) > 0 ? Math.min(popup.x - 100, window.innerWidth - 260) : 10
                        }}
                    >
                        <div className="bg-gray-50 px-4 py-2 border-b flex justify-between items-center">
                            <span className="font-bold text-gray-700 truncate max-w-[120px]">{popup.word}</span>
                            <span className="text-xs bg-gray-200 px-2 py-0.5 rounded-full text-gray-600">Lv. {dictionary[popup.word] || 0}</span>
                        </div>
                        <div className="p-2 space-y-2">
                            <button onClick={handleMaster}
                                className="w-full flex items-center justify-center gap-2 p-2 bg-green-50 text-green-700 hover:bg-green-100 rounded-md transition text-sm font-bold border border-green-200">
                                <Check className="w-4 h-4" /> Mastered!
                            </button>
                            <button onClick={handleReset}
                                className="w-full flex items-center justify-center gap-2 p-2 text-gray-500 hover:bg-gray-100 hover:text-red-600 rounded-md transition text-xs border border-transparent hover:border-red-100">
                                <RefreshCw className="w-3 h-3" /> リセット
                            </button>
                            {/* 明示的な閉じるボタン */}
                            <button onClick={() => setPopup(p => ({ ...p, visible: false }))}
                                className="w-full flex items-center justify-center gap-2 p-2 mt-2 text-gray-500 hover:bg-gray-100 rounde