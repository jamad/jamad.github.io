<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Immune Wars: Evolution</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #fff;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            width: 100vw;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            overflow: hidden;
            border-right: 2px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-panel {
            width: 220px;
            background-color: #111;
            display: flex;
            flex-direction: row;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            z-index: 10;
            position: relative;
        }

        #food-list-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 5px;
            overflow-y: auto;
            background-color: #1a1a1a;
        }

        #trash-zone {
            width: 80px;
            background: repeating-linear-gradient(
                45deg,
                #220000,
                #220000 10px,
                #330000 10px,
                #330000 20px
            );
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid #444;
            color: #ff4444;
            font-family: 'Orbitron', sans-serif;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            letter-spacing: 4px;
            font-weight: bold;
        }

        .section-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            text-align: center;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .food-item {
            background: linear-gradient(145deg, #2a2a2a, #202020);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px 2px;
            margin-bottom: 8px;
            color: #ddd;
            font-size: 12px;
            text-align: center;
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: none;
            position: relative;
            z-index: 11;
        }
        
        .food-item:active { cursor: grabbing; }

        .food-item.bad-food {
            border-color: #663333;
            background: linear-gradient(145deg, #2a2020, #201a1a);
        }

        .food-icon { font-size: 26px; margin-bottom: 4px; pointer-events: none; }
        .food-name { pointer-events: none; }

        .dragging {
            opacity: 0.8;
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            width: 120px;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            background: rgba(30,30,30,0.9);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            z-index: 5;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .subtitle {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.8;
            padding: 0 20px;
            max-width: 500px;
        }
        
        .instruction { color: #0ff; font-weight: bold; }
        .warning { color: #ff4444; font-weight: bold; }

        .start-btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            border-radius: 4px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        #message-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }

        @media (max-width: 600px) {
            #ui-panel { width: 140px; }
            #trash-zone { width: 50px; font-size: 12px; }
            .food-item { font-size: 10px; }
            .food-icon { font-size: 20px; }
            .title { font-size: 24px; }
            .subtitle { font-size: 11px; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div class="stat-box" style="border-color:#ff3333; color:#ff3333">ENEMIES: <span id="enemy-count">0</span></div>
            <div class="stat-box">CELLS: <span id="cell-count">0</span></div>
        </div>
        <div id="message-log"></div>
        
        <div id="overlay">
            <div class="title">IMMUNE WARS</div>
            <div class="subtitle">
                <span class="instruction">ã€æ“ä½œæ–¹æ³•ã€‘</span><br>
                ãƒªã‚¹ãƒˆã®é£Ÿå“ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§æ“ä½œã—ã¾ã™ã€‚<br>
                â—€ å·¦ï¼ˆç”»é¢ï¼‰ã¸ï¼š é£Ÿã¹ã‚‹ï¼ˆæ „é¤Šå¸åï¼‰<br>
                â–¶ å³ï¼ˆç¸æ¨¡æ§˜ï¼‰ã¸ï¼š æ¨ã¦ã‚‹ï¼ˆã‚´ãƒŸç®±ï¼‰<br><br>
                <span class="warning">å¤‰æ›´ç‚¹</span><br>
                æ•µã¯æ‚ªã„é£Ÿäº‹ã‚’ã¨ã‚‹ã¨<b>èµ¤ãå¤‰ç•°ã—æ”»æ’ƒåŠ›ãŒå€å¢—</b>ã—ã¾ã™ã€‚<br>
                å¼±ã„æ•µã¯é€ƒã’ã¾ã™ãŒã€<b>å¼·ããªã‚‹ã¨è¥²ã£ã¦ãã¾ã™</b>ã€‚<br>
                4ç§’ã”ã¨ã«åˆ†è£‚ã™ã‚‹ã®ã§æ—©ã‚ã«å¯¾å‡¦ã—ã¦ãã ã•ã„ã€‚
            </div>
            <button class="start-btn" id="startBtn">START MISSION</button>
        </div>
    </div>

    <div id="ui-panel">
        <div id="food-list-container">
            <div class="section-header">MENU</div>
            <div id="food-list">
                <!-- JSã§ç”Ÿæˆ -->
            </div>
        </div>
        <div id="trash-zone">TRASH</div>
    </div>

<script>
/**
 * AUDIO SYSTEM
 */
const AudioSys = {
    ctx: null,
    init: function() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        } catch(e) {}
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot: function() { this.playTone(400 + Math.random()*200, 'square', 0.1, 0.05); },
    playEat: function() { this.playTone(800 + Math.random()*200, 'sine', 0.15, 0.1); },
    playSpawn: function() { this.playTone(600, 'triangle', 0.2, 0.05); },
    playTrash: function() { this.playTone(150, 'sawtooth', 0.2, 0.05); },
    playExplosion: function() { 
        this.playTone(100, 'sawtooth', 0.2, 0.1);
        this.playTone(80, 'square', 0.2, 0.1);
    },
    playPowerUp: function(isBad) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        if(isBad) {
            // æ‚ªã„ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—: ä½ãä¸æ°—å‘³ãªéŸ³
            osc.frequency.setValueAtTime(150, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(80, this.ctx.currentTime + 0.5);
            osc.type = 'sawtooth';
        } else {
            osc.frequency.setValueAtTime(400, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.3);
            osc.type = 'sine';
        }
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }
};

/**
 * GAME DATA
 */
const COLORS = {
    player: '#00ccff', 
    macrophage: '#00ff88',
    enemy1: '#4444ff', // é’ï¼ˆåˆæœŸï¼‰
    enemy2: '#8844ff', 
    nutrientGood: '#ffff00', 
    nutrientBad: '#cc00cc',  
    bullet: '#00ffff'
};

const FOOD_DB = [
    { id: 'broccoli', name: 'ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼', icon: 'ğŸ¥¦', type: 'good' },
    { id: 'salmon', name: 'é®­', icon: 'ğŸŸ', type: 'good' },
    { id: 'yogurt', name: 'ãƒ¨ãƒ¼ã‚°ãƒ«ãƒˆ', icon: 'ğŸ¥›', type: 'good' },
    { id: 'lemon', name: 'ãƒ¬ãƒ¢ãƒ³', icon: 'ğŸ‹', type: 'good' },
    { id: 'garlic', name: 'ãƒ‹ãƒ³ãƒ‹ã‚¯', icon: 'ğŸ§„', type: 'good' },
    { id: 'fries', name: 'ãƒãƒ†ãƒˆ', icon: 'ğŸŸ', type: 'bad' },
    { id: 'donut', name: 'ãƒ‰ãƒ¼ãƒŠãƒ„', icon: 'ğŸ©', type: 'bad' },
    { id: 'pizza', name: 'ãƒ”ã‚¶', icon: 'ğŸ•', type: 'bad' },
    { id: 'soda', name: 'ç‚­é…¸é£²æ–™', icon: 'ğŸ¥¤', type: 'bad' }
];

/**
 * VECTOR CLASS
 */
class Vec2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
    normalize() {
        let m = this.mag();
        if(m > 0) { this.x /= m; this.y /= m; }
        return this;
    }
    dist(v) { return Math.sqrt((this.x-v.x)**2 + (this.y-v.y)**2); }
    copy() { return new Vec2(this.x, this.y); }
    
    wrap(w, h) {
        if(this.x < 0) this.x = w;
        if(this.x > w) this.x = 0;
        if(this.y < 0) this.y = h;
        if(this.y > h) this.y = 0;
    }
}

/**
 * ENTITY CLASSES
 */
class Entity {
    constructor(x, y, radius, color) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(0, 0);
        this.acc = new Vec2(0, 0);
        this.radius = radius;
        this.color = color;
        this.dead = false;
        this.maxSpeed = 2;
        this.friction = 0.95;
    }

    update(w, h) {
        this.vel.add(this.acc);
        this.vel.mult(this.friction);
        if (this.vel.mag() > this.maxSpeed) {
            this.vel.normalize().mult(this.maxSpeed);
        }
        this.pos.add(this.vel);
        this.acc.mult(0);
        this.pos.wrap(w, h);
    }

    applyForce(force) {
        this.acc.add(force);
    }
    
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class ImmuneCell extends Entity {
    constructor(x, y, type) {
        super(x, y, 12, COLORS.player);
        this.type = type; 
        this.name = type === 'MACROPHAGE' ? 'ãƒã‚¯ãƒ­ãƒ•ã‚¡ãƒ¼ã‚¸' : (type === 'B-CELL' ? 'ï¼¢ç´°èƒ' : 'ï¼´ç´°èƒ');
        this.shootCooldown = 0;
        this.energy = 0;
        
        // ä¿®æ­£ï¼šã™ã¹ã¦ã®åˆæœŸç§»å‹•é€Ÿåº¦ã‚’åŠåˆ†ã«
        // å…ƒ: 1.5 -> æ–°: 0.75
        this.maxSpeed = 0.75; 
        this.hp = 20; // åŸºç¤ä½“åŠ›
        
        if (type === 'MACROPHAGE') {
            this.radius = 18;
            this.color = COLORS.macrophage;
            this.maxSpeed = 0.5; // å…ƒ: 1.2 -> æ–°: 0.6
            this.hp = 50; // é£Ÿç´°èƒã¯ã‚¿ãƒ•
        }
    }

    behavior(enemies, w, h) {
        let closest = null;
        let minDist = Infinity;
        let distVec = new Vec2(0,0);

        enemies.forEach(e => {
            let toEnemy = e.pos.copy().sub(this.pos);
            // ç”»é¢ç«¯å‡¦ç†
            if (toEnemy.x > w/2) toEnemy.x -= w; else if (toEnemy.x < -w/2) toEnemy.x += w;
            if (toEnemy.y > h/2) toEnemy.y -= h; else if (toEnemy.y < -h/2) toEnemy.y += h;
            let d = toEnemy.mag();
            if (d < minDist) {
                minDist = d;
                closest = e;
                distVec = toEnemy;
            }
        });

        if (closest) {
            distVec.normalize();
            if (this.type === 'MACROPHAGE') {
                // ãƒã‚¯ãƒ­ãƒ•ã‚¡ãƒ¼ã‚¸ã¯ç©æ¥µçš„ã«é£Ÿã¹ã‚‹
                this.applyForce(distVec.mult(0.25));
            } else {
                // B/Tç´°èƒã¯è·é›¢ã‚’å–ã£ã¦å°„æ’ƒ
                if (minDist < 150) this.applyForce(distVec.mult(-0.2));
                else if (minDist > 250) this.applyForce(distVec.mult(0.1));
                
                if (this.shootCooldown <= 0 && minDist < 350) {
                    this.shoot(distVec);
                    this.shootCooldown = (this.type === 'T-CELL') ? 30 : 45; 
                }
            }
        }
        this.shootCooldown--;
    }

    shoot(dir) {
        game.bullets.push(new Bullet(this.pos.x, this.pos.y, dir));
        AudioSys.playShoot();
    }
    
    absorb() {
        this.energy += 1;
        this.hp = Math.min(this.hp + 5, 100); // å›å¾©
        if(this.energy >= 3) {
            this.energy = 0;
            game.spawnMessage("å…ç–«ç´°èƒåˆ†è£‚ï¼", this.pos.x, this.pos.y);
            let child = new ImmuneCell(this.pos.x + 10, this.pos.y, this.type);
            child.maxSpeed = this.maxSpeed; // é€Ÿåº¦ç¶™æ‰¿
            game.cells.push(child);
        }
    }
    
    draw(ctx) {
        super.draw(ctx);
        // åå‰è¡¨ç¤º
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(this.name, this.pos.x, this.pos.y + this.radius + 12);
        // HPãƒãƒ¼
        ctx.fillStyle = "#0f0";
        ctx.fillRect(this.pos.x - 10, this.pos.y - this.radius - 8, 20 * (this.hp / (this.type==='MACROPHAGE'?50:20)), 3);
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 10, type === 1 ? COLORS.enemy1 : COLORS.enemy2);
        this.type = type; 
        
        // ä¿®æ­£ï¼šæ”»æ’ƒåŠ›(Power)ã®æ¦‚å¿µã‚’è¿½åŠ 
        this.power = type === 1 ? 5 : 8; 
        
        // ä¿®æ­£ï¼šç§»å‹•é€Ÿåº¦ã‚’åŠåˆ†ã«
        // å…ƒ: 2.5 -> æ–°: 1.25, å…ƒ: 1.0 -> æ–°: 0.5
        this.maxSpeed = type === 1 ? 1.25 : 0.5;
        
        this.radius = type === 1 ? 8 : 12;
        this.angle = 0;
        this.reproduceTimer = 0;
        
        // ä¿®æ­£ï¼šåˆ†è£‚é–“éš”ã‚’4ç§’ã«å›ºå®š (60fps * 4 = 240)
        this.reproduceInterval = 240; 
    }

    // ä¿®æ­£ï¼šè‰²ã‚’æ›´æ–°ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ”»æ’ƒåŠ›ãŒä¸ŠãŒã‚‹ã¨èµ¤ããªã‚‹ï¼‰
    updateColor() {
        // ãƒ‘ãƒ¯ãƒ¼ã«å¿œã˜ã¦èµ¤ã¿ã‚’å¢—ã™
        // åˆæœŸãƒ‘ãƒ¯ãƒ¼(5)ãªã‚‰é’ã€ãƒ‘ãƒ¯ãƒ¼ãŒ20ã‚’è¶…ãˆã‚‹ã¨çœŸã£èµ¤ã«è¿‘ã¥ã
        let t = Math.min((this.power - 5) / 40, 1); 
        
        // é’(0,0,255) -> èµ¤(255,0,0) ã¸ã®è£œé–“
        let r = Math.floor(50 + 205 * t);
        let g = Math.floor(50 * (1 - t));
        let b = Math.floor(255 * (1 - t));
        
        this.color = `rgb(${r},${g},${b})`;
        
        // ã‚µã‚¤ã‚ºã‚‚å°‘ã—å¤§ãã
        this.radius = Math.min(25, (this.type===1?8:12) + this.power * 0.3);
    }

    behavior(cells, w, h) {
        this.angle += 0.1;
        this.reproduceTimer++;

        // ä¿®æ­£ï¼š4ç§’ãŠãã«åˆ†è£‚
        if(this.reproduceTimer > this.reproduceInterval) {
            this.reproduceTimer = 0;
            this.split();
            return; // åˆ†è£‚ã—ãŸã‚‰ã“ã®å€‹ä½“ã¯æ¶ˆãˆã‚‹ã‹å‡¦ç†çµ‚äº†
        }

        let closest = null;
        let minDist = Infinity;
        cells.forEach(c => {
            let toCell = c.pos.copy().sub(this.pos);
            if (toCell.x > w/2) toCell.x -= w; else if (toCell.x < -w/2) toCell.x += w;
            if (toCell.y > h/2) toCell.y -= h; else if (toCell.y < -h/2) toCell.y += h;
            let d = toCell.mag();
            if (d < minDist) { minDist = d; closest = c; }
        });

        // ä¿®æ­£ï¼šAIæŒ™å‹•
        // å…ç–«ç´°èƒ(Power: HPã¨ã¿ãªã™)ã‚ˆã‚Šå¼·ã„ã‹ï¼Ÿ
        // åŸºæº–å€¤: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¹³å‡çš„ãªå¼·ã•ã‚’10-20ã¨ä»®å®š
        let immunityStrength = 20; 

        if (closest) {
            let dir = closest.pos.copy().sub(this.pos);
            if (dir.x > w/2) dir.x -= w; else if (dir.x < -w/2) dir.x += w;
            if (dir.y > h/2) dir.y -= h; else if (dir.y < -h/2) dir.y += h;
            dir.normalize();

            // ä¿®æ­£ï¼šå¼·ã„æ™‚ã¯è¥²ã†ã€å¼±ã„æ™‚ã¯é€ƒã’ã‚‹
            if (this.power >= immunityStrength) {
                // è¥²ã† (Chase)
                this.applyForce(dir.mult(0.15));
            } else {
                // é€ƒã’ã‚‹ (Flee) - è² ã®èµ°åŒ–æ€§
                this.applyForce(dir.mult(-0.10));
            }
        } else {
            // è¿‘ãã«ã„ãªã„ã¨ãã¯ãƒ©ãƒ³ãƒ€ãƒ 
            this.applyForce(new Vec2(Math.random()-0.5, Math.random()-0.5).mult(0.1));
        }
    }
    
    // æ‚ªã„æ „é¤Šç´ ã‚’é£Ÿã¹ãŸæ™‚ã®å‡¦ç†
    absorbBadNutrient() {
        game.spawnMessage("æ•µãŒå¤‰ç•°ï¼æ”»æ’ƒåŠ›å€å¢—", this.pos.x, this.pos.y, "#ff0000");
        // ä¿®æ­£ï¼šæ”»æ’ƒåŠ›ãŒå€ã«ãªã‚‹
        this.power *= 2;
        this.updateColor(); // è‰²æ›´æ–°
    }
    
    split() {
        if(game.enemies.length < 100) { 
            // ä¿®æ­£ï¼šèŠ±ç«ã®ã‚ˆã†ã«æ”¾å°„çŠ¶ã«ç™ºæ•£
            // 2ã¤ã«åˆ†è£‚ã—ã€åå¯¾æ–¹å‘ã«é£›ã³å‡ºã™
            let angle = Math.random() * Math.PI * 2;
            let speed = 2.5; // é£›ã³å‡ºã—é€Ÿåº¦

            // å­1
            let child1 = new Enemy(this.pos.x, this.pos.y, this.type);
            child1.vel = new Vec2(Math.cos(angle)*speed, Math.sin(angle)*speed);
            child1.power = this.power; // ãƒ‘ãƒ¯ãƒ¼ç¶™æ‰¿
            child1.updateColor();

            // å­2 (180åº¦åå¯¾)
            let child2 = new Enemy(this.pos.x, this.pos.y, this.type);
            child2.vel = new Vec2(Math.cos(angle + Math.PI)*speed, Math.sin(angle + Math.PI)*speed);
            child2.power = this.power;
            child2.updateColor();

            game.enemies.push(child1, child2);
            this.dead = true; // è¦ªã¯æ¶ˆæ»…ï¼ˆåˆ†è£‚ã—ãŸãŸã‚ï¼‰
            
            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            AudioSys.playSpawn();
            game.createParticles(this.pos.x, this.pos.y, this.color, 5);
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        
        ctx.beginPath();
        if (this.type === 1) {
            // ã‚¦ã‚¤ãƒ«ã‚¹å‹ï¼ˆãƒˆã‚²ãƒˆã‚²ï¼‰
            ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, 0); ctx.lineTo(0, this.radius); ctx.lineTo(-this.radius, 0);
        } else {
            // ãƒã‚¯ãƒ†ãƒªã‚¢å‹ï¼ˆå¤šè§’å½¢ï¼‰
            for(let i=0; i<8; i++) {
                let r = this.radius + (i%2===0 ? 2 : -2);
                let a = (Math.PI*2 / 8) * i;
                ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
        }
        ctx.fill();
        
        // ãƒ‘ãƒ¯ãƒ¼è¡¨ç¤º
        ctx.rotate(-this.angle); // æ–‡å­—ã¯å›è»¢ã•ã›ãªã„
        ctx.fillStyle = "#fff";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        // ctx.fillText(Math.floor(this.power), 0, 4); // æ•°å€¤ãŒè¦‹ãŸã„å ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆè§£é™¤
        
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, dir) {
        super(x, y, 3, COLORS.bullet);
        this.vel = dir.copy().mult(5); // å¼¾é€Ÿã‚‚å°‘ã—èª¿æ•´
        this.life = 60;
        this.friction = 1.0;
    }
    update(w, h) {
        super.update(w, h);
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
}

class Nutrient extends Entity {
    constructor(x, y, foodData) {
        super(x, y, 6, foodData.type === 'good' ? COLORS.nutrientGood : COLORS.nutrientBad);
        this.isGood = (foodData.type === 'good');
        this.foodData = foodData;
        this.friction = 1.0;
        this.life = 600; 
        this.maxSpeed = 1.0; // æ „é¤Šç´ ã‚‚ã‚†ã£ãã‚Šã«
    }
    
    behavior(cells, enemies, w, h) {
        this.life--;
        if(this.life <= 0) this.dead = true;

        let targets = this.isGood ? cells : enemies;
        let closest = null;
        let minDist = 250; 

        targets.forEach(t => {
            let toTarget = t.pos.copy().sub(this.pos);
            if (toTarget.x > w/2) toTarget.x -= w; else if (toTarget.x < -w/2) toTarget.x += w;
            if (toTarget.y > h/2) toTarget.y -= h; else if (toTarget.y < -h/2) toTarget.y += h;
            let d = toTarget.mag();
            if (d < minDist) { minDist = d; closest = t; }
        });

        if (closest) {
            let dir = closest.pos.copy().sub(this.pos);
            if (dir.x > w/2) dir.x -= w; else if (dir.x < -w/2) dir.x += w;
            if (dir.y > h/2) dir.y -= h; else if (dir.y < -h/2) dir.y += h;
            // å¸ã„å¯„ã›ã‚‰ã‚Œã‚‹é€Ÿåº¦
            dir.normalize().mult(0.2); 
            this.applyForce(dir);
        }
    }
}

class Particle extends Entity {
    constructor(x, y, color) {
        super(x, y, Math.random()*2+1, color);
        this.vel = new Vec2(Math.random()-0.5, Math.random()-0.5).mult(3);
        this.life = 30;
        this.friction = 0.9;
    }
    update(w, h) {
        super.update(w, h);
        this.life--;
        this.radius *= 0.9;
        if(this.life <= 0) this.dead = true;
    }
}

/**
 * UI MANAGER
 */
class UIManager {
    constructor(game) {
        this.game = game;
        this.listEl = document.getElementById('food-list');
        this.trashEl = document.getElementById('trash-zone');
        this.panelEl = document.getElementById('ui-panel');
        this.dragItem = null;
        this.dragData = null;
        this.touchOffset = {x:0, y:0};
        
        this.refillList();
    }
    
    refillList() {
        this.listEl.innerHTML = '';
        for(let i=0; i<6; i++) {
            this.addRandomFood();
        }
    }
    
    addRandomFood() {
        const food = FOOD_DB[Math.floor(Math.random() * FOOD_DB.length)];
        const el = document.createElement('div');
        el.className = 'food-item' + (food.type === 'bad' ? ' bad-food' : '');
        el.innerHTML = `<div class="food-icon">${food.icon}</div><div class="food-name">${food.name}</div>`;
        
        el.addEventListener('mousedown', (e) => this.startDrag(e, el, food));
        el.addEventListener('touchstart', (e) => this.startDrag(e, el, food), {passive: false});
        
        this.listEl.appendChild(el);
    }
    
    startDrag(e, el, food) {
        if(!this.game.isPlaying) return;

        const touch = e.touches ? e.touches[0] : e;
        const rect = el.getBoundingClientRect();
        
        this.touchOffset.x = touch.clientX - rect.left;
        this.touchOffset.y = touch.clientY - rect.top;
        
        this.dragItem = el.cloneNode(true);
        this.dragItem.classList.add('dragging');
        this.dragItem.style.width = rect.width + 'px';
        document.body.appendChild(this.dragItem);
        
        this.dragData = food;
        this.moveDrag(touch.clientX, touch.clientY);
        
        el.style.opacity = '0.3';
        this.originalEl = el;

        const moveHandler = (ev) => {
            const t = ev.touches ? ev.touches[0] : ev;
            this.moveDrag(t.clientX, t.clientY);
        };
        
        const endHandler = (ev) => {
            const t = ev.changedTouches ? ev.changedTouches[0] : ev;
            this.endDrag(t.clientX);
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('mouseup', endHandler);
            document.removeEventListener('touchend', endHandler);
        };

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('touchmove', moveHandler, {passive: false});
        document.addEventListener('mouseup', endHandler);
        document.addEventListener('touchend', endHandler);
    }
    
    moveDrag(x, y) {
        if(this.dragItem) {
            this.dragItem.style.left = (x - this.touchOffset.x) + 'px';
            this.dragItem.style.top = (y - this.touchOffset.y) + 'px';
        }
    }
    
    endDrag(x) {
        if(!this.dragItem) return;
        
        const panelRect = this.panelEl.getBoundingClientRect();
        const trashRect = this.trashEl.getBoundingClientRect();
        
        if (x < panelRect.left) {
            this.game.spawnFood(this.dragData);
            this.originalEl.remove();
            this.addRandomFood(); 
        } else if (x > trashRect.left) {
            AudioSys.playTrash();
            this.originalEl.remove();
            this.addRandomFood(); 
        } else {
            this.originalEl.style.opacity = '1';
        }
        
        this.dragItem.remove();
        this.dragItem = null;
        this.dragData = null;
        this.originalEl = null;
    }
}

/**
 * GAME MANAGER
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.ui = new UIManager(this);
        
        this.cells = [];
        this.enemies = [];
        this.bullets = [];
        this.nutrients = [];
        this.particles = [];
        
        this.isPlaying = false;
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.enemyCountEl = document.getElementById('enemy-count');
        this.cellCountEl = document.getElementById('cell-count');
    }

    resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.width = rect.width;
        this.height = rect.height;
    }

    start() {
        AudioSys.init();
        this.isPlaying = true;
        document.getElementById('overlay').style.display = 'none';
        
        this.cells = [];
        this.enemies = [];
        this.bullets = [];
        this.nutrients = [];
        this.particles = [];
        this.ui.refillList();

        // åˆæœŸé…ç½®
        this.cells.push(new ImmuneCell(this.width/2, this.height/2, 'MACROPHAGE'));
        this.cells.push(new ImmuneCell(this.width/2 - 40, this.height/2, 'B-CELL'));
        this.cells.push(new ImmuneCell(this.width/2 + 40, this.height/2, 'T-CELL'));
        
        for(let i=0; i<5; i++) { this.spawnEnemy(); }

        this.loop();
    }

    spawnEnemy() {
        let x = Math.random() * this.width;
        let y = Math.random() * this.height;
        if (this.cells.length > 0) {
             while(new Vec2(x,y).dist(this.cells[0].pos) < 250) {
                 x = Math.random() * this.width;
                 y = Math.random() * this.height;
             }
        }
        let type = Math.random() > 0.7 ? 2 : 1;
        this.enemies.push(new Enemy(x, y, type));
    }

    spawnFood(food) {
        AudioSys.playSpawn();
        // ä¿®æ­£: æ „é¤Šç´ ã®é€Ÿåº¦ã‚‚æ§ãˆã‚ã«
        for(let i=0; i<4; i++) {
            let n = new Nutrient(this.width, Math.random() * this.height, food);
            n.vel = new Vec2(-0.8 - Math.random()*1, Math.random() * 1 - 0.5); 
            this.nutrients.push(n);
        }
        
        if(food.type === 'bad') {
            this.spawnMessage("æœ‰å®³ç‰©è³ªæ¤œçŸ¥ï¼æ•µå¼·åŒ–æ³¨æ„", this.width/2, this.height/2, "#ff0000");
        }
    }
    
    spawnMessage(text, x, y, color='#fff') {
        const el = document.createElement('div');
        el.innerText = text;
        el.style.position = 'absolute';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        el.style.fontWeight = 'bold';
        el.style.fontSize = '14px';
        el.style.textShadow = '0 0 3px #000';
        el.style.pointerEvents = 'none';
        el.style.transition = 'all 1s ease-out';
        el.style.zIndex = 100;
        document.getElementById('game-container').appendChild(el);
        
        setTimeout(() => {
            el.style.top = (y - 50) + 'px';
            el.style.opacity = 0;
        }, 10);
        setTimeout(() => el.remove(), 1000);
    }

    createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    update() {
        if(!this.isPlaying) return;

        this.cells.forEach(c => {
            c.behavior(this.enemies, this.width, this.height);
            c.update(this.width, this.height);
        });

        this.enemies.forEach(e => {
            e.behavior(this.cells, this.width, this.height);
            e.update(this.width, this.height);
            
            // æ•µ vs å…ç–«
            this.cells.forEach(c => {
                let dist = c.pos.dist(e.pos);
                if(dist < c.radius + e.radius) {
                    
                    // ãƒã‚¯ãƒ­ãƒ•ã‚¡ãƒ¼ã‚¸ã®æ•é£Ÿ
                    if(c.type === 'MACROPHAGE') {
                        // æ•µãŒå¼·ã™ãã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
                        if (e.power > c.hp / 2) {
                            c.hp -= 5;
                            e.dead = true; // ãã‚Œã§ã‚‚é£Ÿã¹ã‚‹ï¼ˆç›¸æ‰“ã¡æ°—å‘³ï¼‰
                            this.createParticles(e.pos.x, e.pos.y, "#ff0000", 10);
                        } else {
                            e.dead = true;
                            AudioSys.playEat();
                            this.createParticles(e.pos.x, e.pos.y, e.color, 10);
                        }
                    } else {
                        // ä»–ã®ç´°èƒã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
                        c.hp -= (e.power * 0.5); // ãƒ‘ãƒ¯ãƒ¼ä¾å­˜ãƒ€ãƒ¡ãƒ¼ã‚¸
                        if(c.hp <= 0) {
                            c.dead = true;
                            this.createParticles(c.pos.x, c.pos.y, c.color, 20);
                            AudioSys.playExplosion();
                        }
                    }
                }
            });
        });

        // å¼¾ã®å½“ãŸã‚Šåˆ¤å®š
        this.bullets.forEach(b => {
            b.update(this.width, this.height);
            this.enemies.forEach(e => {
                if(!e.dead && b.pos.dist(e.pos) < e.radius + b.radius) {
                    e.power -= 2; // ãƒ‘ãƒ¯ãƒ¼ãƒ€ã‚¦ãƒ³
                    if (e.power <= 0) {
                        e.dead = true;
                        AudioSys.playExplosion();
                        this.createParticles(e.pos.x, e.pos.y, e.color, 15);
                    } else {
                        // ãƒ’ãƒƒãƒˆæ¼”å‡º
                        b.dead = true;
                        this.createParticles(b.pos.x, b.pos.y, COLORS.bullet, 3);
                    }
                }
            });
        });

        // æ „é¤Šç´ ã®å½“ãŸã‚Šåˆ¤å®š
        this.nutrients.forEach(n => {
            n.behavior(this.cells, this.enemies, this.width, this.height);
            n.update(this.width, this.height);
            
            this.cells.forEach(c => {
                if(!n.dead && n.isGood && c.pos.dist(n.pos) < c.radius + n.radius + 15) {
                    n.dead = true;
                    AudioSys.playPowerUp(false);
                    c.absorb(); 
                }
            });
            this.enemies.forEach(e => {
                if(!n.dead && !n.isGood && e.pos.dist(n.pos) < e.radius + n.radius + 15) {
                    n.dead = true;
                    AudioSys.playPowerUp(true);
                    // ä¿®æ­£ï¼šæ•µãŒæ‚ªã„æ „é¤Šç´ ã‚’å¸å
                    e.absorbBadNutrient(); 
                }
            });
        });

        this.particles.forEach(p => p.update(this.width, this.height));

        this.enemies = this.enemies.filter(e => !e.dead);
        this.bullets = this.bullets.filter(b => !b.dead);
        this.nutrients = this.nutrients.filter(n => !n.dead);
        this.particles = this.particles.filter(p => !p.dead);
        this.cells = this.cells.filter(c => !c.dead);

        if(this.enemies.length === 0) this.spawnEnemy(); // å…¨æ»…ã—ãŸã‚‰è¿½åŠ 
        if(this.cells.length === 0) this.gameOver(false);
        if(this.enemies.length > 150) this.gameOver(false); // å¢—ãˆã™ããŸã‚‰è² ã‘
        
        this.enemyCountEl.innerText = this.enemies.length;
        this.cellCountEl.innerText = this.cells.length;
    }

    draw() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.strokeStyle = '#1a1a2e';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let x=0; x<this.width; x+=50) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); }
        for(let y=0; y<this.height; y+=50) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.width,y); }
        this.ctx.stroke();

        this.ctx.globalCompositeOperation = 'lighter';

        this.nutrients.forEach(n => n.draw(this.ctx));
        this.cells.forEach(c => c.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.bullets.forEach(b => b.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        this.ctx.globalCompositeOperation = 'source-over';
    }

    loop() {
        if (!this.isPlaying) return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
    
    gameOver(isWin) {
        this.isPlaying = false;
        const ov = document.getElementById('overlay');
        ov.style.display = 'flex';
        const title = ov.querySelector('.title');
        const sub = ov.querySelector('.subtitle');
        const btn = ov.querySelector('#startBtn');
        
        if(isWin) {
            title.innerText = "MISSION CLEAR";
            title.style.color = "#00ffcc";
            sub.innerHTML = "ä½“å†…ç’°å¢ƒã¯æ­£å¸¸åŒ–ã•ã‚Œã¾ã—ãŸã€‚";
        } else {
            title.innerText = "SYSTEM FAILURE";
            title.style.color = "#ff3333";
            sub.innerHTML = "å…ç–«ç³»ãŒå´©å£Šã—ã¾ã—ãŸã€‚<br>ã‚¦ã‚¤ãƒ«ã‚¹ã«ã‚ˆã‚‹æ„ŸæŸ“çˆ†ç™ºãŒç™ºç”Ÿã€‚";
        }
        btn.innerText = "RETRY";
    }
}

const game = new Game();
document.getElementById('startBtn').addEventListener('click', () => game.start());

</script>
</body>
</html>