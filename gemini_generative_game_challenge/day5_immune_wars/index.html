<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Immune Wars: Full Course</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #fff;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            width: 100vw;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            overflow: hidden;
            border-right: 2px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-panel {
            width: 220px;
            background-color: #111;
            display: flex;
            flex-direction: row;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            z-index: 10;
            position: relative;
        }

        #food-list-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 5px;
            overflow-y: auto;
            background-color: #1a1a1a;
        }

        #food-list-container::-webkit-scrollbar {
            width: 8px;
        }
        #food-list-container::-webkit-scrollbar-track {
            background: #111;
        }
        #food-list-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        #trash-zone {
            width: 80px;
            background: repeating-linear-gradient(
                45deg,
                #220000,
                #220000 10px,
                #330000 10px,
                #330000 20px
            );
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid #444;
            color: #ff4444;
            font-family: 'Orbitron', sans-serif;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            letter-spacing: 4px;
            font-weight: bold;
        }

        .section-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            text-align: center;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .food-item {
            background: linear-gradient(145deg, #2a2a2a, #202020);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 6px 10px; 
            margin-bottom: 5px;
            color: #ddd;
            font-size: 12px;
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            flex-direction: row; 
            align-items: center; 
            justify-content: flex-start; 
            touch-action: none;
            position: relative;
            z-index: 11;
            height: 36px; 
            flex-shrink: 0;
        }
        
        .food-item:active { cursor: grabbing; }

        .food-item.bad-food {
            border-color: #663333;
            background: linear-gradient(145deg, #2a2020, #201a1a);
        }

        .food-icon { 
            font-size: 22px; 
            margin-right: 12px; 
            margin-bottom: 0;   
            pointer-events: none; 
            width: 25px; 
            text-align: center;
        }
        
        .food-name { 
            pointer-events: none; 
            font-weight: bold;
            font-size: 11px;
            text-align: left;
            white-space: nowrap; 
        }

        .dragging {
            opacity: 0.8;
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            width: 140px;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            background: rgba(30,30,30,0.9);
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 5px;
            border-radius: 6px;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            z-index: 5;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .subtitle {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.8;
            padding: 0 20px;
            max-width: 500px;
        }
        
        .instruction { color: #0ff; font-weight: bold; }
        .warning { color: #ff4444; font-weight: bold; }

        .start-btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            border-radius: 4px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }

        @media (max-width: 600px) {
            #ui-panel { width: 140px; }
            #trash-zone { width: 50px; font-size: 12px; }
            .food-item { font-size: 10px; height: 30px; }
            .food-icon { font-size: 18px; margin-right: 5px; width: 20px; }
            .title { font-size: 24px; }
            .subtitle { font-size: 11px; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div class="stat-box" style="border-color:#ff3333; color:#ff3333">ENEMIES: <span id="enemy-count">0</span></div>
            <div class="stat-box">CELLS: <span id="cell-count">0</span></div>
            <div class="stat-box" style="border-color:#ffff00; color:#ffff00; font-size:12px">FOOD: <span id="food-count">0</span>/30</div>
        </div>
        
        <div id="overlay">
            <div class="title">IMMUNE WARS</div>
            <div class="subtitle">
                <span class="instruction">„ÄêÈ£üÂìÅ„Éá„Éº„Çø„Éô„Éº„ÇπÂÄçÂ¢ó„Äë</span><br>
                1. <b>„É°„Éã„É•„ÉºÊã°Âºµ</b>ÔºöÂêàË®à80Á®ÆÈ°û‰ª•‰∏ä„ÅÆÈ£üÂìÅ„ÅåÁôªÂ†¥„Åó„Åæ„Åô„ÄÇ<br>
                2. <b>„Éê„É©„É≥„ÇπÁ∂≠ÊåÅ</b>ÔºöËâØ„ÅÑÈ£üÂìÅ„Å®ÊÇ™„ÅÑÈ£üÂìÅ„ÅÆÊØîÁéá„ÅØÂçä„ÄÖ„Åß„Åô„ÄÇ<br>
                3. <b>ÂÖçÁñ´Â¢óÊÆñ</b>ÔºöÊ†ÑÈ§äË£úÁµ¶„ÅßÂÖçÁñ´ËªçÂõ£„ÇíËÇ≤„Å¶„ÄÅÊïµ„ÇíÊÆ≤ÊªÖ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<br>
                <br>
                ÈÅ©Âàá„Å™È£ü‰∫ãÈÅ∏Êäû„Åå„ÄÅÂãùÂà©„Å∏„ÅÆÈçµ„Åß„Åô„ÄÇ
            </div>
            <button class="start-btn" id="startBtn">START MISSION</button>
        </div>
    </div>

    <div id="ui-panel">
        <div id="food-list-container">
            <div class="section-header">MENU</div>
            <div id="food-list">
                <!-- JS„ÅßÁîüÊàê -->
            </div>
        </div>
        <div id="trash-zone">TRASH</div>
    </div>

<script>
/**
 * AUDIO SYSTEM
 */
const AudioSys = {
    ctx: null,
    init: function() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        } catch(e) {}
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot: function() { this.playTone(400 + Math.random()*200, 'square', 0.1, 0.05); },
    playEat: function() { this.playTone(800 + Math.random()*200, 'sine', 0.15, 0.1); },
    playSpawn: function() { this.playTone(600, 'triangle', 0.2, 0.05); },
    playTrash: function() { this.playTone(150, 'sawtooth', 0.2, 0.05); },
    playExplosion: function() { 
        this.playTone(100, 'sawtooth', 0.2, 0.1);
        this.playTone(80, 'square', 0.2, 0.1);
    },
    playPowerUp: function(isBad) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        if(isBad) {
            osc.frequency.setValueAtTime(150, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(80, this.ctx.currentTime + 0.5);
            osc.type = 'sawtooth';
        } else {
            osc.frequency.setValueAtTime(400, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.3);
            osc.type = 'sine';
        }
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    },
    playLevelUp: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(600, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.5);
        osc.type = 'triangle';
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }
};

/**
 * GAME DATA
 */
const COLORS = {
    player: '#00ccff', 
    macrophage: '#00ff88',
    enemy1: '#4444ff', 
    enemy2: '#8844ff', 
    nutrientGood: '#ffff00', 
    nutrientBad: '#cc00cc',  
    bullet: '#00ffff'
};

const FOOD_DB = [
    // --- Good Foods (Original + New) ---
    { id: 'broccoli', name: '„Éñ„É≠„ÉÉ„Ç≥„É™„Éº', icon: 'ü•¶', type: 'good' },
    { id: 'salmon', name: '„Çµ„Éº„É¢„É≥', icon: 'üêü', type: 'good' },
    { id: 'yogurt', name: '„É®„Éº„Ç∞„É´„Éà', icon: 'ü•õ', type: 'good' },
    { id: 'lemon', name: '„É¨„É¢„É≥', icon: 'üçã', type: 'good' },
    { id: 'garlic', name: '„Éã„É≥„Éã„ÇØ', icon: 'üßÑ', type: 'good' },
    { id: 'carrot', name: '„Éã„É≥„Ç∏„É≥', icon: 'ü•ï', type: 'good' },
    { id: 'spinach', name: '„Éõ„Ç¶„É¨„É≥„ÇΩ„Ç¶', icon: 'ü•¨', type: 'good' },
    { id: 'tomato', name: '„Éà„Éû„Éà', icon: 'üçÖ', type: 'good' },
    { id: 'apple', name: '„É™„É≥„Ç¥', icon: 'üçé', type: 'good' },
    { id: 'egg', name: '„Çø„Éû„Ç¥', icon: 'ü•ö', type: 'good' },
    { id: 'cheese', name: '„ÉÅ„Éº„Ç∫', icon: 'üßÄ', type: 'good' },
    { id: 'tea', name: 'Á∑ëËå∂', icon: 'üçµ', type: 'good' },
    { id: 'water', name: 'Â§©ÁÑ∂Ê∞¥', icon: 'üíß', type: 'good' },
    { id: 'rice', name: '„ÅîÈ£Ø', icon: 'üçö', type: 'good' },
    { id: 'tofu', name: 'Ë±ÜËÖê', icon: 'üßä', type: 'good' }, 
    { id: 'mush', name: '„Ç≠„Éé„Ç≥', icon: 'üçÑ', type: 'good' },
    { id: 'grape', name: '„Éñ„Éâ„Ç¶', icon: 'üçá', type: 'good' },
    { id: 'melon', name: '„É°„É≠„É≥', icon: 'üçà', type: 'good' },
    { id: 'honey', name: '„Éè„ÉÅ„Éü„ÉÑ', icon: 'üçØ', type: 'good' },
    { id: 'chicken', name: '„ÉÅ„Ç≠„É≥', icon: 'üçó', type: 'good' },
    // New Good
    { id: 'banana', name: '„Éê„Éä„Éä', icon: 'üçå', type: 'good' },
    { id: 'orange', name: '„Ç™„É¨„É≥„Ç∏', icon: 'üçä', type: 'good' },
    { id: 'strawberry', name: '„Ç§„ÉÅ„Ç¥', icon: 'üçì', type: 'good' },
    { id: 'kiwi', name: '„Ç≠„Ç¶„Ç§', icon: 'ü•ù', type: 'good' },
    { id: 'peach', name: '„É¢„É¢', icon: 'üçë', type: 'good' },
    { id: 'onion', name: '„Çø„Éû„Éç„ÇÆ', icon: 'üßÖ', type: 'good' },
    { id: 'corn', name: '„Éà„Ç¶„É¢„É≠„Ç≥„Ç∑', icon: 'üåΩ', type: 'good' },
    { id: 'potato', name: '„Ç∏„É£„Ç¨„Ç§„É¢', icon: 'ü•î', type: 'good' },
    { id: 'sweetpotato', name: '„Çµ„ÉÑ„Éû„Ç§„É¢', icon: 'üç†', type: 'good' },
    { id: 'avocado', name: '„Ç¢„Éú„Ç´„Éâ', icon: 'ü•ë', type: 'good' },
    { id: 'beef', name: 'ÁâõËÇâ', icon: 'ü•©', type: 'good' },
    { id: 'shrimp', name: '„Ç®„Éì', icon: 'ü¶ê', type: 'good' },
    { id: 'octopus', name: '„Çø„Ç≥', icon: 'üêô', type: 'good' },
    { id: 'squid', name: '„Ç§„Ç´', icon: 'ü¶ë', type: 'good' },
    { id: 'beans', name: 'Ë±ÜÈ°û', icon: 'ü´ò', type: 'good' },
    { id: 'nuts', name: '„Éä„ÉÉ„ÉÑ', icon: 'ü•ú', type: 'good' },
    { id: 'salad', name: '„Çµ„É©„ÉÄ', icon: 'ü•ó', type: 'good' },
    { id: 'soup', name: '„Çπ„Éº„Éó', icon: 'ü•£', type: 'good' },
    { id: 'pineapple', name: '„Éë„Ç§„É≥', icon: 'üçç', type: 'good' },
    { id: 'cherry', name: '„Çµ„ÇØ„É©„É≥„Éú', icon: 'üçí', type: 'good' },
    { id: 'watermelon', name: '„Çπ„Ç§„Ç´', icon: 'üçâ', type: 'good' },
    { id: 'cucumber', name: '„Ç≠„É•„Ç¶„É™', icon: 'ü•í', type: 'good' },
    
    // --- Bad Foods (Original + New) ---
    { id: 'fries', name: '„Éù„ÉÜ„Éà', icon: 'üçü', type: 'bad' },
    { id: 'donut', name: '„Éâ„Éº„Éä„ÉÑ', icon: 'üç©', type: 'bad' },
    { id: 'pizza', name: '„Éî„Ç∂', icon: 'üçï', type: 'bad' },
    { id: 'soda', name: 'ÁÇ≠ÈÖ∏È£≤Êñô', icon: 'ü•§', type: 'bad' },
    { id: 'burger', name: '„Éê„Éº„Ç¨„Éº', icon: 'üçî', type: 'bad' },
    { id: 'hotdog', name: '„Éõ„ÉÉ„Éà„Éâ„ÉÉ„Ç∞', icon: 'üå≠', type: 'bad' },
    { id: 'cake', name: '„Ç±„Éº„Ç≠', icon: 'üç∞', type: 'bad' },
    { id: 'cookie', name: '„ÇØ„ÉÉ„Ç≠„Éº', icon: 'üç™', type: 'bad' },
    { id: 'beer', name: '„Éì„Éº„É´', icon: 'üç∫', type: 'bad' },
    { id: 'wine', name: '„ÉØ„Ç§„É≥', icon: 'üç∑', type: 'bad' },
    { id: 'candy', name: '„Ç≠„É£„É≥„Éá„Ç£', icon: 'üç¨', type: 'bad' },
    { id: 'lolly', name: '„Éö„É≠„Éö„É≠', icon: 'üç≠', type: 'bad' },
    { id: 'choco', name: '„ÉÅ„Éß„Ç≥', icon: 'üç´', type: 'bad' },
    { id: 'ice', name: '„Ç¢„Ç§„Çπ', icon: 'üç¶', type: 'bad' },
    { id: 'bacon', name: '„Éô„Éº„Ç≥„É≥', icon: 'ü•ì', type: 'bad' },
    { id: 'popcorn', name: '„Éù„ÉÉ„Éó„Ç≥„Éº„É≥', icon: 'üçø', type: 'bad' },
    { id: 'pudding', name: '„Éó„É™„É≥', icon: 'üçÆ', type: 'bad' },
    { id: 'croissant', name: '„Éë„É≥', icon: 'ü•ê', type: 'bad' },
    { id: 'taco', name: '„Çø„Ç≥„Çπ', icon: 'üåÆ', type: 'bad' },
    { id: 'sandwich', name: '„Çµ„É≥„Éâ', icon: 'ü•™', type: 'bad' },
    // New Bad
    { id: 'ramen', name: '„É©„Éº„É°„É≥', icon: 'üçú', type: 'bad' },
    { id: 'spaghetti', name: '„Éë„Çπ„Çø', icon: 'üçù', type: 'bad' },
    { id: 'pancake', name: '„Éë„É≥„Ç±„Éº„Ç≠', icon: 'ü•û', type: 'bad' },
    { id: 'waffle', name: '„ÉØ„ÉÉ„Éï„É´', icon: 'üßá', type: 'bad' },
    { id: 'bagel', name: '„Éô„Éº„Ç∞„É´', icon: 'ü•Ø', type: 'bad' },
    { id: 'pretzel', name: '„Éó„É¨„ÉÉ„ÉÑ„Çß„É´', icon: 'ü•®', type: 'bad' },
    { id: 'butter', name: '„Éê„Çø„Éº', icon: 'üßà', type: 'bad' },
    { id: 'cupcake', name: '„Ç´„ÉÉ„Éó„Ç±„Éº„Ç≠', icon: 'üßÅ', type: 'bad' },
    { id: 'pie', name: '„Éë„Ç§', icon: 'ü•ß', type: 'bad' },
    { id: 'dango', name: 'Âõ£Â≠ê', icon: 'üç°', type: 'bad' },
    { id: 'sake', name: 'Êó•Êú¨ÈÖí', icon: 'üç∂', type: 'bad' },
    { id: 'whiskey', name: '„Ç¶„Ç§„Çπ„Ç≠„Éº', icon: 'ü•É', type: 'bad' },
    { id: 'cocktail', name: '„Ç´„ÇØ„ÉÜ„É´', icon: 'üç∏', type: 'bad' },
    { id: 'boba', name: '„Çø„Éî„Ç™„Ç´', icon: 'üßã', type: 'bad' },
    { id: 'canned', name: 'Áº∂Ë©∞', icon: 'ü•´', type: 'bad' },
    { id: 'salt', name: 'Â°©ÂàÜÈÅéÂ§ö', icon: 'üßÇ', type: 'bad' },
    { id: 'dumpling', name: 'È§ÉÂ≠ê', icon: 'ü•ü', type: 'bad' },
    { id: 'friedshrimp', name: '„Ç®„Éì„Éï„É©„Ç§', icon: 'üç§', type: 'bad' },
    { id: 'skewer', name: '‰∏≤„Ç´„ÉÑ', icon: 'üç¢', type: 'bad' },
    { id: 'mooncake', name: 'ÊúàÈ§Ö', icon: 'ü•Æ', type: 'bad' },
    { id: 'bread', name: 'È£ü„Éë„É≥', icon: 'üçû', type: 'bad' },
    { id: 'baguette', name: '„Éï„É©„É≥„Çπ„Éë„É≥', icon: 'ü•ñ', type: 'bad' }
];

class Vec2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
    normalize() {
        let m = this.mag();
        if(m > 0) { this.x /= m; this.y /= m; }
        return this;
    }
    dist(v) { return Math.sqrt((this.x-v.x)**2 + (this.y-v.y)**2); }
    copy() { return new Vec2(this.x, this.y); }
}

class Entity {
    constructor(x, y, radius, color) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(0, 0);
        this.acc = new Vec2(0, 0);
        this.radius = radius;
        this.color = color;
        this.dead = false;
        this.maxSpeed = 2;
        this.friction = 0.95;
    }

    update(w, h) {
        this.vel.add(this.acc);
        this.vel.mult(this.friction);
        if (this.vel.mag() > this.maxSpeed) {
            this.vel.normalize().mult(this.maxSpeed);
        }
        this.pos.add(this.vel);
        this.acc.mult(0);
        
        // ÁîªÈù¢Á´Ø„Éê„Ç¶„É≥„Éâ
        if (this.pos.x < this.radius) {
            this.pos.x = this.radius;
            this.vel.x *= -1;
        } else if (this.pos.x > w - this.radius) {
            this.pos.x = w - this.radius;
            this.vel.x *= -1;
        }

        if (this.pos.y < this.radius) {
            this.pos.y = this.radius;
            this.vel.y *= -1;
        } else if (this.pos.y > h - this.radius) {
            this.pos.y = h - this.radius;
            this.vel.y *= -1;
        }
    }

    applyForce(force) {
        this.acc.add(force);
    }
    
    draw(ctx) {
        if(this.radius <= 0) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class ImmuneCell extends Entity {
    constructor(x, y, type) {
        super(x, y, 12, COLORS.player);
        this.type = type; 
        this.name = type === 'MACROPHAGE' ? '„Éû„ÇØ„É≠„Éï„Ç°„Éº„Ç∏' : (type === 'B-CELL' ? 'Ôº¢Á¥∞ËÉû' : 'Ôº¥Á¥∞ËÉû');
        this.shootCooldown = 0;
        this.xp = 0;
        this.level = 1;
        
        if (type === 'MACROPHAGE') {
            this.hp = 30; // Â∑®Â§ß
            this.maxSpeed = 1.0; 
            this.color = COLORS.macrophage;
        } else {
            this.hp = 15; // Ê®ôÊ∫ñ
            this.maxSpeed = 1.2; 
        }
    }

    update(w, h) {
        super.update(w, h);
        this.radius = Math.max(0, this.hp);
        
        if (this.radius < 5) {
            this.dead = true;
            game.createParticles(this.pos.x, this.pos.y, this.color, 15);
        }
    }

    behavior(cells, enemies, w, h) {
        // --- Âë≥ÊñπÂêåÂ£´„ÅÆÂàÜÈõ¢ (Separation) ---
        let separation = new Vec2(0, 0);
        let count = 0;
        let desiredSeparation = this.radius * 2.5;

        cells.forEach(other => {
            if (other === this) return;
            let d = this.pos.dist(other.pos);
            if (d > 0 && d < desiredSeparation) {
                let diff = this.pos.copy().sub(other.pos);
                diff.normalize();
                diff.mult(1 / d); 
                separation.add(diff);
                count++;
            }
        });

        if (count > 0) {
            separation.mult(1 / count);
            separation.normalize();
            separation.mult(0.5); 
            this.applyForce(separation);
        }

        // --- Êó¢Â≠ò„ÅÆAI„É≠„Ç∏„ÉÉ„ÇØ ---
        let closest = null;
        let minDist = Infinity;
        let distVec = new Vec2(0,0);

        enemies.forEach(e => {
            let toEnemy = e.pos.copy().sub(this.pos);
            let d = toEnemy.mag();
            if (d < minDist) {
                minDist = d;
                closest = e;
                distVec = toEnemy;
            }
        });

        if (closest) {
            distVec.normalize();
            let isExterminationMode = (enemies.length <= 10);

            if (this.type === 'MACROPHAGE') {
                let speedMult = isExterminationMode ? 0.6 : 0.4;
                this.applyForce(distVec.mult(speedMult));
            } else {
                let isWeaker = (this.hp < closest.power);

                if (isWeaker) {
                    this.applyForce(distVec.mult(-0.4));
                } else {
                    if (isExterminationMode) {
                        this.applyForce(distVec.mult(0.35)); 
                    } else {
                        if (minDist > 250) {
                            this.applyForce(distVec.mult(0.25)); 
                        } else if (minDist < 100) {
                            this.applyForce(distVec.mult(-0.3)); 
                        } else {
                            this.applyForce(new Vec2(Math.random()-0.5, Math.random()-0.5).mult(0.1));
                        }
                    }
                }
                
                let range = isExterminationMode ? 500 : 350;
                if (this.shootCooldown <= 0 && minDist < range) {
                    this.shoot(distVec);
                    this.shootCooldown = (this.type === 'T-CELL') ? 30 : 45; 
                }
            }
        }
        this.shootCooldown--;
    }

    shoot(dir) {
        game.bullets.push(new Bullet(this.pos.x, this.pos.y, dir));
        AudioSys.playShoot();
    }
    
    absorb(amount = 5) {
        this.hp += amount;
        this.hp = Math.min(this.hp, 50); 
        this.split();
    }
    
    split() {
        if (game.cells.length < 50) {
            let child = new ImmuneCell(this.pos.x, this.pos.y, this.type);
            child.hp = this.hp; 
            child.vel = new Vec2(Math.random()-0.5, Math.random()-0.5).mult(5);
            game.cells.push(child);
            
            game.spawnMessage("Â¢óÊÆñÔºÅ", this.pos.x, this.pos.y, "#00ffcc");
            AudioSys.playLevelUp();
            game.createParticles(this.pos.x, this.pos.y, "#ffffff", 10);
        } else {
            game.spawnMessage("MAXIMUM", this.pos.x, this.pos.y, "#ffffff");
        }
    }
    
    draw(ctx) {
        super.draw(ctx);
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        if (this.radius > 10) {
            ctx.fillText(this.name, this.pos.x, this.pos.y + this.radius + 12);
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 10, type === 1 ? COLORS.enemy1 : COLORS.enemy2);
        this.type = type; 
        this.power = type === 1 ? 12 : 20; 
        this.maxSpeed = type === 1 ? 1.5 : 0.8;
        this.reproduceTimer = 0;
        this.reproduceInterval = 480; 
        this.updateColor(); 
    }

    updateColor() {
        let t = Math.min((this.power - 5) / 40, 1); 
        let r = Math.floor(50 + 205 * t);
        let g = Math.floor(50 * (1 - t));
        let b = Math.floor(255 * (1 - t));
        this.color = `rgb(${r},${g},${b})`;
        this.radius = Math.max(0, this.power);
    }

    update(w, h) {
        super.update(w, h);
        if (this.power < 5) {
            this.dead = true;
            game.createParticles(this.pos.x, this.pos.y, this.color, 10);
        }
    }

    behavior(cells, enemies, w, h) {
        this.reproduceTimer++;
        if(this.reproduceTimer > this.reproduceInterval) {
            this.reproduceTimer = 0;
            this.split();
            return;
        }

        let separation = new Vec2(0, 0);
        let count = 0;
        let desiredSeparation = this.radius * 2.5;

        enemies.forEach(other => {
            if (other === this) return;
            let d = this.pos.dist(other.pos);
            if (d > 0 && d < desiredSeparation) {
                let diff = this.pos.copy().sub(other.pos);
                diff.normalize();
                diff.mult(1 / d); 
                separation.add(diff);
                count++;
            }
        });

        if (count > 0) {
            separation.mult(1 / count);
            separation.normalize();
            separation.mult(0.6); 
            this.applyForce(separation);
        }

        let closest = null;
        let minDist = Infinity;
        cells.forEach(c => {
            let toCell = c.pos.copy().sub(this.pos);
            let d = toCell.mag();
            if (d < minDist) { minDist = d; closest = c; }
        });

        let isAttacking = false;
        const margin = 80;
        const avoidP = 0.8; 

        if (closest) {
            let isMobMode = (enemies.length >= 10);
            
            if (isMobMode || this.power >= closest.hp) {
                isAttacking = true;
                let dir = closest.pos.copy().sub(this.pos);
                dir.normalize();
                this.applyForce(dir.mult(0.25)); 
            } else {
                let dir = closest.pos.copy().sub(this.pos);
                dir.normalize();
                this.applyForce(dir.mult(-0.2));
            }
        } else {
            this.applyForce(new Vec2(Math.random()-0.5, Math.random()-0.5).mult(0.2));
        }

        if (!isAttacking || (isAttacking && minDist > 200)) {
            if (this.pos.x < margin) this.applyForce(new Vec2(avoidP, 0));
            if (this.pos.x > w - margin) this.applyForce(new Vec2(-avoidP, 0));
            if (this.pos.y < margin) this.applyForce(new Vec2(0, avoidP));
            if (this.pos.y > h - margin) this.applyForce(new Vec2(0, -avoidP));
        }
    }
    
    absorbBadNutrient() {
        game.spawnMessage("ÊïµÂº∑ÂåñÔºÅ", this.pos.x, this.pos.y, "#ff0000");
        this.power *= 1.3; 
        this.updateColor(); 
    }
    
    split() {
        if(game.enemies.length < 80) { 
            let angle = Math.random() * Math.PI * 2;
            let speed = 2.5; 

            let child1 = new Enemy(this.pos.x, this.pos.y, this.type);
            child1.vel = new Vec2(Math.cos(angle)*speed, Math.sin(angle)*speed);
            child1.power = this.power; 
            child1.updateColor();

            let child2 = new Enemy(this.pos.x, this.pos.y, this.type);
            child2.vel = new Vec2(Math.cos(angle + Math.PI)*speed, Math.sin(angle + Math.PI)*speed);
            child2.power = this.power;
            child2.updateColor();

            game.enemies.push(child1, child2);
            this.dead = true; 
            
            AudioSys.playSpawn();
            game.createParticles(this.pos.x, this.pos.y, this.color, 5);
        }
    }

    draw(ctx) {
        if(this.radius <= 0) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle); 
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        
        ctx.beginPath();
        if (this.type === 1) {
            ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, 0); ctx.lineTo(0, this.radius); ctx.lineTo(-this.radius, 0);
        } else {
            for(let i=0; i<8; i++) {
                let r = this.radius + (i%2===0 ? 2 : -2);
                let a = (Math.PI*2 / 8) * i;
                ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
        }
        ctx.fill();
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, dir) {
        super(x, y, 3, COLORS.bullet);
        this.vel = dir.copy().mult(7); 
        this.life = 60;
        this.friction = 1.0;
    }
    update(w, h) {
        super.update(w, h);
        this.life--;
        if(this.life <= 0) this.dead = true;
    }
}

class Nutrient extends Entity {
    constructor(x, y, foodData) {
        super(x, y, 6, foodData.type === 'good' ? COLORS.nutrientGood : COLORS.nutrientBad);
        this.isGood = (foodData.type === 'good');
        this.foodData = foodData;
        this.friction = 1.0;
        this.maxSpeed = 1.0; 
    }
    
    behavior(cells, enemies, w, h) {
        let targets = this.isGood ? cells : enemies;
        let closest = null;
        let minDist = 1000; 

        targets.forEach(t => {
            let toTarget = t.pos.copy().sub(this.pos);
            let d = toTarget.mag();
            if (d < minDist) { minDist = d; closest = t; }
        });

        if (closest) {
            let magnetRange = closest.radius * 16;
            
            let dir = closest.pos.copy().sub(this.pos);
            dir.normalize();
            
            if (minDist < magnetRange) {
                let pullStrength = 1.5 * (magnetRange / minDist); 
                this.applyForce(dir.mult(pullStrength * 0.1));
            } else {
                this.applyForce(dir.mult(0.25)); 
            }
        }
    }
}

class Particle extends Entity {
    constructor(x, y, color) {
        super(x, y, Math.random()*2+1, color);
        this.vel = new Vec2(Math.random()-0.5, Math.random()-0.5).mult(3);
        this.life = 30;
        this.friction = 0.9;
    }
    update(w, h) {
        super.update(w, h);
        this.life--;
        this.radius *= 0.9;
        if(this.life <= 0) this.dead = true;
    }
}

/**
 * UI MANAGER
 */
class UIManager {
    constructor(game) {
        this.game = game;
        this.listEl = document.getElementById('food-list');
        this.trashEl = document.getElementById('trash-zone');
        this.panelEl = document.getElementById('ui-panel');
        this.dragItem = null;
        this.dragData = null;
        this.touchOffset = {x:0, y:0};
        this.refillList();
    }
    
    refillList() {
        this.listEl.innerHTML = '';
        for(let i=0; i<24; i++) {
            this.addRandomFood();
        }
    }
    
    addRandomFood() {
        const food = FOOD_DB[Math.floor(Math.random() * FOOD_DB.length)];
        const el = document.createElement('div');
        el.className = 'food-item' + (food.type === 'bad' ? ' bad-food' : '');
        el.innerHTML = `<div class="food-icon">${food.icon}</div><div class="food-name">${food.name}</div>`;
        
        el.addEventListener('mousedown', (e) => this.startDrag(e, el, food));
        el.addEventListener('touchstart', (e) => this.startDrag(e, el, food), {passive: false});
        
        this.listEl.appendChild(el);
    }
    
    startDrag(e, el, food) {
        if(!this.game.isPlaying) return;

        const touch = e.touches ? e.touches[0] : e;
        const rect = el.getBoundingClientRect();
        
        this.touchOffset.x = touch.clientX - rect.left;
        this.touchOffset.y = touch.clientY - rect.top;
        
        this.dragItem = el.cloneNode(true);
        this.dragItem.classList.add('dragging');
        this.dragItem.style.width = '160px';
        document.body.appendChild(this.dragItem);
        
        this.dragData = food;
        this.moveDrag(touch.clientX, touch.clientY);
        
        el.style.opacity = '0.3';
        this.originalEl = el;

        const moveHandler = (ev) => {
            const t = ev.touches ? ev.touches[0] : ev;
            this.moveDrag(t.clientX, t.clientY);
        };
        
        const endHandler = (ev) => {
            const t = ev.changedTouches ? ev.changedTouches[0] : ev;
            this.endDrag(t.clientX);
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('mouseup', endHandler);
            document.removeEventListener('touchend', endHandler);
        };

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('touchmove', moveHandler, {passive: false});
        document.addEventListener('mouseup', endHandler);
        document.addEventListener('touchend', endHandler);
    }
    
    moveDrag(x, y) {
        if(this.dragItem) {
            this.dragItem.style.left = (x - this.touchOffset.x) + 'px';
            this.dragItem.style.top = (y - this.touchOffset.y) + 'px';
        }
    }
    
    endDrag(x) {
        if(!this.dragItem) return;
        
        const panelRect = this.panelEl.getBoundingClientRect();
        const trashRect = this.trashEl.getBoundingClientRect();
        
        if (x < panelRect.left) {
            this.game.spawnFood(this.dragData);
            this.originalEl.remove();
            this.addRandomFood(); 
        } else if (x > trashRect.left) {
            AudioSys.playTrash();
            this.originalEl.remove();
            this.addRandomFood(); 
        } else {
            this.originalEl.style.opacity = '1';
        }
        
        this.dragItem.remove();
        this.dragItem = null;
        this.dragData = null;
        this.originalEl = null;
    }
}

/**
 * GAME MANAGER
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.ui = new UIManager(this);
        
        this.cells = [];
        this.enemies = [];
        this.bullets = [];
        this.nutrients = [];
        this.particles = [];
        
        this.isPlaying = false;
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.enemyCountEl = document.getElementById('enemy-count');
        this.cellCountEl = document.getElementById('cell-count');
        this.foodCountEl = document.getElementById('food-count');
    }

    resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.width = rect.width;
        this.height = rect.height;
    }

    start() {
        AudioSys.init();
        this.isPlaying = true;
        document.getElementById('overlay').style.display = 'none';
        
        this.cells = [];
        this.enemies = [];
        this.bullets = [];
        this.nutrients = [];
        this.particles = [];
        this.ui.refillList();

        this.cells.push(new ImmuneCell(this.width/2, this.height/2, 'MACROPHAGE'));
        this.cells.push(new ImmuneCell(this.width/2 - 40, this.height/2, 'B-CELL'));
        this.cells.push(new ImmuneCell(this.width/2 + 40, this.height/2, 'T-CELL'));
        
        for(let i=0; i<8; i++) { this.spawnEnemy(); }

        this.loop();
    }

    spawnEnemy() {
        let x = Math.random() * this.width;
        let y = Math.random() * this.height;
        if (this.cells.length > 0) {
             while(new Vec2(x,y).dist(this.cells[0].pos) < 250) {
                 x = Math.random() * this.width;
                 y = Math.random() * this.height;
             }
        }
        let type = Math.random() > 0.7 ? 2 : 1;
        this.enemies.push(new Enemy(x, y, type));
    }

    spawnFood(food) {
        AudioSys.playSpawn();
        const MAX_NUTRIENTS = 30;
        
        let speed = 3.0 + Math.random() * 2.0;

        for(let i=0; i<4; i++) {
            let side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;

            switch(side) {
                case 0: // ‰∏ä„Åã„Çâ
                    x = Math.random() * this.width;
                    y = -20;
                    vx = (Math.random() - 0.5) * 2;
                    vy = speed;
                    break;
                case 1: // Âè≥„Åã„Çâ
                    x = this.width + 20;
                    y = Math.random() * this.height;
                    vx = -speed;
                    vy = (Math.random() - 0.5) * 2;
                    break;
                case 2: // ‰∏ã„Åã„Çâ
                    x = Math.random() * this.width;
                    y = this.height + 20;
                    vx = (Math.random() - 0.5) * 2;
                    vy = -speed;
                    break;
                case 3: // Â∑¶„Åã„Çâ
                    x = -20;
                    y = Math.random() * this.height;
                    vx = speed;
                    vy = (Math.random() - 0.5) * 2;
                    break;
            }

            let n = new Nutrient(x, y, food);
            n.vel = new Vec2(vx, vy);
            this.nutrients.push(n);
        }
        
        while (this.nutrients.length > MAX_NUTRIENTS) {
            this.nutrients.shift();
        }
        
        if(food.type === 'bad') {
            this.spawnMessage("ÊúâÂÆ≥Áâ©Ë≥™Ê§úÁü•ÔºÅ", this.width/2, this.height/2, "#ff0000");
        }
    }
    
    spawnMessage(text, x, y, color='#fff') {
        const el = document.createElement('div');
        el.innerText = text;
        el.style.position = 'absolute';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        el.style.fontWeight = 'bold';
        el.style.fontSize = '14px';
        el.style.textShadow = '0 0 3px #000';
        el.style.pointerEvents = 'none';
        el.style.transition = 'all 1s ease-out';
        el.style.zIndex = 100;
        document.getElementById('game-container').appendChild(el);
        
        setTimeout(() => {
            el.style.top = (y - 50) + 'px';
            el.style.opacity = 0;
        }, 10);
        setTimeout(() => el.remove(), 1000);
    }

    createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    update() {
        if(!this.isPlaying) return;

        this.cells.forEach(c => {
            c.behavior(this.cells, this.enemies, this.width, this.height);
            c.update(this.width, this.height);
        });

        this.enemies.forEach(e => {
            e.behavior(this.cells, this.enemies, this.width, this.height);
            e.update(this.width, this.height);
            e.updateColor(); 

            // Êïµ vs ÂÖçÁñ´
            this.cells.forEach(c => {
                let dist = c.pos.dist(e.pos);
                if(dist < c.radius + e.radius) {
                    
                    if(c.type === 'MACROPHAGE') {
                        let damage = e.power;
                        let recovery = e.power * 0.5;
                        c.hp = c.hp - damage + recovery;
                        
                        e.dead = true; 
                        AudioSys.playEat();
                        this.createParticles(e.pos.x, e.pos.y, e.color, 10);
                        this.createParticles(c.pos.x, c.pos.y, "#00ff00", 5);

                    } else {
                        c.hp -= (e.power * 0.5); 
                        if(c.hp <= 5) { 
                            c.dead = true;
                            this.createParticles(c.pos.x, c.pos.y, c.color, 20);
                            AudioSys.playExplosion();
                        }
                    }
                }
            });
        });

        this.bullets.forEach(b => {
            b.update(this.width, this.height);
            this.enemies.forEach(e => {
                if(!e.dead && b.pos.dist(e.pos) < e.radius + b.radius) {
                    e.power -= 2; 
                    e.updateColor();
                    
                    if (e.power < 5) { 
                        e.dead = true;
                        AudioSys.playExplosion();
                        this.createParticles(e.pos.x, e.pos.y, e.color, 15);
                    } else {
                        b.dead = true;
                        this.createParticles(b.pos.x, b.pos.y, COLORS.bullet, 3);
                    }
                }
            });
        });

        this.nutrients.forEach(n => {
            n.behavior(this.cells, this.enemies, this.width, this.height);
            n.update(this.width, this.height);
            
            this.cells.forEach(c => {
                if(!n.dead && n.isGood && c.pos.dist(n.pos) < c.radius + n.radius + 15) {
                    n.dead = true;
                    AudioSys.playPowerUp(false);
                    c.absorb(10); 
                }
            });
            this.enemies.forEach(e => {
                if(!n.dead && !n.isGood && e.pos.dist(n.pos) < e.radius + n.radius + 15) {
                    n.dead = true;
                    AudioSys.playPowerUp(true);
                    e.absorbBadNutrient(); 
                }
            });
        });

        this.particles.forEach(p => p.update(this.width, this.height));

        this.enemies = this.enemies.filter(e => !e.dead);
        this.bullets = this.bullets.filter(b => !b.dead);
        this.nutrients = this.nutrients.filter(n => !n.dead);
        this.particles = this.particles.filter(p => !p.dead);
        this.cells = this.cells.filter(c => !c.dead);

        if(this.enemies.length === 0) this.gameOver(true); 
        if(this.cells.length === 0) this.gameOver(false);
        if(this.enemies.length > 150) this.gameOver(false); 
        
        this.enemyCountEl.innerText = this.enemies.length;
        this.cellCountEl.innerText = this.cells.length;
        this.foodCountEl.innerText = this.nutrients.length;
    }

    draw() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.strokeStyle = '#1a1a2e';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let x=0; x<this.width; x+=50) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); }
        for(let y=0; y<this.height; y+=50) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.width,y); }
        this.ctx.stroke();

        this.ctx.globalCompositeOperation = 'lighter';

        this.nutrients.forEach(n => n.draw(this.ctx));
        this.cells.forEach(c => c.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.bullets.forEach(b => b.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        this.ctx.globalCompositeOperation = 'source-over';
    }

    loop() {
        if (!this.isPlaying) return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
    
    gameOver(isWin) {
        this.isPlaying = false;
        const ov = document.getElementById('overlay');
        ov.style.display = 'flex';
        const title = ov.querySelector('.title');
        const sub = ov.querySelector('.subtitle');
        const btn = ov.querySelector('#startBtn');
        
        if(isWin) {
            title.innerText = "MISSION CLEAR";
            title.style.color = "#00ffcc";
            sub.innerHTML = "‰ΩìÂÜÖÁí∞Â¢É„ÅØÊ≠£Â∏∏Âåñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ<br>ÂÖçÁñ´„Ç∑„Çπ„ÉÜ„É†ÂãùÂà©ÔºÅ";
        } else {
            title.innerText = "SYSTEM FAILURE";
            title.style.color = "#ff3333";
            sub.innerHTML = "ÂÖçÁñ´Á≥ª„ÅåÂ¥©Â£ä„Åó„Åæ„Åó„Åü„ÄÇ<br>„Ç¶„Ç§„É´„Çπ„Å´„Çà„ÇãÊÑüÊüìÁàÜÁô∫„ÅåÁô∫Áîü„ÄÇ";
        }
        btn.innerText = "RETRY";
    }
}

const game = new Game();
document.getElementById('startBtn').addEventListener('click', () => game.start());

</script>
</body>
</html>