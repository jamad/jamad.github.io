<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四字熟語 門番 - Idiom Gatekeeper</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700;900&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gate-color: #2c3e50;
            --gate-border: #d4af37;
            --bg-color: #000;
            --text-color: #fff;
            --accent: #c0392b;
            --neon: #00ffcc;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Noto Serif JP', serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            perspective: 1000px; /* 3D空間の奥行き */
        }

        /* UI Layer (HUD) */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--neon);
        }

        .question-counter { color: var(--gate-border); }
        .timer { color: var(--neon); }

        /* Answer Buttons */
        #controls {
            pointer-events: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            max-width: 600px;
            margin: 0 auto 20px;
            width: 100%;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.5s ease;
        }

        #controls.active {
            transform: translateY(0);
            opacity: 1;
        }

        .ans-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--gate-border);
            color: white;
            padding: 20px;
            font-size: 1.5rem;
            font-family: 'Noto Serif JP', serif;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-align: center;
        }

        .ans-btn:hover {
            background: var(--gate-border);
            color: #000;
            transform: scale(1.05);
        }

        .ans-btn:active { transform: scale(0.95); }

        /* 3D Scene */
        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* Gate Construction */
        .gate-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 600px;
            height: 500px;
            /* transformはJSで制御 */
            transform-style: preserve-3d;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 中心点を調整 */
            margin-top: -250px;
            margin-left: -300px;
        }

        .gate-door {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            border: 4px solid var(--gate-border);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            backface-visibility: hidden;
        }

        .gate-left {
            left: 0;
            transform-origin: left center;
            border-right: 1px solid var(--gate-border);
            border-radius: 10px 0 0 10px;
        }

        .gate-right {
            right: 0;
            transform-origin: right center;
            border-left: 1px solid var(--gate-border);
            border-radius: 0 10px 10px 0;
        }

        /* Gate Text */
        .gate-text-container {
            position: absolute;
            z-index: 10;
            text-align: center;
            width: 80%;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .question-text {
            font-size: 1.8rem;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 4px;
            line-height: 1.4;
        }

        /* Animations */
        .gate-wrapper.open .gate-left {
            transform: rotateY(-110deg);
        }
        .gate-wrapper.open .gate-right {
            transform: rotateY(110deg);
        }
        .gate-wrapper.open .gate-text-container {
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Screens (Start/Result) */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            background: linear-gradient(to bottom, #d4af37, #f1c40f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .btn-primary {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(192, 57, 43, 0.5);
            transition: transform 0.2s;
        }

        .btn-primary:hover {
            transform: scale(1.1);
            background: #e74c3c;
        }

        .hidden { display: none !important; }

        /* Ranking Table */
        .ranking-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
        .ranking-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-family: 'Orbitron', monospace;
        }
    </style>
</head>
<body>

    <!-- 3D World -->
    <div id="world">
        <!-- JS will populate gates here -->
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="question-counter">GATE: <span id="current-q">0</span>/20</div>
            <div class="timer" id="timer-display">00:00.000</div>
        </div>
        <div id="controls">
            <button class="ans-btn" id="btn0"></button>
            <button class="ans-btn" id="btn1"></button>
            <button class="ans-btn" id="btn2"></button>
            <button class="ans-btn" id="btn3"></button>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay">
        <h1>四字熟語 門番</h1>
        <p style="margin-bottom: 20px; font-size: 1.2rem;">20の門を潜り抜け、最速を目指せ。</p>
        <button class="btn-primary" onclick="game.start()">挑戦開始</button>
        <div id="loading-msg" style="margin-top: 20px; color: #aaa;">データ読込中...</div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="overlay hidden">
        <h1>突破完了</h1>
        <div style="font-size: 2rem; margin-bottom: 20px;">
            TIME: <span id="final-time" style="color: var(--neon); font-family: 'Orbitron';"></span>
        </div>
        <div class="ranking-box">
            <h3>ローカルランキング (Top 5)</h3>
            <div id="ranking-list"></div>
        </div>
        <button class="btn-primary" onclick="location.reload()" style="margin-top: 20px;">再挑戦</button>
    </div>

    <script>
        class Game {
            constructor() {
                this.idioms = [];
                this.questions = [];
                this.currentIndex = 0;
                this.maxQuestions = 20;
                this.startTime = 0;
                this.timerInterval = null;
                this.worldZ = 0; // World Z position
                this.gateDistance = 800; // Distance between gates
                this.isAnimating = false;
            }

            async loadData() {
                try {
                    const response = await fetch('idioms.json');
                    if (!response.ok) throw new Error("JSON not found");
                    const data = await response.json();
                    // Filter only 4-char words just in case
                    this.idioms = data.filter(item => item.word.length === 4);
                    document.getElementById('loading-msg').style.display = 'none';
                } catch (e) {
                    document.getElementById('loading-msg').textContent = "エラー: idioms.jsonが見つかりません";
                    console.error(e);
                }
            }

            // Shuffle array (Fisher-Yates)
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            initQuestions() {
                // Shuffle all idioms and take necessary amount
                const shuffled = this.shuffle([...this.idioms]);
                
                this.questions = [];
                for(let i=0; i<this.maxQuestions; i++) {
                    const correct = shuffled[i];
                    
                    // Create distractors (3 random others)
                    let distractors = [];
                    while(distractors.length < 3) {
                        const d = this.idioms[Math.floor(Math.random() * this.idioms.length)];
                        if(d.word !== correct.word && !distractors.includes(d)) {
                            distractors.push(d);
                        }
                    }
                    
                    const options = this.shuffle([correct, ...distractors]);
                    
                    this.questions.push({
                        target: correct,
                        options: options
                    });
                }
            }

            start() {
                if(this.idioms.length === 0) return alert("データが読み込まれていません");
                
                this.initQuestions();
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('controls').classList.add('active');
                
                this.currentIndex = 0;
                this.worldZ = 0;
                document.getElementById('world').style.transform = `translateZ(0px)`;
                document.getElementById('world').innerHTML = ''; // clear

                // Generate first two gates (current and next)
                this.renderGate(0);
                this.renderGate(1);

                this.updateHUD();
                this.startTime = performance.now();
                this.timerInterval = requestAnimationFrame(this.updateTimer.bind(this));
            }

            renderGate(index) {
                if (index >= this.maxQuestions) return; // Goal post?

                const q = this.questions[index];
                const zPos = -index * this.gateDistance;
                
                const gateEl = document.createElement('div');
                gateEl.className = 'gate-wrapper';
                gateEl.id = `gate-${index}`;
                gateEl.style.transform = `translateZ(${zPos}px)`;

                // Using meaning or reading as the "Question"
                // To make it harder/better, use Meaning.
                const questionText = q.target.meaning.length > 40 
                    ? q.target.meaning.substring(0, 40) + "..." 
                    : q.target.meaning;

                gateEl.innerHTML = `
                    <div class="gate-door gate-left"></div>
                    <div class="gate-door gate-right"></div>
                    <div class="gate-text-container">
                        <div class="question-text">${questionText}</div>
                        <div style="font-size: 0.8em; margin-top:5px; color:#aaa;">(${q.target.reading})</div>
                    </div>
                `;

                document.getElementById('world').appendChild(gateEl);
            }

            updateHUD() {
                const q = this.questions[this.currentIndex];
                document.getElementById('current-q').textContent = this.currentIndex + 1;
                
                const buttons = document.querySelectorAll('.ans-btn');
                buttons.forEach((btn, i) => {
                    const option = q.options[i];
                    btn.textContent = option.word;
                    btn.onclick = () => this.checkAnswer(option.word, q.target.word);
                });
            }

            checkAnswer(selectedWord, correctWord) {
                if(this.isAnimating) return;

                if (selectedWord === correctWord) {
                    this.nextLevel();
                } else {
                    // Penalty or visual feedback for wrong answer
                    const world = document.getElementById('world');
                    world.style.transition = "transform 0.1s";
                    world.style.transform = `translateZ(${this.worldZ}px) translateX(10px)`;
                    setTimeout(() => {
                        world.style.transform = `translateZ(${this.worldZ}px) translateX(-10px)`;
                        setTimeout(() => {
                            world.style.transform = `translateZ(${this.worldZ}px)`;
                            world.style.transition = "transform 0.8s cubic-bezier(0.25, 1, 0.5, 1)";
                        }, 100);
                    }, 100);
                    
                    // Add 5 seconds penalty? (Optional)
                    this.startTime -= 5000; 
                }
            }

            nextLevel() {
                this.isAnimating = true;
                
                // 1. Open current gate
                const currentGate = document.getElementById(`gate-${this.currentIndex}`);
                currentGate.classList.add('open');

                // 2. Move camera forward
                this.currentIndex++;
                this.worldZ += this.gateDistance;
                document.getElementById('world').style.transform = `translateZ(${this.worldZ}px)`;

                // 3. Prepare logic for next state
                if (this.currentIndex < this.maxQuestions) {
                    // Generate the gate AFTER the next one (to keep infinite hallway feel)
                    this.renderGate(this.currentIndex + 1);
                    
                    // Remove old gate to save memory (optional, kept simplae here)
                    if(this.currentIndex > 2) {
                        const oldGate = document.getElementById(`gate-${this.currentIndex - 3}`);
                        if(oldGate) oldGate.remove();
                    }

                    setTimeout(() => {
                        this.updateHUD();
                        this.isAnimating = false;
                    }, 600); // Wait for animation mostly to finish
                } else {
                    this.finish();
                }
            }

            updateTimer() {
                if (this.currentIndex >= this.maxQuestions) return;
                
                const now = performance.now();
                const diff = now - this.startTime;
                
                const min = Math.floor(diff / 60000);
                const sec = Math.floor((diff % 60000) / 1000);
                const ms = Math.floor((diff % 1000));

                const str = 
                    (min < 10 ? "0" + min : min) + ":" + 
                    (sec < 10 ? "0" + sec : sec) + "." + 
                    (ms < 100 ? "0" : "") + (ms < 10 ? "0" : "") + ms;

                document.getElementById('timer-display').textContent = str;
                this.timerInterval = requestAnimationFrame(this.updateTimer.bind(this));
            }

            finish() {
                cancelAnimationFrame(this.timerInterval);
                const finalTimeStr = document.getElementById('timer-display').textContent;
                const finalTimeMs = performance.now() - this.startTime;
                
                document.getElementById('controls').classList.remove('active');
                
                // 少し待ってから結果画面
                setTimeout(() => {
                    document.getElementById('result-screen').classList.remove('hidden');
                    document.getElementById('final-time').textContent = finalTimeStr;
                    this.saveScore(finalTimeMs, finalTimeStr);
                }, 1000);
            }

            /* --- ランキング機能（セキュリティに関する解説）---
               クライアントサイド(JS)だけで完結する場合、ユーザーは Console で
               game.saveScore(1, "00:00.001") を実行できてしまいます。
               
               本番環境で改ざんを防ぐには:
               1. ゲーム開始時にサーバーから一意のトークンと問題順序を取得
               2. 回答ごとにサーバーへタイムスタンプを送信、または
                  全問終了時にサーバーへ「各問題の回答時間ログ」を送信
               3. サーバー側で「人間には不可能な速度でないか」等を検証してDB保存
               
               今回はデモのため、Local Storageを使用します。
            */
            saveScore(ms, str) {
                let ranking = JSON.parse(localStorage.getItem('gateGameRanking') || '[]');
                ranking.push({ time: ms, str: str, date: new Date().toLocaleDateString() });
                ranking.sort((a, b) => a.time - b.time);
                ranking = ranking.slice(0, 5); // Top 5
                localStorage.setItem('gateGameRanking', JSON.stringify(ranking));

                this.showRanking(ranking);
            }

            showRanking(ranking) {
                const list = document.getElementById('ranking-list');
                list.innerHTML = '';
                ranking.forEach((r, i) => {
                    const row = document.createElement('div');
                    row.className = 'ranking-row';
                    row.innerHTML = `
                        <span>#${i+1}</span>
                        <span>${r.str}</span>
                        <span style="font-size:0.8em; color:#aaa;">${r.date}</span>
                    `;
                    list.appendChild(row);
                });
            }
        }

        const game = new Game();
        window.onload = () => game.loadData();

    </script>
</body>
</html>