<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mind Map Prototype v2</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        h1 {
            margin: 0;
            font-size: 1.4rem;
            letter-spacing: 1px;
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        /* Outliner (Right Panel) */
        #outliner {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 200px;
            max-height: 60vh;
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 10px;
            color: white;
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 transparent;
            transition: transform 0.3s ease;
        }

        #outliner::-webkit-scrollbar {
            width: 6px;
        }

        #outliner::-webkit-scrollbar-thumb {
            background-color: #4a90e2;
            border-radius: 3px;
        }

        .outliner-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .outliner-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .outliner-item.active {
            background: rgba(74, 144, 226, 0.3);
            border-left-color: #4a90e2;
        }

        /* Config Button */
        #config-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 20px;
            color: white;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.2s;
            z-index: 150;
        }

        #config-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Config Panel */
        #config-panel {
            display: none;
            position: absolute;
            top: 70px;
            right: 20px;
            width: 240px;
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 15px;
            color: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 150;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .config-action-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        .config-action-btn:hover {
            background: #357abd;
        }

        .config-action-btn.secondary {
            background: #333;
            border: 1px solid #555;
        }

        .config-action-btn.secondary:hover {
            background: #444;
        }

        /* Context Menu */
        #context-menu {
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 200px;
            z-index: 100;
            transform-origin: top left;
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .menu-header {
            font-weight: bold;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            margin-bottom: 4px;
            color: #333;
            text-align: center;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .menu-item {
            display: block;
            width: 100%;
            padding: 10px 12px;
            margin: 2px 0;
            background: none;
            border: none;
            text-align: left;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            color: #333;
            transition: background 0.1s;
        }

        .menu-item:hover {
            background-color: #f0f0f0;
        }

        .menu-item.cancel {
            color: #ff4757;
            border-top: 1px solid #eee;
            margin-top: 4px;
        }

        /* Input Modal */
        #input-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1rem;
        }

        input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 16px;
            border: 2px solid #eee;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            border-color: #4a90e2;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .modal-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-confirm {
            background: #4a90e2;
            color: white;
        }

        .btn-cancel {
            background: #f0f2f5;
            color: #666;
        }
    </style>
</head>

<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Info Overlay -->
    <div id="ui-layer">
        <h1>3D Mind Map</h1>
        <p>Â∑¶„ÇØ„É™„ÉÉ„ÇØ: ÂõûËª¢ / Âè≥„ÇØ„É™„ÉÉ„ÇØ(Èï∑Êäº„Åó): „É°„Éã„É•„Éº</p>
    </div>

    <!-- Outliner -->
    <div id="outliner">
        <!-- List items injected by JS -->
    </div>

    <!-- Config Button -->
    <div id="config-btn" onclick="toggleConfig()">‚öôÔ∏è</div>

    <!-- Config Panel -->
    <div id="config-panel">
        <div class="config-item">
            <label class="config-label">„Éé„Éº„ÉâÈñì„ÅÆË∑ùÈõ¢</label>
            <input type="range" id="dist-slider" min="5" max="20" step="1" value="8"
                oninput="updateSpringLength(this.value)">
        </div>

        <div class="config-item">
            <button class="config-action-btn secondary" onclick="resetCameraToRoot()">üéØ „É´„Éº„Éà„Çí‰∏≠ÂøÉ„Å´„É™„Çª„ÉÉ„Éà</button>
            <button class="config-action-btn" onclick="saveStructure()">üíæ ‰øùÂ≠ò (Save)</button>
            <button class="config-action-btn" onclick="loadStructure()">üìÇ Âæ©ÂÖÉ (Load)</button>
            <button class="config-action-btn secondary" onclick="toggleConfig()" style="margin-top: 15px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="menu-header" id="menu-title">Node Name</div>
        <button class="menu-item" onclick="handleMenu('rename')">‚úèÔ∏è ÂêçÂâç„ÇíÂ§âÊõ¥</button>
        <button class="menu-item" onclick="handleMenu('add')">üå± Â≠ê„Éé„Éº„Éâ„Çí‰ΩúÊàê</button>
        <button class="menu-item" onclick="handleMenu('url')">üîó URL„ÇíÈñã„Åè</button>
        <button class="menu-item cancel" onclick="handleMenu('cancel')">„Ç≠„É£„É≥„Çª„É´</button>
    </div>

    <!-- Rename Modal -->
    <div id="input-modal">
        <div class="modal-content">
            <h3 class="modal-title">„Éé„Éº„ÉâÂêç„ÇíÂ§âÊõ¥</h3>
            <input type="text" id="node-name-input" placeholder="Êñ∞„Åó„ÅÑÂêçÂâç">
            <div class="modal-buttons">
                <button class="modal-btn btn-cancel" onclick="closeModal()">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn btn-confirm" onclick="confirmRename()">OK</button>
            </div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tween.js for smooth animation is not included, using custom lerp logic -->

    <script>
        // --- Sound System (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'add') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'click') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'cancel') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'whoosh') {
                const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) output[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseFilter = audioCtx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(200, now);
                noiseFilter.frequency.linearRampToValueAtTime(2000, now + 0.3);
                noise.connect(noiseFilter);
                noiseFilter.connect(gain);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                noise.start(now);
                noise.stop(now + 0.5);
            }
        }

        // --- 3D Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.005);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 150;

        // --- Data Structure ---
        let nodes = [];
        let connections = [];
        let nextId = 1;

        // --- Canvas Helper: Text Wrapping ---
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            let line = '';
            let lineCount = 0;
            const maxLines = 4; // Max lines before cutting off completely

            // Simple character-based wrapping for Japanese/English mix
            for (let i = 0; i < text.length; i++) {
                const testLine = line + text[i];
                const metrics = ctx.measureText(testLine);
                consttestWidth = metrics.width;

                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(line, x, y);
                    line = text[i];
                    y += lineHeight;
                    lineCount++;
                    if (lineCount >= maxLines) {
                        line = line.substring(0, line.length - 1) + '...';
                        break;
                    }
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, y);
        }

        // --- Visualization Helper: Texture Generation ---
        function createNodeTexture(text) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size / 1.6; // Aspect ratio
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Border
            ctx.lineWidth = 15;
            ctx.strokeStyle = '#4a90e2';
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Fake QR Code (Left side)
            const qrSize = 180;
            const qrX = 30;
            const qrY = (canvas.height - qrSize) / 2;

            ctx.fillStyle = '#000';
            // Draw positioning squares
            ctx.fillRect(qrX, qrY, 40, 40);
            ctx.fillRect(qrX + 140, qrY, 40, 40);
            ctx.fillRect(qrX, qrY + 140, 40, 40);
            // Random noise
            for (let i = 0; i < 80; i++) {
                ctx.fillRect(
                    qrX + Math.random() * qrSize,
                    qrY + Math.random() * qrSize,
                    12, 12
                );
            }

            // Text (Right side)
            ctx.fillStyle = '#333';
            const fontSize = 48;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top'; // Changed to top for multiline

            const textX = qrX + qrSize + 30;
            const textY = 60; // Padding top
            const maxTextWidth = canvas.width - textX - 30;

            wrapText(ctx, text, textX, textY, maxTextWidth, fontSize * 1.2);

            const texture = new THREE.CanvasTexture(canvas);
            // Improve text quality
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        // --- Node Management ---
        function createNode(text, parentNode = null, savedPosition = null) {
            const geometry = new THREE.PlaneGeometry(4, 2.5);
            const material = new THREE.MeshBasicMaterial({
                map: createNodeTexture(text),
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);

            if (savedPosition) {
                mesh.position.copy(savedPosition);
            } else if (parentNode) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 5 + Math.random() * 3;
                mesh.position.set(
                    parentNode.mesh.position.x + Math.cos(angle) * dist,
                    parentNode.mesh.position.y + (Math.random() - 0.5) * 5,
                    parentNode.mesh.position.z + Math.sin(angle) * dist
                );
            } else {
                mesh.position.set(0, 0, 0);
            }

            scene.add(mesh);

            const nodeData = {
                id: nextId++,
                mesh: mesh,
                text: text,
                url: 'https://www.google.com/search?q=' + encodeURIComponent(text),
                velocity: new THREE.Vector3(),
                force: new THREE.Vector3(),
                parent: parentNode
            };

            nodes.push(nodeData);

            if (parentNode) {
                const material = new THREE.LineBasicMaterial({ color: 0x4a90e2, transparent: true, opacity: 0.6 });
                const geometry = new THREE.BufferGeometry().setFromPoints([parentNode.mesh.position, mesh.position]);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                connections.push({ line: line, from: parentNode, to: nodeData });
            }

            updateOutliner();
            return nodeData;
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isLongPress = false;
        let pressTimer;
        let startPointer = { x: 0, y: 0 };
        const LONG_PRESS_DURATION = 600;
        const DRAG_THRESHOLD = 20;

        let selectedNode = null;

        function checkIntersection(screenX, screenY) {
            pointer.x = (screenX / window.innerWidth) * 2 - 1;
            pointer.y = -(screenY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh));
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedNode = nodes.find(n => n.mesh === targetMesh);
                return true;
            }
            return false;
        }

        // Right Click (PC)
        window.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            if (checkIntersection(event.clientX, event.clientY)) {
                playSound('pop');
                showContextMenu(event.clientX, event.clientY, selectedNode);
            }
        });

        // Touch/Mouse Hold
        function onPointerDown(event) {
            if (event.type === 'mousedown' && event.button !== 0) return;
            isLongPress = false;
            const x = event.touches ? event.touches[0].clientX : event.clientX;
            const y = event.touches ? event.touches[0].clientY : event.clientY;
            startPointer.x = x;
            startPointer.y = y;
            pressTimer = setTimeout(() => {
                isLongPress = true;
                handleLongPress(x, y);
            }, LONG_PRESS_DURATION);
        }

        function onPointerMove(event) {
            const x = event.touches ? event.touches[0].clientX : event.clientX;
            const y = event.touches ? event.touches[0].clientY : event.clientY;
            const dx = x - startPointer.x;
            const dy = y - startPointer.y;
            if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
                clearTimeout(pressTimer);
            }
        }

        function onPointerUp(event) {
            clearTimeout(pressTimer);
        }

        function handleLongPress(screenX, screenY) {
            if (checkIntersection(screenX, screenY)) {
                playSound('pop');
                showContextMenu(screenX, screenY, selectedNode);
            }
        }

        window.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchstart', onPointerDown, { passive: false });
        window.addEventListener('touchmove', onPointerMove, { passive: false });
        window.addEventListener('touchend', onPointerUp);

        // --- Outliner Logic ---
        const outliner = document.getElementById('outliner');

        function updateOutliner() {
            outliner.innerHTML = '';
            nodes.forEach(node => {
                const div = document.createElement('div');
                div.className = 'outliner-item';
                div.textContent = node.text;
                div.onclick = () => focusOnNode(node);
                outliner.appendChild(div);
            });
        }

        // Camera Animation Variables
        let isAnimatingCamera = false;
        let cameraTargetPos = new THREE.Vector3();
        let cameraTargetLook = new THREE.Vector3();

        function focusOnNode(node) {
            // Target position: offset from the node to see it
            const offset = new THREE.Vector3(0, 0, 15);
            // Apply current camera rotation to offset to maintain viewing angle or just fixed z?
            // Let's just zoom in to Z offset for simplicity
            cameraTargetPos.copy(node.mesh.position).add(new THREE.Vector3(0, 5, 15));
            controls.target.copy(node.mesh.position); // This is immediate for OrbitControls target

            // We want to smoothly move the camera *position*
            isAnimatingCamera = true;
            playSound('click');
        }

        function resetCameraToRoot() {
            if (nodes.length > 0) focusOnNode(nodes[0]);
        }

        // --- Config Logic ---
        let springLength = 8;
        const configPanel = document.getElementById('config-panel');

        function toggleConfig() {
            if (configPanel.style.display === 'block') {
                configPanel.style.display = 'none';
            } else {
                configPanel.style.display = 'block';
                playSound('click');
            }
        }

        function updateSpringLength(val) {
            springLength = parseFloat(val);
        }

        function saveStructure() {
            const data = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    text: n.text,
                    parentId: n.parent ? n.parent.id : null,
                    position: n.mesh.position // Save pos to prevent explosion on reload
                })),
                springLength: springLength
            };
            localStorage.setItem('mindmap_data', JSON.stringify(data));
            alert('‰øùÂ≠ò„Åó„Åæ„Åó„Åü / Saved');
            playSound('add');
        }

        function loadStructure() {
            const json = localStorage.getItem('mindmap_data');
            if (!json) {
                alert('‰øùÂ≠ò„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì / No saved data');
                return;
            }
            const data = JSON.parse(json);

            // Clear Scene
            nodes.forEach(n => scene.remove(n.mesh));
            connections.forEach(c => scene.remove(c.line));
            nodes = [];
            connections = [];
            nextId = 1;

            // Rebuild
            const idMap = {}; // old ID -> new Node Obj

            // 1. Create Nodes
            data.nodes.forEach(nData => {
                // Ensure IDs don't clash if we add more later, though we reset nextId based on data
                nextId = Math.max(nextId, nData.id + 1);

                // Temp parent handling
                const tempNode = {
                    id: nData.id,
                    text: nData.text,
                    savedPos: new THREE.Vector3(nData.position.x, nData.position.y, nData.position.z),
                    parentId: nData.parentId
                };
                idMap[nData.id] = tempNode;
            });

            // 2. Instantiate in order (Root first usually, but let's handle via map)
            // Ideally sort by ID or just link parents after creation
            data.nodes.sort((a, b) => a.id - b.id).forEach(nData => {
                const parentNode = nData.parentId ? idMap[nData.parentId].realNode : null;
                const newNode = createNode(nData.text, parentNode, idMap[nData.id].savedPos);
                // Override the auto-generated ID to match saved one to keep relationships
                newNode.id = nData.id;
                idMap[nData.id].realNode = newNode;
            });

            if (data.springLength) {
                springLength = data.springLength;
                document.getElementById('dist-slider').value = springLength;
            }

            playSound('add');
            alert('Âæ©ÂÖÉ„Åó„Åæ„Åó„Åü / Loaded');
            toggleConfig();
        }

        // --- Context Menu & UI Logic ---
        const menu = document.getElementById('context-menu');
        const menuTitle = document.getElementById('menu-title');
        const modal = document.getElementById('input-modal');
        const nameInput = document.getElementById('node-name-input');

        function showContextMenu(x, y, node) {
            menuTitle.innerText = node.text;
            let posX = x;
            let posY = y;
            if (posX + 200 > window.innerWidth) posX = window.innerWidth - 210;
            if (posY + 200 > window.innerHeight) posY = window.innerHeight - 210;
            menu.style.left = posX + 'px';
            menu.style.top = posY + 'px';
            menu.style.display = 'block';
        }

        function hideMenu() {
            menu.style.display = 'none';
        }

        function handleMenu(action) {
            if (!selectedNode) return;
            hideMenu();
            switch (action) {
                case 'rename':
                    nameInput.value = selectedNode.text;
                    modal.style.display = 'flex';
                    break;
                case 'add':
                    createNode('New Child', selectedNode);
                    break;
                case 'url':
                    playSound('whoosh');
                    window.open(selectedNode.url, '_blank');
                    break;
                case 'cancel':
                    playSound('cancel');
                    break;
            }
        }

        function closeModal() {
            modal.style.display = 'none';
            playSound('cancel');
        }

        function confirmRename() {
            if (selectedNode && nameInput.value) {
                selectedNode.text = nameInput.value;
                selectedNode.url = 'https://www.google.com/search?q=' + encodeURIComponent(nameInput.value);
                selectedNode.mesh.material.map = createNodeTexture(selectedNode.text);
                selectedNode.mesh.material.needsUpdate = true;
                playSound('click');
                updateOutliner();
            }
            modal.style.display = 'none';
        }

        // --- Force-Directed Graph Logic ---
        const REPULSION = 80;
        const ATTRACTION = 0.01;
        const DAMPING = 0.9;

        function updateLayout() {
            // Forces
            nodes.forEach(node => {
                node.force.set(0, 0, 0);
                if (node.id === 1) { // Root logic
                    node.force.sub(node.mesh.position).multiplyScalar(0.05); // Centering force
                }
            });

            // Repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const diff = new THREE.Vector3().subVectors(n1.mesh.position, n2.mesh.position);
                    let dist = diff.length();
                    if (dist === 0) dist = 0.01;
                    const f = REPULSION / (dist * dist);
                    diff.normalize().multiplyScalar(f);
                    n1.force.add(diff);
                    n2.force.sub(diff);
                }
            }

            // Attraction
            connections.forEach(conn => {
                const diff = new THREE.Vector3().subVectors(conn.to.mesh.position, conn.from.mesh.position);
                const dist = diff.length();
                const displacement = dist - springLength;
                diff.normalize().multiplyScalar(displacement * ATTRACTION);
                conn.to.force.sub(diff);
                conn.from.force.add(diff);
            });

            // Apply Velocity & Position
            nodes.forEach(node => {
                // Skip velocity update for root to keep it stable, but allow small movement
                if (node.id !== 1) {
                    node.velocity.add(node.force);
                    node.velocity.multiplyScalar(DAMPING);
                    node.mesh.position.add(node.velocity);
                } else {
                    node.velocity.set(0, 0, 0); // Root stays put
                    // Optionally root force can slightly nudge it, but 0,0,0 is safer
                }

                // Billboard: Face Camera
                // FIX: This is now OUTSIDE the if(node.id !== 1) block so Root also updates
                node.mesh.quaternion.copy(camera.quaternion);
            });

            // Update Lines
            connections.forEach(conn => {
                const positions = conn.line.geometry.attributes.position.array;
                positions[0] = conn.from.mesh.position.x;
                positions[1] = conn.from.mesh.position.y;
                positions[2] = conn.from.mesh.position.z;
                positions[3] = conn.to.mesh.position.x;
                positions[4] = conn.to.mesh.position.y;
                positions[5] = conn.to.mesh.position.z;
                conn.line.geometry.attributes.position.needsUpdate = true;
            });
        }

        // --- Camera Animation Logic ---
        function updateCamera() {
            if (isAnimatingCamera) {
                // Simple lerp
                camera.position.lerp(cameraTargetPos, 0.05);

                if (camera.position.distanceTo(cameraTargetPos) < 0.1) {
                    isAnimatingCamera = false;
                }
            }
        }

        // --- Main Loop ---
        const rootNode = createNode("ROOT");

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateLayout();
            updateCamera();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>