<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mind Map v20260115.8</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        h1 { margin: 0; font-size: 1.4rem; letter-spacing: 1px; }
        p { margin: 5px 0; font-size: 0.9rem; }

        /* Search Bar */
        #search-container {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            height: 40px;
            z-index: 10;
        }

        #search-input {
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 40, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0 12px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(8px);
            outline: none;
            box-sizing: border-box;
        }
        #search-input::placeholder { color: #aaa; }
        #search-input:focus { border-color: #4a90e2; background: rgba(30, 30, 60, 0.9); }

        /* Outliner */
        #outliner {
            position: absolute;
            top: 130px;
            right: 20px;
            width: 300px;
            max-height: calc(100vh - 150px);
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: auto;
            padding: 10px;
            color: white;
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 transparent;
        }

        #outliner::-webkit-scrollbar { width: 6px; height: 6px; }
        #outliner::-webkit-scrollbar-thumb { background-color: #4a90e2; border-radius: 3px; }

        .outliner-item {
            padding: 6px 12px; margin-bottom: 2px; border-radius: 6px;
            cursor: pointer; font-size: 0.9rem; white-space: nowrap;
            transition: background 0.2s; border-left: 3px solid transparent; display: block;
        }
        .outliner-item:hover { background: rgba(255, 255, 255, 0.1); }
        .outliner-item.active { background: rgba(74, 144, 226, 0.3); border-left-color: #4a90e2; }

        /* Config Button */
        #config-btn {
            position: absolute; top: 20px; right: 20px; width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.1); border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; font-size: 20px; color: white;
            backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.2s; z-index: 150;
        }
        #config-btn:hover { background: rgba(255, 255, 255, 0.2); }

        /* Config Panel */
        #config-panel {
            display: none; position: absolute; top: 70px; right: 20px; width: 240px;
            background: rgba(30, 30, 50, 0.95); backdrop-filter: blur(12px);
            border-radius: 12px; padding: 15px; color: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); z-index: 150;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .config-item { margin-bottom: 15px; }
        .config-label { display: block; font-size: 0.85rem; color: #aaa; margin-bottom: 5px; }
        .value-display { float: right; color: #4a90e2; font-weight: bold; }
        input[type="range"] { width: 100%; cursor: pointer; }

        .config-action-btn {
            display: block; width: 100%; padding: 8px; margin-top: 8px;
            background: #4a90e2; color: white; border: none; border-radius: 6px;
            cursor: pointer; font-size: 0.9rem; transition: background 0.2s;
        }
        .config-action-btn:hover { background: #357abd; }
        .config-action-btn.secondary { background: #333; border: 1px solid #555; }
        .config-action-btn.secondary:hover { background: #444; }

        /* Context Menu */
        #context-menu {
            display: none; position: absolute; background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px); border-radius: 12px; padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); width: 200px; z-index: 100;
        }
        .menu-header {
            font-weight: bold; padding: 8px 12px; border-bottom: 1px solid #eee;
            margin-bottom: 4px; color: #333; text-align: center; font-size: 0.9rem;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .menu-item {
            display: block; width: 100%; padding: 10px 12px; margin: 2px 0;
            background: none; border: none; text-align: left; font-size: 14px;
            cursor: pointer; border-radius: 6px; color: #333;
        }
        .menu-item:hover { background-color: #f0f0f0; }
        .menu-item.delete { color: #ff4757; }
        .menu-item.cancel { color: #666; border-top: 1px solid #eee; margin-top: 4px; }

        /* Modals */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 200; justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 12px; width: 85%; max-width: 320px;
            text-align: center; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }
        .modal-title { margin: 0 0 15px 0; color: #333; font-size: 1.1rem; }
        .modal-desc { font-size: 0.9rem; color: #666; margin-bottom: 20px; line-height: 1.5; }
        
        input[type="text"] {
            width: 100%; box-sizing: border-box; padding: 12px; margin-bottom: 20px;
            font-size: 16px; border: 2px solid #eee; border-radius: 8px; outline: none;
        }
        input[type="text"]:focus { border-color: #4a90e2; }

        .modal-buttons { display: flex; justify-content: space-between; gap: 10px; }
        .modal-buttons-stack { display: flex; flex-direction: column; gap: 10px; }
        .modal-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: 500; }
        
        .btn-confirm { background: #4a90e2; color: white; }
        .btn-danger { background: #ff4757; color: white; }
        .btn-warning { background: #ffaa00; color: white; }
        .btn-cancel { background: #f0f2f5; color: #666; }

        /* Toast */
        #toast {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff;
            text-align: center; border-radius: 8px; padding: 12px; position: fixed;
            z-index: 300; left: 50%; bottom: 30px; transform: translateX(-50%);
            font-size: 15px; opacity: 0; transition: opacity 0.3s, bottom 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #toast.show { visibility: visible; opacity: 1; bottom: 50px; }
        #toast.success { background-color: #2ecc71; }
        #toast.error { background-color: #e74c3c; }

    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>3D Mind Map</h1>
        <p>Â∑¶„ÇØ„É™„ÉÉ„ÇØ: ÂõûËª¢ / Âè≥„ÇØ„É™„ÉÉ„ÇØ: „É°„Éã„É•„Éº</p>
        <p>ÁßªÂãï: W(Ë¶™) S(Â≠ê) A(Ââç) D(Ê¨°)</p>
    </div>

    <!-- Search -->
    <div id="search-container">
        <input type="search" id="search-input" placeholder="üîç „Éé„Éº„Éâ„ÇíÊ§úÁ¥¢ (Enter„ÅßÁßªÂãï)..." oninput="handleSearch(this.value)" onkeydown="if(event.key==='Enter') jumpToFirstMatch()">
    </div>

    <div id="outliner"></div>
    <div id="config-btn" onclick="toggleConfig()">‚öôÔ∏è</div>

    <div id="config-panel">
        <div class="config-item">
            <label class="config-label">
                „Éé„Éº„ÉâÈñì„ÅÆË∑ùÈõ¢
                <span class="value-display" id="dist-val">8.0</span>
            </label>
            <input type="range" id="dist-slider" min="0.1" max="20" step="0.1" value="8"
                oninput="updateSpringLength(this.value)">
        </div>
        <div class="config-item">
            <button class="config-action-btn secondary" onclick="resetCameraToRoot()">üéØ „É´„Éº„Éà„Çí‰∏≠ÂøÉ„Å´„É™„Çª„ÉÉ„Éà</button>
            <hr style="border:0; border-top:1px solid #555; margin:10px 0;">
            <button class="config-action-btn" onclick="exportJSON()">‚¨áÔ∏è „Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò (.json)</button>
            <button class="config-action-btn" onclick="document.getElementById('file-input').click()">‚¨ÜÔ∏è „Éï„Ç°„Ç§„É´„Åã„ÇâË™≠Ëæº (.json)</button>
            <button class="config-action-btn secondary" onclick="toggleConfig()" style="margin-top: 15px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="file-input" style="display:none" accept=".json" onchange="importJSON(this)">
    <input type="color" id="color-input" style="display:none" oninput="applyColor(this.value)">

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="menu-header" id="menu-title">Node Name</div>
        <button class="menu-item" onclick="handleMenu('rename')">‚úèÔ∏è ÂêçÂâç„ÇíÂ§âÊõ¥</button>
        <button class="menu-item" onclick="handleMenu('add')">üå± Â≠ê„Éé„Éº„Éâ„Çí‰ΩúÊàê</button>
        <button class="menu-item delete" id="btn-delete" onclick="handleMenu('delete_confirm')">üóëÔ∏è „Éé„Éº„Éâ„ÇíÂâäÈô§</button>
        <button class="menu-item" onclick="handleMenu('url')">üîó URL„ÇíÈñã„Åè</button>
        <button class="menu-item" onclick="handleMenu('color')">üé® Ëâ≤„ÇíÂ§âÊõ¥</button>
        <button class="menu-item cancel" onclick="handleMenu('cancel')">„Ç≠„É£„É≥„Çª„É´</button>
    </div>

    <!-- Modals -->
    <div id="rename-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">„Éé„Éº„ÉâÂêç„ÇíÂ§âÊõ¥</h3>
            <input type="text" id="node-name-input" placeholder="Êñ∞„Åó„ÅÑÂêçÂâç">
            <div class="modal-buttons">
                <button class="modal-btn btn-cancel" onclick="closeModal('rename-modal')">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn btn-confirm" onclick="confirmRename()">OK</button>
            </div>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ÂâäÈô§„ÅÆÁ¢∫Ë™ç</h3>
            <p class="modal-desc">„Éé„Éº„Éâ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ<br>Â≠ê„Éé„Éº„Éâ„ÅÆÊâ±„ÅÑ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            <div class="modal-buttons-stack">
                <button class="modal-btn btn-danger" onclick="executeDelete('all')">üóëÔ∏è Â≠êÂ≠´„ÇíÂÖ®ÂâäÈô§</button>
                <button class="modal-btn btn-warning" onclick="executeDelete('reparent')">üîó Â≠ê„ÇíË¶™„Å´Êé•Á∂ö (Á∂ôÊâø)</button>
                <button class="modal-btn btn-cancel" onclick="closeModal('delete-modal')">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>

    <div id="toast">Message</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

    <script>
        // --- Utils ---
        const toastEl = document.getElementById('toast');
        function showToast(msg, type='success') {
            toastEl.textContent = msg;
            toastEl.className = type === 'success' ? 'show success' : 'show error';
            setTimeout(() => { toastEl.className = toastEl.className.replace('show', ''); }, 3000);
        }

        // --- Sound ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            if (type === 'pop') {
                osc.type='sine';osc.frequency.setValueAtTime(400,now);osc.frequency.exponentialRampToValueAtTime(800,now+0.1);
                gain.gain.setValueAtTime(0.5,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.2);
                osc.start(now);osc.stop(now+0.2);
            } else if (type === 'add') {
                osc.type='triangle';osc.frequency.setValueAtTime(300,now);osc.frequency.linearRampToValueAtTime(600,now+0.1);
                gain.gain.setValueAtTime(0.3,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.4);
                osc.start(now);osc.stop(now+0.4);
            } else if (type === 'click') {
                osc.type='square';osc.frequency.setValueAtTime(800,now);
                gain.gain.setValueAtTime(0.1,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.05);
                osc.start(now);osc.stop(now+0.05);
            } else if (type === 'delete') {
                osc.type='sawtooth';osc.frequency.setValueAtTime(150,now);osc.frequency.linearRampToValueAtTime(50,now+0.3);
                gain.gain.setValueAtTime(0.3,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.3);
                osc.start(now);osc.stop(now+0.3);
            } else if (type === 'whoosh') {
                const n=audioCtx.createBufferSource(); const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.5,audioCtx.sampleRate);
                const d=b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
                n.buffer=b; const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(200,now); f.frequency.linearRampToValueAtTime(2000,now+0.3);
                n.connect(f); f.connect(gain); gain.gain.setValueAtTime(0.5,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.5);
                n.start(now); n.stop(now+0.5);
            } else if (type === 'cancel') {
                osc.type='sine';osc.frequency.setValueAtTime(300,now);osc.frequency.exponentialRampToValueAtTime(100,now+0.15);
                gain.gain.setValueAtTime(0.3,now);gain.gain.exponentialRampToValueAtTime(0.01,now+0.2);
                osc.start(now);osc.stop(now+0.2);
            }
        }

        // --- 3D Scene ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.005);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 20, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 0.5; controls.maxDistance = 250;
        controls.minPolarAngle = 0; controls.maxPolarAngle = Math.PI;

        // --- Starfield (Multi-layer for variation) ---
        function createStarField() {
            // Layer 1: Small distant stars
            const geo1 = new THREE.BufferGeometry();
            const count1 = 1500;
            const pos1 = new Float32Array(count1 * 3);
            for (let i = 0; i < count1; i++) {
                const r = 800 + Math.random() * 400; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos1[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                pos1[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                pos1[i * 3 + 2] = r * Math.cos(phi);
            }
            geo1.setAttribute('position', new THREE.BufferAttribute(pos1, 3));
            const mat1 = new THREE.PointsMaterial({ size: 1.2, color: 0xaaaaaa, transparent: true, opacity: 0.6, fog: false });
            scene.add(new THREE.Points(geo1, mat1));

            // Layer 2: Bigger, brighter stars
            const geo2 = new THREE.BufferGeometry();
            const count2 = 400;
            const pos2 = new Float32Array(count2 * 3);
            for (let i = 0; i < count2; i++) {
                const r = 700 + Math.random() * 500; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos2[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                pos2[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                pos2[i * 3 + 2] = r * Math.cos(phi);
            }
            geo2.setAttribute('position', new THREE.BufferAttribute(pos2, 3));
            const mat2 = new THREE.PointsMaterial({ size: 2.5, color: 0xffffff, transparent: true, opacity: 0.9, fog: false });
            scene.add(new THREE.Points(geo2, mat2));
        }
        createStarField();

        let nodes = []; let connections = []; let nextId = 1; let selectedNode = null; let activeNode = null;
        const indicatorGroup = new THREE.Group(); scene.add(indicatorGroup);
        const indicators = { w: null, a: null, s: null, d: null };

        function createTri(color, zRot, offset) {
            const s = new THREE.Shape(); s.moveTo(0,0.5); s.lineTo(0.4,-0.3); s.lineTo(-0.4,-0.3);
            const m = new THREE.Mesh(new THREE.ShapeGeometry(s), new THREE.MeshBasicMaterial({color:color,side:THREE.DoubleSide,transparent:true,opacity:0.8}));
            m.rotation.z = zRot; m.position.set(offset.x, offset.y, 0); m.scale.set(0.75, 0.75, 0.75);
            return m;
        }
        indicators.w = createTri(0x00ffff, 0, {x:0, y:1.7}); indicators.s = createTri(0x00ff00, Math.PI, {x:0, y:-1.7});
        indicators.a = createTri(0xffaa00, Math.PI/2, {x:-2.4, y:0}); indicators.d = createTri(0xffaa00, -Math.PI/2, {x:2.4, y:0});
        Object.values(indicators).forEach(m => indicatorGroup.add(m));

        function updateIndicators() {
            if (!activeNode) { indicatorGroup.visible = false; return; }
            indicatorGroup.visible = true;
            indicatorGroup.position.copy(activeNode.mesh.position);
            indicatorGroup.quaternion.copy(camera.quaternion);
            indicators.w.visible = !!activeNode.parent;
            indicators.s.visible = nodes.some(n => n.parent === activeNode);
            if (activeNode.parent) {
                const s = nodes.filter(n => n.parent === activeNode.parent).sort((a,b)=>a.id-b.id);
                const i = s.indexOf(activeNode);
                indicators.a.visible = (i > 0); indicators.d.visible = (i < s.length - 1);
            } else { indicators.a.visible = false; indicators.d.visible = false; }
        }

        function createNodeTexture(text, color = '#ffffff') {
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=320;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.lineWidth=15; ctx.strokeStyle='#4a90e2'; ctx.strokeRect(0,0,canvas.width,canvas.height);
            const qr = new QRious({ value: window.location.href, size: 180, level: 'L' });
            ctx.drawImage(qr.canvas, 30, (canvas.height-180)/2);
            ctx.fillStyle='#333'; ctx.font='bold 48px Arial'; ctx.textAlign='left'; ctx.textBaseline='top';
            let line='', lc=0, y=60;
            for(let i=0;i<text.length;i++){
                if(ctx.measureText(line+text[i]).width>240 && i>0){ ctx.fillText(line,240,y); line=text[i]; y+=58; lc++; if(lc>=4){line=line.slice(0,-1)+'...';break;} }
                else line+=text[i];
            }
            ctx.fillText(line,240,y);
            return new THREE.CanvasTexture(canvas);
        }

        function createNode(text, parentNode = null, savedPosition = null, color = '#ffffff') {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 2.5), new THREE.MeshBasicMaterial({ map: createNodeTexture(text, color), side: THREE.DoubleSide }));
            if (savedPosition) mesh.position.copy(savedPosition);
            else if (parentNode) {
                const a = Math.random()*Math.PI*2, d = springLength;
                mesh.position.set(parentNode.mesh.position.x+Math.cos(a)*d, parentNode.mesh.position.y+(Math.random()-0.5)*d, parentNode.mesh.position.z+Math.sin(a)*d);
            }
            scene.add(mesh);
            const node = { id: nextId++, mesh: mesh, text: text, color: color, url: 'https://www.google.com/search?q='+encodeURIComponent(text), velocity: new THREE.Vector3(), force: new THREE.Vector3(), parent: parentNode };
            nodes.push(node);
            if (parentNode) {
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([parentNode.mesh.position, mesh.position]), new THREE.LineBasicMaterial({color:0x4a90e2,transparent:true,opacity:0.6}));
                scene.add(line); connections.push({line:line, from:parentNode, to:node});
            }
            if (nodes.length === 1) activeNode = node;
            updateOutliner(); return node;
        }

        // --- Search (Visual Fix) ---
        function handleSearch(val) {
            val = val.toLowerCase();
            const items = document.querySelectorAll('.outliner-item');
            // Filter DOM elements directly based on their text content
            items.forEach(item => {
                const match = item.textContent.toLowerCase().includes(val);
                item.style.display = match ? 'block' : 'none';
            });
        }

        function jumpToFirstMatch() {
            const val = document.getElementById('search-input').value.toLowerCase();
            const items = document.querySelectorAll('.outliner-item');
            for (let item of items) {
                if (item.style.display !== 'none' && item.textContent.toLowerCase().includes(val)) {
                    // Trigger click on the DOM element to ensure correct mapping
                    item.click();
                    playSound('click');
                    break;
                }
            }
        }

        // --- Deletion Logic ---
        function executeDelete(mode) {
            if (!selectedNode || !selectedNode.parent) return; 
            const target = selectedNode;
            const parent = target.parent;
            closeModal('delete-modal');
            const nodesToRemove = new Set();

            if (mode === 'all') {
                function collect(n) { nodesToRemove.add(n); nodes.filter(c => c.parent === n).forEach(collect); }
                collect(target);
            } else if (mode === 'reparent') {
                nodesToRemove.add(target);
                const children = nodes.filter(n => n.parent === target);
                children.forEach(child => {
                    child.parent = parent; 
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([parent.mesh.position, child.mesh.position]), new THREE.LineBasicMaterial({color:0x4a90e2,transparent:true,opacity:0.6}));
                    scene.add(line); connections.push({line:line, from:parent, to:child});
                });
            }

            nodesToRemove.forEach(n => { scene.remove(n.mesh); n.mesh.geometry.dispose(); n.mesh.material.dispose(); });
            const deadLines = connections.filter(c => nodesToRemove.has(c.from) || nodesToRemove.has(c.to));
            deadLines.forEach(c => { scene.remove(c.line); c.line.geometry.dispose(); });
            connections = connections.filter(c => !nodesToRemove.has(c.from) && !nodesToRemove.has(c.to));
            nodes = nodes.filter(n => !nodesToRemove.has(n));

            activeNode = parent; focusOnNodeWithTrace(parent); updateOutliner(); playSound('delete'); showToast('ÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        // --- Outliner ---
        const outliner = document.getElementById('outliner');
        function updateOutliner() {
            const filterVal = document.getElementById('search-input').value.toLowerCase();
            outliner.innerHTML = '';
            function build(node, depth) {
                const d = document.createElement('div'); d.className='outliner-item'; 
                if(activeNode&&activeNode.id===node.id)d.classList.add('active');
                d.style.paddingLeft=(12+depth*15)+'px'; d.textContent=node.text;
                d.onclick=(e)=>{e.stopPropagation(); focusOnNodeWithTrace(node);};
                if (!node.text.toLowerCase().includes(filterVal)) d.style.display = 'none';
                outliner.appendChild(d);
                nodes.filter(n=>n.parent===node).forEach(c=>build(c,depth+1));
            }
            const r=nodes.filter(n=>!n.parent); if(r.length===0&&nodes.length>0)nodes.forEach(n=>build(n,0)); else r.forEach(n=>build(n,0));
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2();
        let isLongPress=false, pressTimer, startP={x:0,y:0};
        function checkIntersection(x,y) {
            pointer.x=(x/window.innerWidth)*2-1; pointer.y=-(y/window.innerHeight)*2+1;
            raycaster.setFromCamera(pointer,camera);
            const ints=raycaster.intersectObjects(nodes.map(n=>n.mesh));
            if(ints.length>0){ selectedNode=nodes.find(n=>n.mesh===ints[0].object); return true; } return false;
        }
        window.addEventListener('contextmenu',(e)=>{ e.preventDefault(); if(checkIntersection(e.clientX,e.clientY)){playSound('pop');showContextMenu(e.clientX,e.clientY,selectedNode);} });
        function onDown(e){ if(e.type==='mousedown'&&e.button!==0)return; isLongPress=false; const x=e.touches?e.touches[0].clientX:e.clientX, y=e.touches?e.touches[0].clientY:e.clientY; startP={x:x,y:y}; pressTimer=setTimeout(()=>{isLongPress=true;if(checkIntersection(x,y)){playSound('pop');showContextMenu(x,y,selectedNode);}},600); }
        function onMove(e){ const x=e.touches?e.touches[0].clientX:e.clientX, y=e.touches?e.touches[0].clientY:e.clientY; if(Math.hypot(x-startP.x,y-startP.y)>20)clearTimeout(pressTimer); }
        function onUp(){ clearTimeout(pressTimer); }
        window.addEventListener('mousedown',onDown); window.addEventListener('mousemove',onMove); window.addEventListener('mouseup',onUp);
        window.addEventListener('touchstart',onDown,{passive:false}); window.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('touchend',onUp);
        
        window.addEventListener('keydown',(e)=>{
            if(document.querySelector('.modal-overlay[style*="flex"]')) return;
            if(e.target.id === 'search-input') return; 
            if(!activeNode&&nodes.length>0){focusOnNodeWithTrace(nodes[0]);return;}
            if(!activeNode)return;
            let t=null, k=e.key.toLowerCase();
            if(k==='w'&&activeNode.parent)t=activeNode.parent;
            else if(k==='s'){const c=nodes.filter(n=>n.parent===activeNode);if(c.length)t=c[0];}
            else if(k==='a'||k==='d'){const s=nodes.filter(n=>n.parent===activeNode.parent).sort((a,b)=>a.id-b.id); const i=s.indexOf(activeNode); if(i!==-1){if(k==='a'&&i>0)t=s[i-1];if(k==='d'&&i<s.length-1)t=s[i+1];}}
            if(t)focusOnNodeWithTrace(t);
        });

        // --- Camera Anim ---
        let isAnimatingCamera=false, animationQueue=[];
        function focusOnNodeWithTrace(t) {
            if(!activeNode) activeNode=t; if(activeNode===t){activeNode=t;updateOutliner();return;}
            let cp=[], tmp=activeNode; while(tmp){cp.push(tmp);tmp=tmp.parent;}
            let tp=[], tmp2=t; while(tmp2){tp.push(tmp2);tmp2=tmp2.parent;}
            let lca=null; for(let n of cp){if(tp.includes(n)){lca=n;break;}}
            animationQueue=[];
            for(let i=0;i<cp.length;i++){if(cp[i]===lca)break;animationQueue.push(cp[i]);}
            if(lca)animationQueue.push(lca);
            let dp=[]; for(let i=0;i<tp.length;i++){if(tp[i]===lca)break;dp.push(tp[i]);}
            dp.reverse().forEach(n=>animationQueue.push(n));
            if(animationQueue.length>0&&animationQueue[0]===activeNode)animationQueue.shift();
            activeNode=t; updateOutliner();
            if(animationQueue.length>0){isAnimatingCamera=true;playSound('whoosh');}
        }
        function updateCamera(){
            updateIndicators();
            if(isAnimatingCamera){
                if(animationQueue.length>0){
                    const n=animationQueue[0], off=new THREE.Vector3(0,5,15), tl=n.mesh.position.clone().add(off);
                    controls.target.lerp(n.mesh.position,0.1); camera.position.lerp(tl,0.15);
                    if(camera.position.distanceTo(tl)<8)animationQueue.shift();
                } else {
                    if(!activeNode)return; const tl=activeNode.mesh.position.clone().add(new THREE.Vector3(0,5,15));
                    controls.target.lerp(activeNode.mesh.position,0.1); camera.position.lerp(tl,0.1);
                    if(camera.position.distanceTo(tl)<0.1){isAnimatingCamera=false;controls.target.copy(activeNode.mesh.position);}
                }
            } else if(activeNode) controls.target.lerp(activeNode.mesh.position,0.1);
        }

        // --- Config & I/O ---
        let springLength=8, repulsionStrength=20;
        const conf=document.getElementById('config-panel');
        function toggleConfig(){ const s=conf.style.display==='block'; conf.style.display=s?'none':'block'; if(!s)playSound('click'); }
        function updateSpringLength(v){ springLength=parseFloat(v); document.getElementById('dist-val').innerText=springLength.toFixed(1); repulsionStrength=springLength*2.5; }
        function resetCameraToRoot(){ if(nodes[0])focusOnNodeWithTrace(nodes[0]); }
        
        function getSaveData() { return JSON.stringify({nodes:nodes.map(n=>({id:n.id,text:n.text,parentId:n.parent?n.parent.id:null,pos:n.mesh.position,color:n.color})),springLength:springLength}); }
        function exportJSON(){
            const blob = new Blob([getSaveData()], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href=url; a.download='mindmap.json'; a.click();
            playSound('add'); showToast('„Éï„Ç°„Ç§„É´„ÅØ„Äå„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Äç„Éï„Ç©„É´„ÉÄ„Å´‰øùÂ≠ò„Åï„Çå„Åæ„Åô');
        }

        function loadData(jsonStr) {
            try {
                const d=JSON.parse(jsonStr);
                nodes.forEach(n=>scene.remove(n.mesh)); connections.forEach(c=>scene.remove(c.line));
                nodes=[]; connections=[]; nextId=1; activeNode=null; indicatorGroup.visible=false;
                const m={}; d.nodes.forEach(x=>{m[x.id]={...x,real:null}; nextId=Math.max(nextId,x.id+1);});
                d.nodes.sort((a,b)=>a.id-b.id).forEach(x=>{
                    const p=x.parentId?m[x.parentId].real:null;
                    const n=createNode(x.text,p,new THREE.Vector3(x.pos.x,x.pos.y,x.pos.z), x.color || '#ffffff');
                    n.id=x.id; m[x.id].real=n;
                });
                if(d.springLength){updateSpringLength(d.springLength); document.getElementById('dist-slider').value=d.springLength;}
                playSound('add'); showToast('„Éá„Éº„Çø„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü');
            } catch(e) { showToast('„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü','error'); }
        }
        function importJSON(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => { loadData(e.target.result); toggleConfig(); input.value = ''; };
            reader.readAsText(file);
        }

        // --- Context & Modals ---
        const menu=document.getElementById('context-menu');
        const renameModal=document.getElementById('rename-modal');
        const deleteModal=document.getElementById('delete-modal');
        const nameInput=document.getElementById('node-name-input');
        
        function showContextMenu(x,y,node){
            document.getElementById('menu-title').innerText=node.text;
            document.getElementById('btn-delete').style.display=node.parent?'block':'none';
            menu.style.left=Math.min(x,window.innerWidth-210)+'px'; menu.style.top=Math.min(y,window.innerHeight-210)+'px';
            menu.style.display='block';
        }
        function handleMenu(act){
            if(!selectedNode)return; menu.style.display='none';
            if(act==='rename'){nameInput.value=selectedNode.text; renameModal.style.display='flex';}
            else if(act==='color'){document.getElementById('color-input').click();}
            else if(act==='add')createNode('New Node ' + nextId, selectedNode); 
            else if(act==='delete_confirm') deleteModal.style.display='flex';
            else if(act==='url'){playSound('whoosh'); window.open(selectedNode.url,'_blank');}
            else playSound('cancel');
        }
        function closeModal(id){ document.getElementById(id).style.display='none'; playSound('cancel'); }
        function confirmRename(){
            if(selectedNode&&nameInput.value){
                selectedNode.text=nameInput.value; selectedNode.url='https://www.google.com/search?q='+encodeURIComponent(nameInput.value);
                selectedNode.mesh.material.map=createNodeTexture(selectedNode.text, selectedNode.color); updateOutliner(); playSound('click');
            }
            closeModal('rename-modal');
        }
        function applyColor(hex) {
            if(selectedNode) {
                selectedNode.color = hex;
                selectedNode.mesh.material.map = createNodeTexture(selectedNode.text, hex);
                // No playSound here to avoid spamming while dragging
            }
        }

        // --- Physics ---
        function updateLayout(){
            nodes.forEach(n=>{ n.force.set(0,0,0); if(n.id===1)n.force.sub(n.mesh.position).multiplyScalar(0.05); });
            for(let i=0;i<nodes.length;i++)for(let j=i+1;j<nodes.length;j++){
                const d=new THREE.Vector3().subVectors(nodes[i].mesh.position,nodes[j].mesh.position);
                let l=d.length(); if(l===0)l=0.01; d.normalize().multiplyScalar(repulsionStrength/(l*l));
                nodes[i].force.add(d); nodes[j].force.sub(d);
            }
            connections.forEach(c=>{
                const d=new THREE.Vector3().subVectors(c.to.mesh.position,c.from.mesh.position);
                const l=d.length(); d.normalize().multiplyScalar((l-springLength)*0.05);
                c.to.force.sub(d); c.from.force.add(d);
            });
            nodes.forEach(n=>{ if(n.id!==1){n.velocity.add(n.force).multiplyScalar(0.9); n.mesh.position.add(n.velocity);} n.mesh.quaternion.copy(camera.quaternion); });
            connections.forEach(c=>{
                const p=c.line.geometry.attributes.position.array;
                p[0]=c.from.mesh.position.x; p[1]=c.from.mesh.position.y; p[2]=c.from.mesh.position.z;
                p[3]=c.to.mesh.position.x; p[4]=c.to.mesh.position.y; p[5]=c.to.mesh.position.z;
                c.line.geometry.attributes.position.needsUpdate=true;
            });
        }
        const root = createNode("ROOT");
        function animate(){ requestAnimationFrame(animate); controls.update(); updateLayout(); updateCamera(); renderer.render(scene,camera); }
        window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);});
        animate();
    </script>
</body>
</html>