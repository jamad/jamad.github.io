<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Mind Map Prototype v2.1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        h1 {
            margin: 0;
            font-size: 1.4rem;
            letter-spacing: 1px;
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        /* Outliner (Right Panel) - Modified */
        #outliner {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px; /* ÂπÖ„Çí150%Á®ãÂ∫¶„Å´Êã°Â§ß (ÂÖÉ200px) */
            max-height: 60vh;
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: auto; /* Ê∞¥Âπ≥„Çπ„ÇØ„É≠„Éº„É´ËøΩÂä† */
            padding: 10px;
            color: white;
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 transparent;
            transition: transform 0.3s ease;
        }

        #outliner::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        #outliner::-webkit-scrollbar-thumb {
            background-color: #4a90e2;
            border-radius: 3px;
        }

        .outliner-item {
            padding: 6px 12px; /* Â∞ë„Åó„Ç≥„É≥„Éë„ÇØ„Éà„Å´ */
            margin-bottom: 2px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap; /* Êäò„ÇäËøî„Åï„Å™„ÅÑ */
            transition: background 0.2s;
            border-left: 3px solid transparent;
            display: block;
        }

        .outliner-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .outliner-item.active {
            background: rgba(74, 144, 226, 0.3);
            border-left-color: #4a90e2;
        }

        /* Config Button */
        #config-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 20px;
            color: white;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.2s;
            z-index: 150;
        }

        #config-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Config Panel */
        #config-panel {
            display: none;
            position: absolute;
            top: 70px;
            right: 20px;
            width: 240px;
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 15px;
            color: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 150;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .config-action-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        .config-action-btn:hover {
            background: #357abd;
        }

        .config-action-btn.secondary {
            background: #333;
            border: 1px solid #555;
        }

        .config-action-btn.secondary:hover {
            background: #444;
        }

        /* Context Menu */
        #context-menu {
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 200px;
            z-index: 100;
            transform-origin: top left;
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .menu-header {
            font-weight: bold;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            margin-bottom: 4px;
            color: #333;
            text-align: center;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .menu-item {
            display: block;
            width: 100%;
            padding: 10px 12px;
            margin: 2px 0;
            background: none;
            border: none;
            text-align: left;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            color: #333;
            transition: background 0.1s;
        }

        .menu-item:hover {
            background-color: #f0f0f0;
        }

        .menu-item.cancel {
            color: #ff4757;
            border-top: 1px solid #eee;
            margin-top: 4px;
        }

        /* Input Modal */
        #input-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1rem;
        }

        input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 16px;
            border: 2px solid #eee;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            border-color: #4a90e2;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .modal-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-confirm {
            background: #4a90e2;
            color: white;
        }

        .btn-cancel {
            background: #f0f2f5;
            color: #666;
        }
    </style>
</head>

<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Info Overlay -->
    <div id="ui-layer">
        <h1>3D Mind Map</h1>
        <p>Â∑¶„ÇØ„É™„ÉÉ„ÇØ: ÂõûËª¢ / Âè≥„ÇØ„É™„ÉÉ„ÇØ: „É°„Éã„É•„Éº</p>
        <p>ÁßªÂãï: W(Ë¶™) S(Â≠ê) A(Ââç) D(Ê¨°)</p>
    </div>

    <!-- Outliner -->
    <div id="outliner">
        <!-- List items injected by JS -->
    </div>

    <!-- Config Button -->
    <div id="config-btn" onclick="toggleConfig()">‚öôÔ∏è</div>

    <!-- Config Panel -->
    <div id="config-panel">
        <div class="config-item">
            <label class="config-label">„Éé„Éº„ÉâÈñì„ÅÆË∑ùÈõ¢</label>
            <!-- Modified Min value to 1 (20% of 5) -->
            <input type="range" id="dist-slider" min="1" max="20" step="0.5" value="8"
                oninput="updateSpringLength(this.value)">
        </div>

        <div class="config-item">
            <button class="config-action-btn secondary" onclick="resetCameraToRoot()">üéØ „É´„Éº„Éà„Çí‰∏≠ÂøÉ„Å´„É™„Çª„ÉÉ„Éà</button>
            <button class="config-action-btn" onclick="saveStructure()">üíæ ‰øùÂ≠ò (Save)</button>
            <button class="config-action-btn" onclick="loadStructure()">üìÇ Âæ©ÂÖÉ (Load)</button>
            <button class="config-action-btn secondary" onclick="toggleConfig()" style="margin-top: 15px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="menu-header" id="menu-title">Node Name</div>
        <button class="menu-item" onclick="handleMenu('rename')">‚úèÔ∏è ÂêçÂâç„ÇíÂ§âÊõ¥</button>
        <button class="menu-item" onclick="handleMenu('add')">üå± Â≠ê„Éé„Éº„Éâ„Çí‰ΩúÊàê</button>
        <button class="menu-item" onclick="handleMenu('url')">üîó URL„ÇíÈñã„Åè</button>
        <button class="menu-item cancel" onclick="handleMenu('cancel')">„Ç≠„É£„É≥„Çª„É´</button>
    </div>

    <!-- Rename Modal -->
    <div id="input-modal">
        <div class="modal-content">
            <h3 class="modal-title">„Éé„Éº„ÉâÂêç„ÇíÂ§âÊõ¥</h3>
            <input type="text" id="node-name-input" placeholder="Êñ∞„Åó„ÅÑÂêçÂâç">
            <div class="modal-buttons">
                <button class="modal-btn btn-cancel" onclick="closeModal()">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn btn-confirm" onclick="confirmRename()">OK</button>
            </div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Sound System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'pop') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'add') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'click') {
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'whoosh') {
                const noise = audioCtx.createBufferSource();
                const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
                const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
                noise.buffer = buf;
                const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(200,now); f.frequency.linearRampToValueAtTime(2000,now+0.3);
                noise.connect(f); f.connect(gain);
                gain.gain.setValueAtTime(0.5,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.5);
                noise.start(now); noise.stop(now+0.5);
            } else if (type === 'cancel') {
                osc.type='sine'; osc.frequency.setValueAtTime(300,now); osc.frequency.exponentialRampToValueAtTime(100,now+0.15);
                gain.gain.setValueAtTime(0.3,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.2);
                osc.start(now); osc.stop(now+0.2);
            }
        }

        // --- 3D Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.005);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2; // Closer min dist
        controls.maxDistance = 150;

        // --- ADDED: Starfield Background ---
        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const count = 1500;
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 400; // Large spread
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff, transparent: true, opacity: 0.8 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        createStarField();

        // --- Data ---
        let nodes = [];
        let connections = [];
        let nextId = 1;
        let selectedNode = null; // For context menu
        let activeNode = null;   // For navigation focus

        // --- Visual Helpers ---
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            let line = '';
            let lineCount = 0;
            for (let i = 0; i < text.length; i++) {
                const testLine = line + text[i];
                if (ctx.measureText(testLine).width > maxWidth && i > 0) {
                    ctx.fillText(line, x, y);
                    line = text[i];
                    y += lineHeight;
                    lineCount++;
                    if (lineCount >= 4) { line = line.slice(0, -1) + '...'; break; }
                } else { line = testLine; }
            }
            ctx.fillText(line, x, y);
        }

        function createNodeTexture(text) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size / 1.6;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 15; ctx.strokeStyle = '#4a90e2'; ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Fake QR
            ctx.fillStyle = '#000';
            ctx.fillRect(30, 90, 40, 40); ctx.fillRect(170, 90, 40, 40); ctx.fillRect(30, 230, 40, 40);
            for(let i=0; i<80; i++) ctx.fillRect(30+Math.random()*180, 90+Math.random()*180, 12, 12);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            wrapText(ctx, text, 240, 60, 240, 58);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            return tex;
        }

        // --- Node Logic ---
        function createNode(text, parentNode = null, savedPosition = null) {
            const geometry = new THREE.PlaneGeometry(4, 2.5);
            const material = new THREE.MeshBasicMaterial({ map: createNodeTexture(text), side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);

            if (savedPosition) mesh.position.copy(savedPosition);
            else if (parentNode) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 5 + Math.random() * 3;
                mesh.position.set(parentNode.mesh.position.x + Math.cos(angle) * dist, parentNode.mesh.position.y + (Math.random()-0.5)*5, parentNode.mesh.position.z + Math.sin(angle) * dist);
            }

            scene.add(mesh);

            const nodeData = {
                id: nextId++,
                mesh: mesh,
                text: text,
                url: 'https://www.google.com/search?q=' + encodeURIComponent(text),
                velocity: new THREE.Vector3(),
                force: new THREE.Vector3(),
                parent: parentNode
            };

            nodes.push(nodeData);

            if (parentNode) {
                const lMat = new THREE.LineBasicMaterial({ color: 0x4a90e2, transparent: true, opacity: 0.6 });
                const lGeo = new THREE.BufferGeometry().setFromPoints([parentNode.mesh.position, mesh.position]);
                const line = new THREE.Line(lGeo, lMat);
                scene.add(line);
                connections.push({ line: line, from: parentNode, to: nodeData });
            }

            // If first node, make it active
            if (nodes.length === 1) activeNode = nodeData;

            updateOutliner();
            return nodeData;
        }

        // --- Updated Outliner: Recursive & Indented ---
        const outliner = document.getElementById('outliner');

        function updateOutliner() {
            outliner.innerHTML = '';
            
            // Recursive builder
            function buildList(node, depth) {
                const div = document.createElement('div');
                div.className = 'outliner-item';
                if (activeNode && activeNode.id === node.id) div.classList.add('active');
                
                // Indent
                div.style.paddingLeft = (12 + depth * 15) + 'px'; 
                div.textContent = node.text;
                
                div.onclick = (e) => {
                    e.stopPropagation();
                    focusOnNodeWithTrace(node);
                };
                
                outliner.appendChild(div);

                // Find children
                const children = nodes.filter(n => n.parent === node);
                children.forEach(child => buildList(child, depth + 1));
            }

            // Start with root(s)
            const roots = nodes.filter(n => !n.parent);
            if(roots.length === 0 && nodes.length > 0) {
                // Fallback if circular or weird
                nodes.forEach(n => buildList(n, 0));
            } else {
                roots.forEach(r => buildList(r, 0));
            }
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isLongPress = false;
        let pressTimer;
        let startPointer = { x: 0, y: 0 };
        const LONG_PRESS_DURATION = 600;

        function checkIntersection(x, y) {
            pointer.x = (x / window.innerWidth) * 2 - 1;
            pointer.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh));
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedNode = nodes.find(n => n.mesh === targetMesh);
                activeNode = selectedNode;
                updateOutliner();
                return true;
            }
            return false;
        }

        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (checkIntersection(e.clientX, e.clientY)) {
                playSound('pop');
                showContextMenu(e.clientX, e.clientY, selectedNode);
            }
        });

        // Mouse/Touch logic
        function onDown(e) {
            if (e.type === 'mousedown' && e.button !== 0) return;
            isLongPress = false;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            startPointer = { x: cx, y: cy };
            pressTimer = setTimeout(() => {
                isLongPress = true;
                if (checkIntersection(cx, cy)) { playSound('pop'); showContextMenu(cx, cy, selectedNode); }
            }, LONG_PRESS_DURATION);
        }
        function onMove(e) {
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            if (Math.hypot(cx - startPointer.x, cy - startPointer.y) > 20) clearTimeout(pressTimer);
        }
        function onUp() { clearTimeout(pressTimer); }

        window.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onUp);

        // --- WASD Navigation ---
        window.addEventListener('keydown', (e) => {
            // Ignore if modal is open
            if (document.getElementById('input-modal').style.display === 'flex') return;
            
            if (!activeNode && nodes.length > 0) {
                activeNode = nodes[0];
                focusOnNodeWithTrace(activeNode);
                return;
            }
            if (!activeNode) return;

            let target = null;
            const key = e.key.toLowerCase();

            if (key === 'w') {
                // Parent
                if (activeNode.parent) target = activeNode.parent;
            } else if (key === 's') {
                // First Child (Using S instead of duplicate D)
                const children = nodes.filter(n => n.parent === activeNode);
                if (children.length > 0) target = children[0];
            } else if (key === 'a' || key === 'd') {
                // Siblings
                const siblings = nodes.filter(n => n.parent === activeNode.parent).sort((a,b) => a.id - b.id);
                const idx = siblings.indexOf(activeNode);
                if (idx !== -1) {
                    if (key === 'a' && idx > 0) target = siblings[idx - 1]; // Prev
                    if (key === 'd' && idx < siblings.length - 1) target = siblings[idx + 1]; // Next
                }
            }

            if (target) {
                activeNode = target;
                updateOutliner();
                focusOnNode(target); // Direct focus for keys, trace is for big jumps
            }
        });

        // --- Camera Animation System ---
        let isAnimatingCamera = false;
        let cameraTargetPos = new THREE.Vector3();
        let animationQueue = []; // For path tracing

        function focusOnNode(node) {
            // Clear queue, just go there
            animationQueue = [];
            cameraTargetPos.copy(node.mesh.position).add(new THREE.Vector3(0, 5, 15));
            controls.target.copy(node.mesh.position);
            isAnimatingCamera = true;
            activeNode = node;
            updateOutliner();
        }

        // Fast path tracing animation
        function focusOnNodeWithTrace(targetNode) {
            if (!activeNode) { focusOnNode(targetNode); return; }
            if (activeNode === targetNode) return;

            // Simple Path finding: Current -> LCA -> Target
            // 1. Get ancestors of current
            let currPath = [];
            let temp = activeNode;
            while(temp) { currPath.push(temp); temp = temp.parent; }
            
            // 2. Get ancestors of target
            let targPath = [];
            temp = targetNode;
            while(temp) { targPath.push(temp); temp = temp.parent; }

            // 3. Find LCA
            let lca = null;
            for(let n of currPath) {
                if(targPath.includes(n)) { lca = n; break; }
            }

            // 4. Build sequence
            animationQueue = [];
            // Up to LCA
            for(let i=0; i<currPath.length; i++) {
                if(currPath[i] === lca) break;
                animationQueue.push(currPath[i]); // Actually we want the parent, but let's visit nodes
            }
            if(lca) animationQueue.push(lca);
            // Down to Target (reverse part of targPath)
            let downPath = [];
            for(let i=0; i<targPath.length; i++) {
                if(targPath[i] === lca) break;
                downPath.push(targPath[i]);
            }
            downPath.reverse().forEach(n => animationQueue.push(n));
            
            // Remove current node from start if present
            if (animationQueue.length > 0 && animationQueue[0] === activeNode) animationQueue.shift();

            // Set final active
            activeNode = targetNode;
            updateOutliner();
            
            // Start animation
            if (animationQueue.length > 0) {
                isAnimatingCamera = true;
                playSound('whoosh');
            } else {
                focusOnNode(targetNode);
            }
        }

        function updateCamera() {
            if (isAnimatingCamera) {
                let targetLoc;
                
                // If we have a queue, our target is the first item in queue
                if (animationQueue.length > 0) {
                    const nextNode = animationQueue[0];
                    // Target position is offset from node
                    const offset = new THREE.Vector3(0, 5, 15);
                    targetLoc = nextNode.mesh.position.clone().add(offset);
                    
                    // Look at node
                    controls.target.lerp(nextNode.mesh.position, 0.1);
                    
                    // Move camera fast
                    camera.position.lerp(targetLoc, 0.15);

                    // Check if close enough to switch to next waypoint
                    if (camera.position.distanceTo(targetLoc) < 8) {
                        animationQueue.shift();
                    }
                } else {
                    // Final approach to activeNode
                    if (!activeNode) return;
                    targetLoc = activeNode.mesh.position.clone().add(new THREE.Vector3(0, 5, 15));
                    controls.target.lerp(activeNode.mesh.position, 0.1);
                    camera.position.lerp(targetLoc, 0.1);
                    
                    if (camera.position.distanceTo(targetLoc) < 0.1) {
                        isAnimatingCamera = false;
                    }
                }
            }
        }

        // --- Config ---
        let springLength = 8;
        const configPanel = document.getElementById('config-panel');
        function toggleConfig() {
            const disp = configPanel.style.display;
            configPanel.style.display = (disp === 'block') ? 'none' : 'block';
            if(configPanel.style.display === 'block') playSound('click');
        }
        function updateSpringLength(val) { springLength = parseFloat(val); }
        function resetCameraToRoot() { if(nodes[0]) focusOnNodeWithTrace(nodes[0]); }
        
        function saveStructure() {
            localStorage.setItem('mindmap_v2_data', JSON.stringify({
                nodes: nodes.map(n => ({ id: n.id, text: n.text, parentId: n.parent ? n.parent.id : null, pos: n.mesh.position })),
                springLength: springLength
            }));
            alert('‰øùÂ≠ò„Åó„Åæ„Åó„Åü'); playSound('add');
        }
        function loadStructure() {
            const json = localStorage.getItem('mindmap_v2_data');
            if(!json) return alert('„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
            const data = JSON.parse(json);
            
            nodes.forEach(n => scene.remove(n.mesh));
            connections.forEach(c => scene.remove(c.line));
            nodes = []; connections = []; nextId = 1; activeNode = null;

            const map = {};
            data.nodes.forEach(d => {
                map[d.id] = { ...d, real: null };
                nextId = Math.max(nextId, d.id + 1);
            });

            data.nodes.sort((a,b) => a.id - b.id).forEach(d => {
                const p = d.parentId ? map[d.parentId].real : null;
                const n = createNode(d.text, p, new THREE.Vector3(d.pos.x, d.pos.y, d.pos.z));
                n.id = d.id;
                map[d.id].real = n;
            });
            if(data.springLength) { springLength = data.springLength; document.getElementById('dist-slider').value = springLength; }
            alert('Âæ©ÂÖÉ„Åó„Åæ„Åó„Åü'); playSound('add'); toggleConfig();
        }

        // --- Context Menu & Logic ---
        const menu = document.getElementById('context-menu');
        const modal = document.getElementById('input-modal');
        const nameInput = document.getElementById('node-name-input');

        function showContextMenu(x, y, node) {
            document.getElementById('menu-title').innerText = node.text;
            menu.style.left = Math.min(x, window.innerWidth - 210) + 'px';
            menu.style.top = Math.min(y, window.innerHeight - 210) + 'px';
            menu.style.display = 'block';
        }
        function handleMenu(action) {
            if(!selectedNode) return;
            menu.style.display = 'none';
            if(action === 'rename') { nameInput.value = selectedNode.text; modal.style.display = 'flex'; }
            else if(action === 'add') createNode('New Node', selectedNode);
            else if(action === 'url') { playSound('whoosh'); window.open(selectedNode.url, '_blank'); }
            else playSound('cancel');
        }
        function closeModal() { modal.style.display = 'none'; playSound('cancel'); }
        function confirmRename() {
            if(selectedNode && nameInput.value) {
                selectedNode.text = nameInput.value;
                selectedNode.url = 'https://www.google.com/search?q='+encodeURIComponent(nameInput.value);
                selectedNode.mesh.material.map = createNodeTexture(selectedNode.text);
                updateOutliner(); playSound('click');
            }
            modal.style.display = 'none';
        }

        // --- Physics ---
        const REPULSION = 80, ATTRACTION = 0.01, DAMPING = 0.9;
        function updateLayout() {
            nodes.forEach(n => {
                n.force.set(0,0,0);
                if(n.id === 1) n.force.sub(n.mesh.position).multiplyScalar(0.05); // Root center
            });
            
            // Repulsion
            for(let i=0; i<nodes.length; i++) {
                for(let j=i+1; j<nodes.length; j++) {
                    const d = new THREE.Vector3().subVectors(nodes[i].mesh.position, nodes[j].mesh.position);
                    let dist = d.length(); if(dist===0) dist=0.01;
                    d.normalize().multiplyScalar(REPULSION / (dist*dist));
                    nodes[i].force.add(d); nodes[j].force.sub(d);
                }
            }
            
            // Attraction
            connections.forEach(c => {
                const d = new THREE.Vector3().subVectors(c.to.mesh.position, c.from.mesh.position);
                const len = d.length();
                d.normalize().multiplyScalar((len - springLength) * ATTRACTION);
                c.to.force.sub(d); c.from.force.add(d);
            });

            // Integrate
            nodes.forEach(n => {
                if(n.id !== 1) {
                    n.velocity.add(n.force).multiplyScalar(DAMPING);
                    n.mesh.position.add(n.velocity);
                }
                n.mesh.quaternion.copy(camera.quaternion); // Billboard
            });

            connections.forEach(c => {
                const p = c.line.geometry.attributes.position.array;
                p[0]=c.from.mesh.position.x; p[1]=c.from.mesh.position.y; p[2]=c.from.mesh.position.z;
                p[3]=c.to.mesh.position.x; p[4]=c.to.mesh.position.y; p[5]=c.to.mesh.position.z;
                c.line.geometry.attributes.position.needsUpdate = true;
            });
        }

        // --- Loop ---
        const root = createNode("ROOT");
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateLayout();
            updateCamera();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();

    </script>
</body>
</html>