<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Kanji Fishing - 漢字深海釣り</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Hiragino Mincho ProN', 'Yu Mincho', serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #depth-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-family: monospace;
            font-size: 24px;
            text-align: right;
            pointer-events: none;
        }
        #message-area {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }
        .msg-box {
            display: inline-block;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.3);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* 結果画面 */
        #result-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 10, 30, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            z-index: 100;
        }
        .fish-card {
            background: #f0f0f0;
            color: #222;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            width: 85%;
            max-width: 380px;
            box-shadow: 0 0 40px rgba(0, 191, 255, 0.2);
            position: relative;
            border: 4px solid #0277bd;
        }
        .fish-kanji {
            font-size: 100px;
            line-height: 1.1;
            margin: 10px 0;
            color: #004d40;
            font-family: 'HiraMinProN-W6', 'YuMincho', serif;
        }
        .fish-reading { font-size: 22px; font-weight: bold; margin-bottom: 5px; }
        .fish-en { font-size: 18px; color: #e65100; font-style: italic; font-family: sans-serif; margin-bottom: 15px;}
        .fish-desc {
            font-size: 14px; color: #444; text-align: left; background: #e0f7fa;
            padding: 12px; border-radius: 6px; line-height: 1.6;
        }
        .btn-close {
            margin-top: 20px; padding: 12px 50px;
            background: #0277bd; color: white; border: none;
            border-radius: 25px; font-size: 18px; font-weight: bold;
            cursor: pointer;
        }
        .badge-rare {
            position: absolute; top: -15px; right: -15px;
            background: #ffd700; color: #000; padding: 5px 15px;
            border-radius: 20px; font-weight: bold; transform: rotate(15deg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .tutorial {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-size: 14px; line-height: 1.5;
        }
        /* 生息域ラベル */
        .zone-label {
            position: absolute; top: 50%; 
            transform: translateY(-50%);
            font-size: 60px; font-weight: bold; 
            color: rgba(255,255,255,0.03);
            pointer-events: none;
            writing-mode: vertical-rl;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="depth-meter">0.0 m</div>
    <div id="message-area"><div class="msg-box" id="msg-text">TAP WATER TO CAST</div></div>
    
    <div class="zone-label" style="left: 20px;">RIVER (淡水)</div>
    <div class="zone-label" style="right: 20px;">OCEAN (海水)</div>

    <div class="tutorial">
        Tap Any Location: Cast Line There<br>
        好きな場所をタップして糸を垂らす
    </div>
</div>

<div id="result-modal">
    <div class="fish-card">
        <div id="badge" class="badge-rare">RARE</div>
        <div style="font-size:12px; color:#666; letter-spacing:1px; margin-bottom:5px;">FISHING LOG</div>
        <div id="res-kanji" class="fish-kanji">魚</div>
        <div id="res-reading" class="fish-reading">さかな</div>
        <div id="res-en" class="fish-en">Fish</div>
        <div id="res-desc" class="fish-desc">解説</div>
        <button class="btn-close" onclick="closeModal()">OK</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * 魚漢字データベース (内蔵版)
 * 一般的な魚から、JIS第2-4水準の難読漢字まで約350種以上を定義
 */
const FISH_DICT = {
    // === Level 1: Surface (Common) ===
    '魚': {y:'sakana', e:'Fish', d:'全ての魚の基本となる字。'},
    '鮮': {y:'azayaka', e:'Fresh', d:'魚が新しいこと。「新鮮」の鮮。'},
    '鮎': {y:'あゆ', e:'Sweetfish', d:'清流の女王。独特の香りがあるため香魚とも。', t:'fresh'},
    '鯉': {y:'こい', e:'Carp', d:'滝を登って龍になるという伝説がある。', t:'fresh'},
    '鮒': {y:'ふな', e:'Crucian Carp', d:'「釣りはフナに始まりフナに終わる」。', t:'fresh'},
    '鱒': {y:'ます', e:'Trout', d:'サケ科の魚。渓流釣りの人気ターゲット。', t:'fresh'},
    '鯛': {y:'たい', e:'Sea Bream', d:'「めでたい」魚の王様。', t:'salt'},
    '鰯': {y:'いわし', e:'Sardine', d:'陸に揚げるとすぐ弱ることから「弱い魚」。', t:'salt'},
    '鯵': {y:'あじ', e:'Horse Mackerel', d:'味が良いからアジと言われる。', t:'salt'},
    '鯖': {y:'さば', e:'Mackerel', d:'「鯖を読む」の語源。数が多くて数えるのが面倒だった。', t:'salt'},
    '鮭': {y:'さけ', e:'Salmon', d:'川で生まれ海で育ち、川へ戻る。', t:'fresh'}, // 回遊
    '鮪': {y:'まぐろ', e:'Tuna', d:'泳ぎ続けないと死んでしまう回遊魚。', t:'salt'},
    '鮫': {y:'さめ', e:'Shark', d:'交尾をする魚であることから「交」の字がついた説あり。', t:'salt'},
    '鯨': {y:'くじら', e:'Whale', d:'哺乳類だが、かつては最大の魚とされていた。', t:'salt'},
    '鰻': {y:'うなぎ', e:'Eel', d:'「一日、四回、糸を垂れる」と書いて鰻(諸説あり)。', t:'fresh'},
    '鯰': {y:'なまず', e:'Catfish', d:'念じて粘る魚。地震予知の伝説がある。', t:'fresh'},
    
    // === Level 2: Mid-Depth (Uncommon) ===
    '鮃': {y:'ひらめ', e:'Flounder', d:'「平」たい魚。左ヒラメに右カレイ。', t:'salt'},
    '鰈': {y:'かれい', e:'Flatfish', d:'「葉」のように薄い魚。', t:'salt'},
    '鰹': {y:'かつお', e:'Bonito', d:'身が堅いことから「堅魚(かたうお)」。', t:'salt'},
    '鱈': {y:'たら', e:'Cod', d:'雪の降る季節に美味しくなる。', t:'salt'},
    '鰤': {y:'ぶり', e:'Yellowtail', d:'師走(12月)に美味しくなる。出世魚。', t:'salt'},
    '鮟': {y:'あんこう', e:'Monkfish', d:'海底で安らかにしている魚？肝が絶品。', t:'salt'},
    '鱚': {y:'きす', e:'Sillago', d:'「喜」ぶ魚。天ぷらの定番。', t:'salt'},
    '鱸': {y:'すずき', e:'Sea Bass', d:'エラが黒いことから。出世魚。', t:'salt'},
    '鮑': {y:'あわび', e:'Abalone', d:'魚偏だが巻貝の仲間。磯の宝石。', t:'salt'},
    '蛸': {y:'たこ', e:'Octopus', d:'海に住むクモ(海蜘蛛)の意味も。', t:'salt'},
    '鰆': {y:'さわら', e:'Spanish Mackerel', d:'春を告げる魚。', t:'salt'},
    '鰍': {y:'かじか', e:'Sculpin', d:'秋に美味しい川魚。', t:'fresh'},
    '鮠': {y:'はや', e:'Dace', d:'動きが速い小魚。', t:'fresh'},
    '鰒': {y:'ふぐ', e:'Pufferfish', d:'腹が膨れる魚。毒がある。', t:'salt'},
    '鮗': {y:'このしろ', e:'Gizzard Shad', d:'冬に美味しい。コハダの成魚。', t:'salt'},
    '鯑': {y:'かずのこ', e:'Herring Roe', d:'ニシンの卵。「カドの子」が訛った。', t:'salt'},
    '鯒': {y:'こち', e:'Flathead', d:'平たい魚。夏が旬。', t:'salt'},
    '鯣': {y:'するめ', e:'Dried Squid', d:'イカを干したもの。縁起物。', t:'salt'},
    '鯱': {y:'しゃち', e:'Orca', d:'魚偏に虎。海の王者。', t:'salt'},
    '鰊': {y:'にしん', e:'Herring', d:'東の魚？春告魚とも呼ばれる。', t:'salt'},
    '鰰': {y:'はたはた', e:'Sandfish', d:'雷(神なり)の季節に獲れる。', t:'salt'},

    // === Level 3: Deep Sea (Rare/Hard) ===
    '鱇': {y:'こう', e:'Deep Sea Fish', d:'鮟鱇（あんこう）の「こう」。', t:'salt'},
    '鰳': {y:'ひら', e:'Ilisha', d:'骨が多い魚。', t:'salt'},
    '鮴': {y:'ごり / めばる', e:'Gori / Rockfish', d:'岩の下で「休」む魚。', t:'fresh'},
    '鯔': {y:'ぼら', e:'Mullet', d:'イナ→ボラ→トド。「とどのつまり」の語源。', t:'salt'},
    '鱵': {y:'さより', e:'Halfbeak', d:'細長い魚。腹黒い(内臓が黒い)ことで有名。', t:'salt'},
    '鱧': {y:'はも', e:'Pike Conger', d:'「豊」かな生命力。京都の夏に欠かせない。', t:'salt'},
    '鰪': {y:'いわし', e:'Sardine (Old)', d:'イワシの異体字の一つ。', t:'salt'},
    '鰮': {y:'いわし', e:'Sardine (Alt)', d:'イワシの別表記。', t:'salt'},
    '鱠': {y:'なます', e:'Namasu', d:'魚と野菜を酢で和えた料理。', t:'fresh'},
    '鱶': {y:'ふか', e:'Large Shark', d:'大型のサメ。フカヒレの原料。', t:'salt'},
    '鰐': {y:'わに', e:'Crocodile / Shark', d:'古事記ではサメ(因幡の白兎)を指した。', t:'salt'},
    '鰣': {y:'はす', e:'Hasu', d:'コイ科の魚。季節(時)に関係？', t:'fresh'},
    '鮖': {y:'かじか', e:'Sculpin', d:'石に張り付く魚。', t:'fresh'},
    '鮇': {y:'いわな', e:'Char', d:'「未」だ幻の魚？イワナの別表記。', t:'fresh'},
    '鮬': {y:'ごり', e:'Gori', d:'幼魚、またはゴリ。', t:'fresh'},
    '鱩': {y:'はたはた', e:'Sandfish', d:'雷魚とも書く。', t:'salt'},
    '鰄': {y:'かいらぎ', e:'Plum Skin', d:'サメの皮。刀の柄に使われた。', t:'salt'},
    '鱆': {y:'たこ', e:'Octopus', d:'タコの別表記。', t:'salt'},
    '鰩': {y:'えい', e:'Ray', d:'海中を揺らめくように泳ぐ。', t:'salt'},
    '鱪': {y:'しいら', e:'Mahi-mahi', d:'ハワイの高級魚マヒマヒ。暑い夏に獲れる。', t:'salt'},
    '鱫': {y:'むつ', e:'Gnomefish', d:'脂っこいことを「むつこい」と言うことから。', t:'salt'},
    '鱰': {y:'しいら', e:'Dolphin Fish', d:'シイラの別表記。', t:'salt'},
    
    // === Level 4: Abyss (Legendary/Obscure) ===
    '鱻': {y:'せん', e:'Fresh (Ancient)', d:'魚が3匹で新鮮さを表す古代文字。', t:'salt'},
    '鱺': {y:'ながすじ', e:'Eel-like', d:'長い魚を表す字。', t:'salt'},
    '䲘': {y:'Unknown', e:'Ancient Fish', d:'詳細不明の古代魚。', t:'salt'},
    '𩶘': {y:'たなご', e:'Bitterling', d:'タナゴの一種を表す異体字。', t:'fresh'},
    '𩸽': {y:'ほっけ', e:'Okhotsk Atka Mackerel', d:'「北」の海で獲れる「花」のような魚。国字。', t:'salt'},
    '鰾': {y:'うきぶくろ', e:'Swim Bladder', d:'魚が浮力を調整する袋。', t:'salt'},
    '鱮': {y:'たなご', e:'Bitterling', d:'「与」える魚？婚姻色が美しい。', t:'fresh'},
    '鯳': {y:'すけとうだら', e:'Alaska Pollock', d:'「底」に住むタラ。カマボコの原料。', t:'salt'},
    '鮟鱇': {y:'あんこう', e:'Monkfish', d:'提灯で獲物を誘う深海魚。', t:'salt'}, // 2文字
    '竜の落とし子': {y:'たつのおとしご', e:'Seahorse', d:'魚には見えないが魚の仲間。', t:'salt'},
    '翻車魚': {y:'まんぼう', e:'Sunfish', d:'海に浮かぶ円盤。', t:'salt'}
};

// 辞書にない漢字が来た場合のフォールバック生成
function getFishData(kanji, type) {
    if (FISH_DICT[kanji]) {
        return FISH_DICT[kanji];
    }
    // 未定義のレア漢字用
    return {
        y: '？？？',
        e: 'Mysterious Deep Species',
        d: `深海で発見された未確認の魚種。「${kanji}」という漢字の読みは謎に包まれている...`,
        t: type
    };
}

// ユーザー入力の大量リスト（一部抜粋して利用、またはレア抽選用プールとして保持）
const RARE_KANJI_POOL = `
鯉 鯽 鯛 鯔 鯖 鯵 鯰 鯑 鯒 鯣 鯆 鯊 鯋 鯏 鯐 鯒 鯓 鯔 鯕 鯖 鯙 鯚 鯜 鯝 鯞 鯟 鯠 鯡 鯢 鯤 鯥 鯦 鯧 鯨 鯩 鯪 鯫 鯬 
鯭 鯮 鯯 鯰 鯱 鯲 鯳 鯴 鯵 鯶 鯷 鯸 鯹 鯺 鯻 鯼 鯽 鯾 鯿 鰀 鰁 鰂 鰃 鰄 鰅 鰆 鰇 鰈 鰉 鰊 鰋 鰌 鰍 鰎 鰏 鰐 鰑 鰒 
鰓 鰔 鰕 鰖 鰗 鰘 鰙 鰚 鰛 鰜 鰝 鰞 鰟 鰠 鰡 鰢 鰣 鰤 鰥 鰦 鰧 鰨 鰩 鰪 鰫 鰬 鰭 鰮 鰯 鰰 鰱 鰲 鰳 鰴 鰵 鰶 鰷 鰸 
鰹 鰺 鰻 鰼 鰽 鰾 鰿 鱀 鱁 鱂 鱃 鱄 鱅 鱆 鱇 鱈 鱉 鱊 鱋 鱌 鱍 鱎 鱏 鱐 鱑 鱒 鱓 鱔 鱕 鱖 鱗 鱘 鱙 鱚 鱛 鱜 鱝 鱞 
鱟 鱠 鱡 鱢 鱣 鱤 鱥 鱦 鱧 鱨 鱩 鱪 鱫 鱬 鱭 鱮 鱯 鱰 鱱 鱲 鱳 鱴 鱵 鱶 鱷 鱸 鱹 鱺 蝦 鰕 鰖 鰰 鰚 鰠 鰡 鰢 鰩  
蟹 鱟 鰞 鱆 鱇 鰂 鰌 鱊 鰒 鱁 鱉 鰐 鯨 鯢 鯱 鰐 鱷 鱓 鱦 鱣 鱥 鮏 鯐 鰌 鱀 鱻 鮮 鯨 鮪 鰯 鮭 鰐 
鰭 鰹 鮫 鰍 鯖 鱈 鰺 鯵 鱒 鯛 鮎 鰻 鮒 鯉 鱗 魯 魴 鮃 鮓 鮑 鮗 鮖 鮟 鮨 鮠 鮴 鯀 鯊 鯒 鯑 鯏 鮹 鯣 鯢 鯤 鯲 鯡 
鯔 鯱 鯰 鰓 鰉 鰔 鰕 鰌 鰈 鰆 鰒 鰊 鰄 鰮 鰛 鰥 鰤 鰰 鱆 鱇 鰾 鱚 鱠 鱧 鱶 鱸 魞 魳 魸 魬 鮇 鮱 鮲 鯎 鯐 鮸 鰙 鰚 
鰘 鰧 鱛 鱏 鱓 鱟 鱩 鱲 𬵪 𩶗 鰡 鰲 鯆 鱉 䰲 魛 魟 䰵 魡 魪 䰻 魥 魭 魧 魦 魣 魫 魶 魹 魨 䰽 魮 魵 䰷 魷 䱀 魼 鮔 
`.replace(/\s+/g, '').split('');

// --- Audio System ---
const AudioSys = {
    ctx: null,
    gain: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.gain = this.ctx.createGain();
            this.gain.gain.value = 0.3;
            this.gain.connect(this.ctx.destination);
        }
        if(this.ctx.state === 'suspended') this.ctx.resume();
    },
    play: function(freq, type, dur, slide=null) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) o.frequency.exponentialRampToValueAtTime(slide, this.ctx.currentTime+dur);
        g.gain.setValueAtTime(0.5, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+dur);
        o.connect(g); g.connect(this.gain);
        o.start(); o.stop(this.ctx.currentTime+dur);
    },
    cast: () => AudioSys.play(600, 'sine', 0.5, 200),
    bite: () => { AudioSys.play(800, 'square', 0.1); setTimeout(()=>AudioSys.play(800,'square',0.1), 100); },
    reel: () => AudioSys.play(300, 'triangle', 0.05),
    catch: () => [0,100,200,400].forEach((t,i)=>setTimeout(()=>AudioSys.play(440*[1,1.25,1.5,2][i], 'square', 0.3), t))
};

// --- Game Engine ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// Game State
let state = 'IDLE'; // IDLE, CASTING, HOLDING, BITE, REELING, CAUGHT
let hook = { x: 0, y: 0, depth: 0, speed: 0 };
let fishes = [];
let particles = [];
let cameraY = 0;
let score = 0;
let targetFish = null;
let fightProgress = 0;

// Config
const CAST_SPEED = 10;
const MAX_DEPTH = 3000; // 3000m equivalent

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    hook.x = width / 2; // Default to center on resize
}
window.addEventListener('resize', resize);
resize();

class Fish {
    constructor() {
        // 初期配置は画面全体に散らす（開始時の見栄えのため）
        // プレイ中のリセットは reset() で画面外に配置
        this.reset(true); 
    }
    
    // isInit: ゲーム開始時の生成ならtrue
    reset(isInit = false) {
        // 深さに応じてランク分け
        this.depth = Math.random() * MAX_DEPTH;
        
        // 生息域：左=淡水, 右=海水
        this.type = Math.random() < 0.5 ? 'fresh' : 'salt';
        
        // 文字決定
        if (Math.random() < 0.3) {
            const keys = Object.keys(FISH_DICT).filter(k => {
                const d = FISH_DICT[k];
                if (d.t && d.t !== this.type) return false;
                return true;
            });
            this.char = keys[Math.floor(Math.random() * keys.length)];
        } else {
            this.char = RARE_KANJI_POOL[Math.floor(Math.random() * RARE_KANJI_POOL.length)];
        }

        this.size = 30 + Math.random() * 50;
        
        // Y座標の決定（Popping防止）
        if (isInit) {
            this.y = this.depth; // 最初はランダムでOK
        } else {
            // プレイ中のリセット：必ず画面外（下）から生成
            // カメラより少し下、またはずっと下
            this.y = cameraY + height + 100 + Math.random() * 500;
        }

        // X座標と移動範囲
        const border = width / 2;
        if (this.type === 'fresh') {
            // 左側エリア
            this.minX = 0; 
            this.maxX = border;
            this.x = Math.random() * (border - 50);
        } else {
            // 右側エリア
            this.minX = border; 
            this.maxX = width;
            this.x = border + Math.random() * (width/2 - 50);
        }
        
        this.vx = (Math.random() * 2 + 0.5) * (Math.random()<0.5 ? 1 : -1);
        this.state = 'SWIM';
    }

    update() {
        if (this.state === 'SWIM') {
            this.x += this.vx;
            // 境界で反転
            if (this.x < this.minX + 20 || this.x > this.maxX - 20) {
                this.vx *= -1;
            }
            
            // 画面外リセットロジック（Popping防止）
            // 画面の上端よりはるか上、または下端よりはるか下に行った場合のみリセット
            const screenY = this.y - cameraY;
            
            // カメラが下がっている（キャスト中）: 上に消えた魚を下へ
            // カメラが上がっている（リール中）: 下に消えた魚を上へ（今回はシンプルに全部下へ回す）
            if (screenY < -200 || screenY > height + 200) {
                // 画面外に出たのでリセット
                this.reset();
            }

            // フックとの判定 (hook.x を使う)
            if (state === 'HOLDING' && Math.abs(this.y - hook.y) < 30 && Math.abs(this.x - hook.x) < 30) {
                if (Math.random() < 0.05) { 
                    startBite(this);
                }
            }
        } else if (this.state === 'HOOKED') {
            // 釣られている時はフックの位置に同期
            this.x = hook.x + (Math.random()-0.5)*10;
            this.y = hook.y + 20;
        }
    }

    draw() {
        const screenY = this.y - cameraY;
        // 画面内のみ描画
        if (screenY < -50 || screenY > height + 50) return;

        ctx.save();
        ctx.translate(this.x, screenY);
        
        // 色設定
        ctx.fillStyle = this.type === 'fresh' ? '#b2dfdb' : '#e1f5fe';
        if (FISH_DICT[this.char] === undefined) ctx.fillStyle = '#ffeb3b'; 
        
        ctx.font = `bold ${this.size}px serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        
        // 【修正】反転処理（scale）を削除し、常に文字が読めるようにする
        // 泳ぐ方向に関わらず文字は正位置
        ctx.fillText(this.char, 0, 0);
        ctx.restore();
    }
}

// パーティクル（泡）
function spawnParticles(x, y, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*4, vy: -Math.random()*4,
            life: 1.0
        });
    }
}

// ------------------------------------
// Input Handling
// ------------------------------------
function handleInput(e) {
    // UI上のタップなら無視（閉じるボタンなど）はHTML側で制御されるが念のため
    if (e.target.tagName === 'BUTTON') return;
    e.preventDefault();

    AudioSys.init();
    
    // タップ位置の取得（X座標用）
    let clientX;
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
    } else {
        clientX = e.clientX;
    }
    
    if (state === 'IDLE') {
        // 【修正】タップした位置にフックのX座標を設定
        hook.x = clientX;
        
        // 画面外にはみ出さないように補正
        if (hook.x < 20) hook.x = 20;
        if (hook.x > width - 20) hook.x = width - 20;

        // キャスト開始
        state = 'CASTING';
        hook.depth = 0;
        hook.y = 0;
        hook.speed = CAST_SPEED;
        setMessage("TAP TO STOP");
        AudioSys.cast();
    } else if (state === 'CASTING') {
        // 停止して待つ
        state = 'HOLDING';
        hook.speed = 0;
        setMessage("WAITING...");
    } else if (state === 'BITE') {
        // 合わせる
        state = 'REELING';
        fightProgress = 0;
        AudioSys.reel();
        setMessage("REEL IT IN! (TAP!)");
    } else if (state === 'REELING') {
        // リールを巻く（連打）
        fightProgress += 10;
        hook.y -= 40; // 巻き上げ速度
        spawnParticles(hook.x, hook.y - cameraY, 2);
        AudioSys.reel();
        if (hook.y <= 0) {
            catchFish();
        }
    }
}

function startBite(fish) {
    state = 'BITE';
    targetFish = fish;
    fish.state = 'HOOKED';
    AudioSys.bite();
    setMessage("!!! TAP !!!");
    setTimeout(() => {
        if (state === 'BITE') {
            state = 'IDLE';
            fish.state = 'SWIM';
            fish.vx *= 3; 
            setMessage("ESCAPED...");
            setTimeout(() => { if(state==='IDLE') hook.y = 0; setMessage("TAP TO CAST"); }, 1500);
        }
    }, 1000);
}

function catchFish() {
    state = 'CAUGHT';
    AudioSys.catch();
    
    const f = targetFish;
    const data = getFishData(f.char, f.type);
    
    const modal = document.getElementById('result-modal');
    document.getElementById('res-kanji').innerText = f.char;
    document.getElementById('res-reading').innerText = data.y;
    document.getElementById('res-en').innerText = data.e;
    document.getElementById('res-desc').innerText = data.d;
    
    const badge = document.getElementById('badge');
    if (!FISH_DICT[f.char]) {
        badge.innerText = "LEGENDARY";
        badge.style.background = "#ff5722";
    } else {
        badge.innerText = "CATCH";
        badge.style.background = "#ffd700";
    }

    modal.style.display = 'flex';
}

window.closeModal = function() {
    document.getElementById('result-modal').style.display = 'none';
    if(targetFish) targetFish.reset();
    state = 'IDLE';
    hook.y = 0;
    cameraY = 0;
    // フックX座標は維持するか、リセットするか。今回は維持（次も同じ場所を狙いやすく）
    setMessage("TAP TO CAST");
}

function setMessage(msg) {
    document.getElementById('msg-text').innerText = msg;
}

// ------------------------------------
// Main Loop
// ------------------------------------
for(let i=0; i<30; i++) fishes.push(new Fish());

function draw() {
    // Logic
    if (state === 'CASTING') {
        hook.y += hook.speed;
        if (hook.y >= MAX_DEPTH) {
            state = 'HOLDING';
            setMessage("MAX DEPTH");
        }
    } else if (state === 'REELING') {
        hook.y += 2; // Gravity resistance
    }

    // Camera follow hook
    let targetCamY = hook.y - height * 0.4;
    if (targetCamY < 0) targetCamY = 0;
    cameraY += (targetCamY - cameraY) * 0.1;

    // UI Updates
    document.getElementById('depth-meter').innerText = (hook.y / 10).toFixed(1) + " m";

    // Draw Background
    let depthRatio = Math.min(cameraY / MAX_DEPTH, 1);
    let r = Math.floor(0 * (1-depthRatio));
    let g = Math.floor(100 * (1-depthRatio)); 
    let b = Math.floor(200 * (1-depthRatio) + 50); 
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, 0, width, height);

    // 生息域の境界線
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.setLineDash([10, 20]);
    ctx.beginPath();
    ctx.moveTo(width/2, 0);
    ctx.lineTo(width/2, height);
    ctx.stroke();
    ctx.setLineDash([]);

    // 深度マーカー
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.font = '20px monospace';
    ctx.textAlign = 'center';
    // 画面に見えている範囲の深度線だけ描画
    const startD = Math.floor(cameraY / 500) * 500;
    for(let d=startD; d<startD + height + 500; d+=500) {
        let sy = d - cameraY;
        ctx.fillText(`- ${d/10}m -`, width/2, sy);
    }

    // 魚
    fishes.forEach(f => {
        f.update();
        f.draw();
    });

    // 釣り糸 (hook.x を使用)
    let screenHookY = hook.y - cameraY;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    // 画面上端（空）からずっと伸びているように見せる
    ctx.moveTo(hook.x, -100); 
    ctx.lineTo(hook.x, screenHookY);
    ctx.stroke();

    // 釣り針
    ctx.fillStyle = state === 'BITE' ? 'red' : 'silver';
    ctx.beginPath();
    ctx.arc(hook.x, screenHookY, 6, 0, Math.PI*2);
    ctx.fill();
    
    // パーティクル
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.y += p.vy;
        p.x += p.vx;
        p.life -= 0.05;
        if (p.life <= 0) particles.splice(i,1);
        else {
            let sy = p.y - cameraY;
            ctx.fillStyle = `rgba(255,255,255,${p.life})`;
            ctx.beginPath(); ctx.arc(p.x, sy, 3, 0, Math.PI*2); ctx.fill();
        }
    }

    requestAnimationFrame(draw);
}

// Event Listeners
canvas.addEventListener('mousedown', handleInput);
canvas.addEventListener('touchstart', handleInput, {passive:false});

requestAnimationFrame(draw);
</script>
</body>
</html>