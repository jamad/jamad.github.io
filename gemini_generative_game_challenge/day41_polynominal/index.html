<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taylor Shift "Dancing with Maclaurin"</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --accent: #00bcd4; /* 近似線の色 */
            --target: #ff4081; /* 元関数の色 */
            --center: #ffd740; /* 中心点aの色 (新規追加) */
            --axis: #ffffff;
            --grid-major: #424242;
            --grid-minor: #2c2c2c;
            --text: #e0e0e0;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Courier New', 'Consolas', monospace; color: var(--text); touch-action: none; }

        /* ── TOP BAR ── */
       #top-bar {
           position: fixed; top: 0; left: 0; right: 0; height: 38px;
           background: rgba(10,10,10,0.97);
           border-bottom: 1px solid #2a2a2a;
           display: flex; align-items: center;
           padding: 0 16px; gap: 12px;
           z-index: 200;
           backdrop-filter: blur(8px);
       }
       #top-bar .title {
           font-size: 0.72rem; letter-spacing: 0.12em; color: var(--accent);
           text-transform: uppercase; white-space: nowrap;
       }
       #top-bar .sep { color: #444; font-size: 0.8rem; }
       #top-bar .sub { font-size: 0.65rem; color: #555; letter-spacing: 0.08em; text-transform: uppercase; }
       #top-bar .spacer { flex: 1; }
       #top-bar .lang-group { display: flex; gap: 4px; }
       .lang-btn {
           background: none; border: 1px solid #333; color: #666;
           font-family: inherit; font-size: 0.65rem; letter-spacing: 0.1em;
           padding: 2px 7px; border-radius: 3px; cursor: pointer; transition: all 0.15s;
       }
       .lang-btn:hover { border-color: #555; color: #aaa; }
       .lang-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,188,212,0.08); }

       /* ── SIDEBAR ── */
       #sidebar {
           position: fixed; top: 38px; right: 0; bottom: 42px;
           width: 190px;
           background: rgba(14,14,14,0.97);
           border-right: 1px solid #1e1e1e;
           display: flex; flex-direction: column;
           padding: 14px 14px 10px;
           box-sizing: border-box;
           gap: 0;
           z-index: 100;
           overflow-y: auto;
       }
       .sb-section {
           border-top: 1px solid #1e1e1e;
           padding: 12px 0 4px;
       }
       .sb-section:first-child { border-top: none; padding-top: 0; }
       .sb-label {
           font-size: 0.6rem; letter-spacing: 0.18em; text-transform: uppercase;
           color: #444; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;
       }
       .sb-value {
           font-size: 0.82rem; color: var(--accent); font-weight: bold; letter-spacing: 0.05em;
       }
       select {
           background: #0e0e0e; color: #ccc; border: 1px solid #2a2a2a;
           padding: 7px 8px; border-radius: 3px; font-size: 0.78rem;
           font-family: inherit; outline: none; width: 100%; box-sizing: border-box;
           letter-spacing: 0.04em; cursor: pointer;
       }
       select:focus { border-color: #333; }


       /* 関数リスト */
       #func-list { display: flex; flex-direction: column; gap: 2px; }
       .func-item {
           font-size: 0.72rem; padding: 5px 8px; border-radius: 2px; cursor: pointer;
           color: #555; border: 1px solid transparent; transition: all 0.12s;
           letter-spacing: 0.04em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
       }
       .func-item:hover { color: #aaa; border-color: #2a2a2a; }
       .func-item.selected { color: var(--accent); border-color: rgba(0,188,212,0.3); background: rgba(0,188,212,0.06); }

       input[type=range] {
           width: 100%; height: 3px; background: #222; border-radius: 2px;
           outline: none; -webkit-appearance: none; margin-top: 6px; cursor: pointer;
       }
       input[type=range]::-webkit-slider-thumb {
           -webkit-appearance: none; width: 14px; height: 14px;
           background: var(--accent); border-radius: 50%; cursor: pointer;
           border: 2px solid #0e0e0e; box-shadow: 0 0 6px rgba(0,188,212,0.5);
       }
       input[type="radio"] { display: none; }

       /* ── PLAY / DANCE BTN ── */
       .icon-btn {
           background: none; border: 1px solid #2a2a2a; color: #555;
           font-family: inherit; font-size: 0.6rem; letter-spacing: 0.1em;
           padding: 2px 6px; border-radius: 2px; cursor: pointer; transition: all 0.15s;
       }
       .icon-btn:hover { border-color: var(--accent); color: var(--accent); }
       .icon-btn.active { border-color: var(--target); color: var(--target); background: rgba(255,64,129,0.08); }

       /* ── LEGEND ── */
       .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; font-size: 0.68rem; color: #555; }
       .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
       .line-dashed { width: 16px; height: 0; border-top: 2px dashed var(--center); flex-shrink: 0; }

       /* ── FORMULA BAR ── */
        #formula-bar {
           position: fixed; bottom: 0; left: 0; right: 190px; height: 42px;
           background: rgba(0,0,0,0.97);
           border-top: 1px solid #1a1a1a;
           display: flex; align-items: center;
           padding: 0 16px;
           overflow-x: auto; white-space: nowrap;
           z-index: 100;
           scrollbar-width: thin; scrollbar-color: #222 #000;
       }
       #formula-bar::-webkit-scrollbar { height: 3px; }
       #formula-bar::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
       #formula-text {
           font-family: 'Times New Roman', Georgia, serif;
           font-size: 1rem; color: #ccc; letter-spacing: 0.5px;
       }
       /* ── CANVAS AREA ── */
       #graphCanvas {
           position: fixed;
           top: 38px; left: 0; right: 190px; bottom: 42px;
       }

       /* ── MOBILE FALLBACK ── */
       @media (max-width: 600px) {
           #sidebar { width: 100%; top: auto; bottom: 42px; height: 220px; border-left: none; border-top: 1px solid #1e1e1e; flex-direction: row; flex-wrap: wrap; overflow-x: auto; padding: 10px; gap: 10px; }
           #formula-bar { right: 0; }
           #graphCanvas { right: 0; bottom: calc(220px + 42px); }
           .sb-section { border-top: none; padding-top: 0; min-width: 130px; }
       }


    </style>
</head>
<body>

<!-- TOP BAR -->
<div id="top-bar">
   <span class="title">Taylor Shift</span>
   <span class="sep">//</span>
   <span class="sub">Dancing with Maclaurin</span>
   <div class="spacer"></div>
   <div class="lang-group">
       <button class="lang-btn" data-lang="en">EN</button>
       <button class="lang-btn active" data-lang="ja">JP</button>
       <button class="lang-btn" data-lang="fi">FI</button>
       <button class="lang-btn" data-lang="da">DA</button>
   </div>
</div>

<!-- SIDEBAR -->
<div id="sidebar">
   <div class="sb-section">
       <div class="sb-label"><span id="lbl-func">FUNCTION</span></div>
       <div id="func-list"></div>
   </div>

   <div class="sb-section">
       <div class="sb-label">
           <span id="lbl-center">CENTER (a)</span>
           <span class="sb-value" id="aVal">0</span>
       </div>
       <input type="range" id="aSlider" min="-3.2" max="3.2" value="0" step="0.1">
       <div style="margin-top:8px;">
           <button id="dance-btn" class="icon-btn">⟳ DANCE</button>
       </div>
   </div>

   <div class="sb-section">
       <div class="sb-label">
           <span id="lbl-terms">TERMS (n)</span>
           <span class="sb-value" id="nVal">1</span>
       </div>
       <input type="range" id="nSlider" min="0" max="64" value="1" step="1">
       <div style="margin-top:8px;">
           <button id="play-btn" class="icon-btn">▶ PLAY</button>
       </div>
   </div>

   <div class="sb-section">
       <div class="sb-label">
           <span id="lbl-zoom">ZOOM</span>
           <span class="sb-value" id="zoomVal">±5</span>
       </div>
       <input type="range" id="zoomSlider" min="2" max="32" value="6" step="0.5">
   </div>

   <div class="sb-section" style="margin-top:auto; padding-top:16px;">
       <div class="sb-label">LEGEND</div>
       <div class="legend-item"><div class="dot" style="background:var(--target)"></div><span id="legend-original">f(x)</span></div>
       <div class="legend-item"><div class="dot" style="background:var(--accent)"></div><span id="legend-approx">P(x)</span></div>
       <div class="legend-item"><div class="line-dashed"></div><span id="legend-center">center a</span></div>
   </div>
</div>

<!-- CANVAS -->
<canvas id="graphCanvas"></canvas>

<!-- FORMULA BAR -->
<div id="formula-bar">
   <span id="formula-text"></span>
</div>


<script>
/**
 * Localization (i18n) Data
 */
const translations = {
    ja: {
        lblFunc: "関数選択", lblTerms: "項数 (n)", lblZoom: "ズーム", lblCenter: "中心点 (a)", btnDance: "Dance!",
        legendOriginal: "元の関数 f(x)", legendApprox: "近似多項式 P(x)", legendCenter: "中心点 (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x (指数関数)",
            log: "ln(1+x) (対数)", inv: "1/(1-x) (幾何級数)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (二項展開)", gauss: "e^(-x²) (ガウス)", inv2: "1/(1+x²)"
        }
    },
    en: {
        lblFunc: "Function", lblTerms: "Terms (n)", lblZoom: "Zoom", lblCenter: "Center (a)", btnDance: "Dance!",
        legendOriginal: "Original f(x)", legendApprox: "Polynomial P(x)", legendCenter: "Center (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binomial)", gauss: "e^(-x²) (Gaussian)", inv2: "1/(1+x²)"
        }
    },
    fi: {
        lblFunc: "Funktio", lblTerms: "Termit (n)", lblZoom: "Zoomaus", lblCenter: "Keskipiste (a)", btnDance: "Dance!",
        legendOriginal: "f(x)", legendApprox: "P(x)", legendCenter: "Keskipiste (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binominen)", gauss: "e^(-x²) (Gaussinen)", inv2: "1/(1+x²)"
        }
    },
    da: {
        lblFunc: "Funktion", lblTerms: "Led (n)", lblZoom: "Zoom", lblCenter: "Centrum (a)", btnDance: "Dance!",
        legendOriginal: "f(x)", legendApprox: "P(x)", legendCenter: "Centrum (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binomisk)", gauss: "e^(-x²) (Gaussisk)", inv2: "1/(1+x²)"
        }
    }
};

let currentLang = 'ja';

/**
 * Math Logic & Formatting Helpers
 */
function factorial(n) {
    if (n <= 1) return 1;
    let r = 1;
    for (let i = 2; i <= n; i++) r *= i;
    return r;
}

function binom(n, k) {
    if (k < 0 || k > n) return 0;
    if (k === 0 || k === n) return 1;
    let r = 1;
    for (let i = 0; i < k; i++) r = r * (n - i) / (i + 1);
    return Math.round(r);
}

function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); };

// 数式文字列生成ヘルパー
// symbolStr: "sin(a)" などの記号文字列。nullの場合は数値計算値を使用。
// forceSign: 記号表示時の強制符号 (+1 または -1)。nullなら自動。
function buildTermHtml(n, xVal, a, derivVal, useFactorial = true, symbolStr = null, forceSign = null) {
    // 係数がほぼ0で、かつ記号指定がない場合はスキップ
    if (!symbolStr && Math.abs(derivVal) < 0.0001) return { val: 0, text: "" };

    const isMaclaurin = Math.abs(a) < 0.001;
    let absDeriv = Math.abs(derivVal);

    // --- 1. 変数部分 (x-a)^n ---
    let xPart = "";
    if (n === 0) {
        xPart = ""; 
    } else if (n === 1) {
        xPart = isMaclaurin ? "x" : "(x - a)";
    } else {
        xPart = isMaclaurin ? `x<sup>${n}</sup>` : `(x - a)<sup>${n}</sup>`;
    }

    // --- 2. 表示テキスト生成 ---
    let text = "";

    if (isMaclaurin) {
        // --- マクローリン (a=0) ---
        // 従来通り数値(分数)できれいに表示
        let sign = derivVal >= 0 ? " + " : " - ";
        let showNum = Math.abs(absDeriv - 1) > 0.001;
        let numStr = showNum ? parseFloat(absDeriv.toFixed(4)) : "";
        let top = (numStr + xPart) || "1"; 
        
        if (n === 0) {
            text = sign + (numStr || "1");
        } else if (useFactorial && n > 1) {
            text = `${sign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
        } else {
            text = sign + top;
        }

    } else {
        // --- テイラー (a!=0) ---
        // 記号 (sin(a)など) があればそれを使う
        
        let displaySign = " + ";
        let content = "";
        
        if (symbolStr) {
            // 記号モード (例: sin(a), e^a)
            // forceSignがあればそれに従う (例: -sin(a) の項)
            if (forceSign !== null) {
                displaySign = forceSign >= 0 ? " + " : " - ";
            }
            content = `<span style="font-style:italic; font-family:Times New Roman;">${symbolStr}</span>`;
            
            // 係数部分の構築
            if (n === 0) {
                text = displaySign + content;
            } else {
                // 分子: Symbol(x-a)^n
                let top = content + xPart;
                if (useFactorial && n > 1) {
                    text = `${displaySign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
                } else {
                    text = displaySign + top;
                }
            }
            
        } else {
            // 記号がない場合 (数値フォールバック) - マジックナンバーを避けるため丸める
            // または log/inv のような代数的構造を表示
            let sign = derivVal >= 0 ? " + " : " - ";
            let valStr = parseFloat(absDeriv.toFixed(2));
            let top = valStr + xPart;

            if (n === 0) {
                text = sign + valStr;
            } else if (useFactorial && n > 1) {
                text = `${sign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
            } else {
                text = sign + top;
            }
        }
    }

    // --- 3. 実際の計算値 (グラフ描画用) ---
    let coeff = derivVal;
    if (useFactorial) coeff = derivVal / factorial(n);
    let val = coeff * Math.pow(xVal - a, n);

    return { val, text };
}


// --- Polynomial helpers (グローバルスコープ) ---
function pAdd(p, q) {
   const r = new Array(Math.max(p.length, q.length)).fill(0);
   p.forEach((c,i) => r[i] += c); q.forEach((c,i) => r[i] += c); return r;
}
function pScale(p, s) { return p.map(c => c*s); }
function pDeriv(p) { return p.slice(1).map((c,i) => c*(i+1)); }
function pMulA(p) { return [0, ...p]; }
function pMul1pA2(p) { return pAdd(p, [0,0,...p]); }
function formatPoly(coeffs) {
   const terms = [];
   for (let k = coeffs.length - 1; k >= 0; k--) {
       const c = Math.round(coeffs[k]);
       if (!c) continue;
       const abs = Math.abs(c);
       const sign = c > 0 ? '+' : '-';
       const varPart = k === 0 ? '' : k === 1 ? 'a' : `a<sup>${k}</sup>`;
       const coefPart = (abs === 1 && k > 0) ? '' : `${abs}`;
       terms.push({ sign, term: coefPart + varPart });
   }
   if (!terms.length) return '0';
   return terms.map(({sign, term}, i) =>
       i === 0 ? (sign==='-' ? '-' : '') + term : ` ${sign} ${term}`
   ).join('');
}

function polyConv(p, q) {
   const r = new Array(p.length + q.length - 1).fill(0);
   for (let i = 0; i < p.length; i++)
       for (let j = 0; j < q.length; j++)
           r[i+j] += p[i] * q[j];
   return r;
}
function formatPolyTan(coeffs) {
   const terms = [];
   for (let k = coeffs.length - 1; k >= 0; k--) {
       const c = Math.round(coeffs[k]);
       if (!c) continue;
       const abs = Math.abs(c);
       const sign = c > 0 ? '+' : '-';
       const varPart = k === 0 ? '' : k === 1 ? 'tan(a)' : `tan<sup>${k}</sup>(a)`;
       const coefPart = (abs === 1 && k > 0) ? '' : `${abs}`;
       terms.push({ sign, term: coefPart + varPart });
   }
   if (!terms.length) return '0';
   return terms.map(({sign, term}, i) =>
       i === 0 ? (sign==='-' ? '-' : '') + term : ` ${sign} ${term}`
   ).join('');
}

let hermiteCache = null;
function getHermitePolys(maxN) {
   if (hermiteCache && hermiteCache.length > maxN) return hermiteCache;
   const hs = [[1], [0, 2]]; // H₀=1, H₁=2a
   for (let n = 1; n < maxN; n++) {
       const t1 = pScale(pMulA(hs[n]), 2);          // 2a·Hₙ
       const t2 = pScale(hs[n-1], -2*n);            // -2n·Hₙ₋₁
       hs.push(pAdd(t1, t2));
   }
   hermiteCache = hs;
   return hs;
}


const functions = {
    sin: {
        func: Math.sin,
        getTerm: (n, x, a) => {
            const deriv = Math.sin(a + n * Math.PI / 2);
            // 記号ロジック: sin -> cos -> -sin -> -cos
            const mod = n % 4;
            let sym = "";
            let sign = 1;
            if (mod === 0) { sym = "sin(a)"; sign = 1; }
            else if (mod === 1) { sym = "cos(a)"; sign = 1; }
            else if (mod === 2) { sym = "sin(a)"; sign = -1; } // -sin(a)
            else if (mod === 3) { sym = "cos(a)"; sign = -1; } // -cos(a)
            
            return buildTermHtml(n, x, a, deriv, true, sym, sign);
        }
    },
    cos: {
        func: Math.cos,
        getTerm: (n, x, a) => {
            const deriv = Math.cos(a + n * Math.PI / 2);
            // 記号: cos -> -sin -> -cos -> sin
            const mod = n % 4;
            let sym = "";
            let sign = 1;
            if (mod === 0) { sym = "cos(a)"; sign = 1; }
            else if (mod === 1) { sym = "sin(a)"; sign = -1; }
            else if (mod === 2) { sym = "cos(a)"; sign = -1; }
            else if (mod === 3) { sym = "sin(a)"; sign = 1; }

            return buildTermHtml(n, x, a, deriv, true, sym, sign);
        }
    },
    exp: {
        func: Math.exp,
        getTerm: (n, x, a) => {
            const deriv = Math.exp(a);
            // 常に e^a
            return buildTermHtml(n, x, a, deriv, true, "e<sup>a</sup>", 1);
        }
    },
    sinh: {
        func: Math.sinh,
        getTerm: (n, x, a) => {
            const deriv = (n % 2 === 0) ? Math.sinh(a) : Math.cosh(a);
            let sym = (n % 2 === 0) ? "sinh(a)" : "cosh(a)";
            return buildTermHtml(n, x, a, deriv, true, sym, 1);
        }
    },
    cosh: {
        func: Math.cosh,
        getTerm: (n, x, a) => {
            const deriv = (n % 2 === 0) ? Math.cosh(a) : Math.sinh(a);
            let sym = (n % 2 === 0) ? "cosh(a)" : "sinh(a)";
            return buildTermHtml(n, x, a, deriv, true, sym, 1);
        }
    },
    log: {
        func: (x) => Math.log(1 + x),
        getTerm: (n, x, a) => {
            // logは特殊構造なので個別処理
            if (a <= -1) return { val: 0, text: "" };
            
            // 計算値
            let val;
            let text = "";
            let isMaclaurin = Math.abs(a) < 0.001;

            if (n === 0) {
                // 定数項: ln(1+a)
                val = Math.log(1+a);
                if (isMaclaurin) text = ""; // log(1)=0
                else text = " + ln(1+a)"; 
            } else {
                // 一般項: (-1)^(n-1) / n * (1+a)^-n
                let signVal = (n % 2 === 0) ? -1 : 1;
                let baseDeriv = signVal / Math.pow(1+a, n); // nで割る前
                val = (baseDeriv / n) * Math.pow(x - a, n);

                // テキスト
                if (isMaclaurin) {
                     // 従来のマクローリン表示
                     let signStr = signVal > 0 ? " + " : " - ";
                     let xPart = (n===1) ? "x" : `x<sup>${n}</sup>`;
                     text = (n===1) ? (signStr+"x") : `${signStr}<span class="frac"><span class="frac-top">${xPart}</span><span class="frac-bottom">${n}</span></span>`;
                } else {
                    // テイラー記号表示: (-1)^(n-1) (x-a)^n / n(1+a)^n
                    // 少し複雑になるので、「定数C」的な見せ方として (1+a)^n を分母に置く
                    let signStr = signVal > 0 ? " + " : " - ";
                    let top = `(x - a)<sup>${n}</sup>`;
                    let bottom = (n===1) ? "(1+a)" : `${n}(1+a)<sup>${n}</sup>`;
                    text = `${signStr}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${bottom}</span></span>`;
                }
            }
            return { val, text };
        }
    },
    inv: {
        func: (x) => 1 / (1 - x),
        getTerm: (n, x, a) => {
            // 修正: a=1（特異点）の直近のみ計算不能とし、それ以外(1.8など)は許可する
            if (Math.abs(a - 1) < 0.001) return { val: 0, text: "" };
            
            // 係数: 1 / (1-a)^(n+1)
            let coeff = 1 / Math.pow(1 - a, n + 1);
            let val = coeff * Math.pow(x - a, n);
            
            let text = "";
            let isMaclaurin = Math.abs(a) < 0.001;

            if (isMaclaurin) {
                 let xPart = (n===0) ? "1" : (n===1 ? "x" : `x<sup>${n}</sup>`);
                 text = " + " + xPart;
            } else {
                // 表示: (x-a)^n / (1-a)^(n+1)
                // a=1.8の場合、分母が負になりますが、構造として (1-a) を維持します
                let top = (n===0) ? "1" : `(x - a)<sup>${n}</sup>`;
                let bottom = (n+1 === 1) ? "(1-a)" : `(1-a)<sup>${n+1}</sup>`;
                text = ` + <span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${bottom}</span></span>`;
            }
            return { val, text };
        }
    },
       arctan: (() => {
       // 数値微分キャッシュ (グラフ描画用)
       let numCache = { a: null, derivs: [] };
       function getDerivs(a, maxN) {
           if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
           const d = [];
           d[0] = Math.atan(a);
           if (maxN >= 1) d[1] = 1 / (1 + a * a);
           for (let k = 1; k < maxN; k++) {
               d[k+1] = -(2*a*k*d[k] + k*(k-1)*(d[k-1] ?? 0)) / (1 + a*a);
           }
           numCache = { a, derivs: d };
           return d;
       }


       let polyCache = null;
       function getPolys(maxN) {
           if (polyCache && polyCache.length > maxN) return polyCache;
           const ps = [null, [1]]; // p_0=special(arctan), p_1=1
           for (let n = 1; n < maxN; n++) {
               ps[n+1] = pAdd(pMul1pA2(pDeriv(ps[n])), pScale(pMulA(ps[n]), -2*n));
           }
           polyCache = ps;
           return ps;
       }


       return {
           func: Math.atan,
           getTerm: (n, x, a) => {
               if (Math.abs(a) < 0.001) {
                   // マクローリン (a=0): 奇数項のみ・従来通り
                   if (n % 2 === 0) return { val: 0, text: "" };
                   const k = (n-1)/2;
                   const signVal = (k%2===0) ? 1 : -1;
                   const val = (signVal/n) * Math.pow(x, n);
                   const signStr = signVal > 0 ? " + " : " - ";
                   const xPart = n===1 ? "x" : `x<sup>${n}</sup>`;
                   const text = n===1 ? (signStr+"x") : `${signStr}<span class="frac"><span class="frac-top">${xPart}</span><span class="frac-bottom">${n}</span></span>`;
                   return { val, text };
               } else {
                   // テイラー (a≠0): 漸化式多項式で記号表示
                   const derivs = getDerivs(a, Math.max(n+1, 2));
                   const deriv = derivs[n] ?? 0;
                   const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                   let text = "";
                   if (n === 0) {
                       text = " + arctan(a)";
                   } else {
                       const ps = getPolys(n+1);
                       const polyStr = formatPoly(ps[n]);
                       const xPart = n===1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                       const denomBase = n===1 ? "(1+a²)" : `(1+a²)<sup>${n}</sup>`;
                       const denom = n===1 ? denomBase : `${n}!·${denomBase}`;
                       const numer = polyStr === '1' ? xPart : `(${polyStr})·${xPart}`;
                       text = ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`;
                   }
                   return { val, text };
               }
           }
       };
   })(),

    tan: (() => {
        // 全微分はtan(a)の多項式: d_n = p_n(tan(a))
        // 漸化式: d_n = Σ C(n-1,k) d_k d_{n-1-k} → 多項式畳み込みで追跡
        let tanPolyCache = null;
        function getTanPolys(maxN) {
            if (tanPolyCache && tanPolyCache.length > maxN) return tanPolyCache;
            const ps = [[0,1], [1,0,1]]; // p0=t, p1=1+t²
            for (let n = 2; n <= maxN; n++) {
                let poly = [0];
                for (let k = 0; k < n; k++) {
                    const term = polyConv(ps[k], ps[n-1-k]).map(c => c * binom(n-1, k));
                    while (poly.length < term.length) poly.push(0);
                    term.forEach((c, i) => poly[i] += c);
                }
                ps.push(poly);
            }
            tanPolyCache = ps;
            return ps;
        }
        let numCache = { a: null, derivs: [] };
        function getDerivs(a, maxN) {
            if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
            const d = [Math.tan(a)];
            d[1] = 1 + d[0] * d[0];
            for (let n = 2; n <= maxN; n++) {
                let s = 0;
                for (let k = 0; k < n; k++) s += binom(n-1, k) * d[k] * d[n-1-k];
                d[n] = s;
            }
            numCache = { a, derivs: d };
            return d;
        }
        return {
            func: Math.tan,
            getTerm: (n, x, a) => {
                const t0 = Math.tan(a);
                if (!isFinite(t0)) return { val: 0, text: "" };
                const derivs = getDerivs(a, Math.max(n+1, 2));
                const deriv = derivs[n] ?? 0;
                const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                const ps = getTanPolys(Math.max(n+1, 2));
                const polyStr = formatPolyTan(ps[n]);
                let text = "";
                if (n === 0) {
                    text = " + tan(a)";
                } else {
                    const xPart = n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                    const numer = polyStr === "1" ? xPart : `(${polyStr})·${xPart}`;
                    const denom = n === 1 ? "" : `${n}!`;
                    text = denom
                        ? ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`
                        : ` + ${numer}`;
                }
                return { val, text };
            }
        };
    })(),

    sqrt: {
        // f^(n)(a) = c_num/c_den · (1+a)^(1/2-n)
        // c_num = product_{j=0}^{n-1}(1-2j), c_den = 2^n
        // 表示: c_num·(x-a)^n / (c_den·n!·√((1+a)^(2n-1)))
        func: (x) => Math.sqrt(1 + x),
        getTerm: (n, x, a) => {
            if (1 + a <= 0) return { val: 0, text: "" };
            // 有理係数を整数で計算 (GCD約分)
            let cNum = 1, cDen = Math.pow(2, n);
            for (let j = 0; j < n; j++) cNum *= (1 - 2*j);
            const g = gcd(Math.abs(cNum), cDen);
            const rNum = cNum / g, rDen = cDen / g;
            const deriv = (cNum / cDen) * Math.pow(1 + a, 0.5 - n);
            const val = (deriv / factorial(n)) * Math.pow(x - a, n);

            let text = "";
            if (n === 0) {
                text = " + √(1+a)";
            } else {
                const signStr = rNum >= 0 ? " + " : " - ";
                const absNum = Math.abs(rNum);
                const xPart = n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                const sqrtExp = 2*n - 1;
                const sqrtPart = sqrtExp === 1 ? "√(1+a)" : `√((1+a)<sup>${sqrtExp}</sup>)`;
                const denomFact = factorial(n);
                const denomNum = rDen * denomFact;
                const fullDenom = denomNum === 1 ? sqrtPart : `${denomNum}·${sqrtPart}`;
                const fullNum = absNum === 1 ? xPart : `${absNum}·${xPart}`;
                text = `${signStr}<span class="frac"><span class="frac-top">${fullNum}</span><span class="frac-bottom">${fullDenom}</span></span>`;
            }
            return { val, text };
        }
    },

    gauss: {
       // f^(n)(a) = (-1)^n · Hₙ(a) · e^(-a²)
       func: (x) => Math.exp(-x * x),
       getTerm: (n, x, a) => {
           const ea2 = Math.exp(-a * a);
           const hs = getHermitePolys(Math.max(n + 1, 2));
           // (-1)^n を Hₙ の係数に折り込む
           const signN = (n % 2 === 0) ? 1 : -1;
           const hSigned = pScale(hs[n], signN);
           const deriv = hSigned.reduce((s, c, i) => s + c * Math.pow(a, i), 0) * ea2;
           const val = (deriv / factorial(n)) * Math.pow(x - a, n);

           let text = "";
           if (Math.abs(a) < 0.001) {
               // マクローリン (a=0): 偶数項のみ、H₂ₖ(0) = (-1)^k (2k)!/k! だが係数は整理済み
               if (n % 2 !== 0) return { val: 0, text: "" };
               const k = n / 2;
               const sv = (k % 2 === 0) ? 1 : -1;
               const signStr = sv > 0 ? " + " : " - ";
               if (n === 0) {
                   text = " + 1";
               } else if (k === 1) {
                   text = ` - x<sup>2</sup>`;
               } else {
                   text = `${signStr}<span class="frac"><span class="frac-top">x<sup>${n}</sup></span><span class="frac-bottom">${k}!</span></span>`;
               }
           } else {
               // テイラー (a≠0): (-1)^n · Hₙ(a) · e^(-a²) / n! · (x-a)^n
               const polyStr = formatPoly(hSigned);
               const xPart = n === 0 ? "" : n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
               const signStr = deriv >= 0 ? " + " : " - ";
               if (n === 0) {
                   text = ` + e<sup>-a²</sup>`;
               } else {
                   const numer = `(${polyStr})·e<sup>-a²</sup>·${xPart}`;
                   const denom = n === 1 ? "" : `${n}!`;
                   text = denom
                       ? ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`
                       : ` + ${numer}`;
               }
           }
           return { val, text };
       }
   },

        inv2: (() => {
        // f = 1/(1+x²) = arctan'(x)
        // f^(n)(a) = p_n(a) / (1+a²)^(n+1)
        // 漸化式: p_{n+1} = -(2n+2)a·p_n - n(n+1)·p_{n-1}·(1+a²)
        let inv2PolyCache = null;
        function getInv2Polys(maxN) {
            if (inv2PolyCache && inv2PolyCache.length > maxN) return inv2PolyCache;
            const ps = [[1], [0, -2]]; // p0=1, p1=-2a
            for (let n = 1; n < maxN; n++) {
                const t1 = pScale(pMulA(ps[n]), -(2*n+2));
                const t2 = pScale(pMul1pA2(ps[n-1]), -n*(n+1));
                ps.push(pAdd(t1, t2));
            }
            inv2PolyCache = ps;
            return ps;
        }
        let numCache = { a: null, derivs: [] };
        function getDerivs(a, maxN) {
            if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
            const a2 = 1 + a * a;
            const d = [1/a2, -2*a/(a2*a2)];
            for (let n = 1; n < maxN; n++) {
                d[n+1] = (-(2*n+2)*a*d[n] - n*(n+1)*d[n-1]) / a2;
            }
            numCache = { a, derivs: d };
            return d;
        }
        return {
            func: (x) => 1 / (1 + x * x),
            getTerm: (n, x, a) => {
                if (Math.abs(a) < 0.001) {
                    // マクローリン: 偶数項のみ (-1)^k, n=2k
                    if (n % 2 !== 0) return { val: 0, text: "" };
                    const k = n / 2;
                    const signVal = (k % 2 === 0) ? 1 : -1;
                    const val = signVal * Math.pow(x, n);
                    const signStr = signVal > 0 ? " + " : " - ";
                    const text = n === 0 ? " + 1" : `${signStr}x<sup>${n}</sup>`;
                    return { val, text };
                } else {
                    // テイラー: p_n(a) / (1+a²)^(n+1)
                    const derivs = getDerivs(a, Math.max(n+1, 2));
                    const deriv = derivs[n] ?? 0;
                    const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                    const ps = getInv2Polys(Math.max(n+1, 2));
                    const polyStr = formatPoly(ps[n]); // arctan用と共用
                    let text = "";
                    const xPart = n === 0 ? "" : n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                    const denom1 = n === 0 ? "(1+a²)" : n === 1 ? "(1+a²)²" : `(1+a²)<sup>${n+1}</sup>`;
                    const denom = n <= 1 ? denom1 : `${n}!·${denom1}`;
                    const numer = n === 0 ? polyStr : `(${polyStr})·${xPart}`;
                    text = ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`;
                    return { val, text };
                }
            }
        };
    })(),
};

/**
 * App Elements & Initialization
 */
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
const nSlider = document.getElementById('nSlider');
const aSlider = document.getElementById('aSlider');
const zoomSlider = document.getElementById('zoomSlider');
const funcSelect = document.getElementById('funcSelect');
const formulaText = document.getElementById('formula-text');
const nVal = document.getElementById('nVal');
const aVal = document.getElementById('aVal');
const zoomVal = document.getElementById('zoomVal');
const langRadios = document.getElementsByName('lang');

// Labels
const elLblFunc = document.getElementById('lbl-func');
const elLblCenter = document.getElementById('lbl-center');
const elLblTerms = document.getElementById('lbl-terms');
const elLblZoom = document.getElementById('lbl-zoom');
const elLegendOriginal = document.getElementById('legend-original');
const elLegendApprox = document.getElementById('legend-approx');
const elLegendCenter = document.getElementById('legend-center');

const danceBtn = document.getElementById('dance-btn');

let currentFuncKey = 'sin';
let audioCtx = null;
let width, height;

function updateLanguage(lang) {
    currentLang = lang;
    const t = translations[lang];
    elLblFunc.innerText = t.lblFunc;
    elLblCenter.innerText = t.lblCenter;
    elLblTerms.innerText = t.lblTerms;
    elLblZoom.innerText = t.lblZoom;

    danceBtn.innerText = t.btnDance;

    elLegendOriginal.innerText = t.legendOriginal;
    elLegendApprox.innerText = t.legendApprox;
    elLegendCenter.innerText = t.legendCenter;

    const currentVal = currentFuncKey;
   const list = document.getElementById('func-list');
   list.innerHTML = "";
   for (let key in functions) {
       const item = document.createElement('div');
       item.className = 'func-item' + (key === currentVal ? ' selected' : '');
       item.textContent = t.funcs[key];
       item.dataset.key = key;
       item.addEventListener('click', () => {
           document.querySelectorAll('.func-item').forEach(el => el.classList.remove('selected'));
           item.classList.add('selected');
           currentFuncKey = key;
           nSlider.value = 1; nVal.textContent = 1; aSlider.value = 0; aVal.textContent = 0;
           requestAnimationFrame(draw);
       });
       list.appendChild(item);
   }
}



document.querySelectorAll('.lang-btn').forEach(btn => {
   btn.addEventListener('click', () => {
       document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
       btn.classList.add('active');
       updateLanguage(btn.dataset.lang);
   });
});
updateLanguage('ja');

function playSound(n) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const baseFreq = 261.63; 
    const semiTones = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21, 24, 26, 28, 31, 33, 36]; 
    const cycle = Math.floor(n / semiTones.length);
    const index = n % semiTones.length;
    const note = semiTones[index] + (cycle * 2); 
    osc.frequency.setValueAtTime(baseFreq * Math.pow(2, note/12), audioCtx.currentTime);
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
}

function toCanvasX(x, rangeX) { return (x / rangeX) * (width / 2) + (width / 2); }
function toCanvasY(y, rangeX) { const scale = (width / 2) / rangeX; return (height / 2) - (y * scale); }

function draw() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    
    const rangeX = parseFloat(zoomSlider.value);
    const nMax = parseInt(nSlider.value);
    const a = parseFloat(aSlider.value);

    const funcKey = currentFuncKey;

    const currentFunc = functions[funcKey];
    
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
    ctx.fillRect(0, 0, width, height);
    
    const scale = (width / 2) / rangeX;
    const rangeY = (height / 2) / scale;

    // Grid X
    ctx.font = "12px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "top";
    for (let i = Math.floor(-rangeX); i <= rangeX; i++) {
        const cx = toCanvasX(i, rangeX);
        ctx.beginPath();
        if (i === 0) { ctx.lineWidth = 3; ctx.strokeStyle = "var(--axis)"; }
        else if (i%5===0) { ctx.lineWidth = 1.5; ctx.strokeStyle = "#555"; }
        else { ctx.lineWidth = 0.5; ctx.strokeStyle = "#333"; }
        ctx.moveTo(cx, 0); ctx.lineTo(cx, height); ctx.stroke();
        if (i !== 0 && i % 2 === 0) { ctx.fillStyle = "#888"; ctx.fillText(i, cx, height/2 + 5); }
    }
    // Grid Y
    for (let i = Math.floor(-rangeY); i <= rangeY; i++) {
        const cy = toCanvasY(i, rangeX);
        ctx.beginPath();
        if (i === 0) { ctx.lineWidth = 3; ctx.strokeStyle = "var(--axis)"; }
        else if (i%5===0) { ctx.lineWidth = 1.5; ctx.strokeStyle = "#555"; }
        else { ctx.lineWidth = 0.5; ctx.strokeStyle = "#333"; }
        ctx.moveTo(0, cy); ctx.lineTo(width, cy); ctx.stroke();
    }
    // Center Line
    const cxA = toCanvasX(a, rangeX);
    if (cxA >= 0 && cxA <= width) {
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.lineWidth = 2;
        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--center');
        ctx.moveTo(cxA, 0); ctx.lineTo(cxA, height); ctx.stroke(); ctx.setLineDash([]);
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--center');
        ctx.fillText(`a=${a}`, cxA + 5, height/2 - 20);
    }

    // Original
    ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--target'); ctx.lineWidth = 3;
    let first = true;
    for (let px = 0; px < width; px+=3) {
        const x = (px - width/2) / scale;
        if (funcKey === 'log' && x <= -1) continue;
        if (funcKey === 'inv' && Math.abs(x - 1) < 0.05) { first = true; continue; }
        const y = currentFunc.func(x);
        if (!isFinite(y) || Math.abs(y) > rangeY * 2) { first = true; continue; }//NaN ガード（sqrt の定義域外対策）
        const py = toCanvasY(y, rangeX);
        if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
    }
    ctx.stroke();

    // Approx
    ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--accent'); ctx.lineWidth = 3;
    first = true;
    
    // Formula Text Gen
    let formulaHtml = `P(x) ≈ `;
    let isFirstTerm = true;

    for (let px = 0; px < width; px+=3) {
        const x = (px - width/2) / scale;
        let yApprox = 0;
        
        for (let k = 0; k <= nMax; k++) {
             let t = currentFunc.getTerm(k, x, a);
             yApprox += t.val;
        }
        
        if (!isFinite(yApprox) || Math.abs(yApprox) > rangeY * 2) { first = true; continue; }//NaN ガード（sqrt の定義域外対策）

        const py = toCanvasY(yApprox, rangeX);
        if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
    }
    ctx.stroke();
    
    for (let k = 0; k <= nMax; k++) {
        let t = currentFunc.getTerm(k, 0, a);
        if (t.text) {
            let txt = t.text;
            if (isFirstTerm && txt.trim().startsWith('+')) txt = txt.replace('+','');
            if (isFirstTerm && txt.trim().startsWith(' -')) txt = txt.trim(); // 最初の項のマイナス詰め
            formulaHtml += txt;
            isFirstTerm = false;
        }
    }
    if (isFirstTerm) formulaHtml += "0";
    formulaText.innerHTML = formulaHtml;
}



// --- Animation ---
const playBtn = document.getElementById('play-btn');
let animTimer = null;
let userTouching = false;

function startAnim() {
    if (animTimer) return;
    

    playBtn.textContent = '⏸ STOP';
    playBtn.classList.add('active');

    animTimer = setInterval(() => {
        if (userTouching) return; // スライダー操作中はスキップ（止めない）
        let cur = parseInt(nSlider.value);
        if (cur >= parseInt(nSlider.max)) {
            cur = 0; // ループ再生
        } else {
            cur++;
        }
        nSlider.value = cur;
        nVal.textContent = cur;
        playSound(cur);
        requestAnimationFrame(draw);
    }, 300); // 300ms間隔（お好みで調整）
}

function stopAnim() {
    clearInterval(animTimer);
    animTimer = null;

    playBtn.textContent = '▶ PLAY';
    playBtn.classList.remove('active');
}

playBtn.addEventListener('click', () => {
    animTimer ? stopAnim() : startAnim();
});

// スライダーを触っている間はアニメのコマをスキップ（停止はしない）
nSlider.addEventListener('mousedown', () => userTouching = true);
nSlider.addEventListener('touchstart', () => userTouching = true);
nSlider.addEventListener('mouseup', () => userTouching = false);
nSlider.addEventListener('touchend', () => userTouching = false);


// Dance with Maclaurin (Reset a to 0)
danceBtn.addEventListener('click', () => {
    aSlider.value = 0;
    aVal.textContent = "0";
    requestAnimationFrame(draw);
});

// Events
nSlider.addEventListener('input', (e) => { nVal.textContent = e.target.value; playSound(parseInt(e.target.value)); requestAnimationFrame(draw); });
aSlider.addEventListener('input', (e) => { aVal.textContent = e.target.value; requestAnimationFrame(draw); });
zoomSlider.addEventListener('input', (e) => { zoomVal.textContent = "x: ±" + e.target.value; requestAnimationFrame(draw); });

window.addEventListener('resize', draw);

draw();
</script>


</body>
</html>