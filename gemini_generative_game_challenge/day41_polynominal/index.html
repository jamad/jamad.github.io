<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taylor Shift "Dancing with Maclaurin"</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --accent: #00bcd4; /* 近似線の色 */
            --target: #ff4081; /* 元関数の色 */
            --center: #ffd740; /* 中心点aの色 (新規追加) */
            --axis: #ffffff;
            --grid-major: #424242;
            --grid-minor: #2c2c2c;
            --text: #e0e0e0;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Courier New', 'Consolas', monospace; color: var(--text); touch-action: none; }

        
        /* ヘッダー (言語切り替え) */
        #header {
            position: absolute; top: 10px; left: 20px;
            background: rgba(30, 30, 30, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            backdrop-filter: blur(4px);
            border: 1px solid #444;
            z-index: 100;
        }
        .lang-option {
            display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 0.8rem;
        }
        input[type="radio"] { accent-color: var(--accent); cursor: pointer; }

        /* UI レイアウト (下部パネル) */
        #ui-layer {
            position: absolute; bottom: 0; width: 100%;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 20px 30px; /* iPhoneの下部バー考慮 */
            box-sizing: border-box;
            border-top: 1px solid #333;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; gap: 12px;
            z-index: 100;
        }

        /* 数式表示エリア */
        #formula-container {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            overflow-x: auto;
            white-space: nowrap;
            min-height: 40px;
            display: flex;
            align-items: center;
            border-left: 4px solid var(--accent);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            
            /* スクロールバーのスタイリング (Webkit) */
            scrollbar-width: thin;
            scrollbar-color: #555 #000;
        }
        #formula-container::-webkit-scrollbar {
            height: 8px;
        }
        #formula-container::-webkit-scrollbar-track {
            background: #000; 
        }
        #formula-container::-webkit-scrollbar-thumb {
            background: #555; 
            border-radius: 4px;
        }

        #formula-text {
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        /* 各コントロール行 */
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .label-row { display: flex; justify-content: space-between; font-size: 0.9rem; color: #aaa; }
        
        /* 入力要素のスタイル */
        select {
            background: #333; color: white; border: 1px solid #555; padding: 10px; border-radius: 4px; font-size: 1rem;
            outline: none; width: 100%; box-sizing: border-box;
        }
        input[type=range] {
            width: 100%; height: 6px; background: #444; border-radius: 3px; outline: none; -webkit-appearance: none; margin-top: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 24px; height: 24px; background: var(--accent); border-radius: 50%; cursor: pointer; border: 2px solid #fff;
        }

        /* 横並びグリッド（PC・タブレット用） */
        .controls-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* 凡例 */
        #legend {
            position: absolute; top: 10px; right: 20px;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 4px; pointer-events: none;
            font-size: 0.8rem;
            text-align: right;
            z-index: 90;
        }
        .legend-item { display: flex; align-items: center; justify-content: flex-end; gap: 8px; margin-bottom: 4px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        /* 中心点用の凡例スタイル追加 */
        .line-dashed { width: 20px; height: 2px; border-top: 2px dashed var(--center); }

        /* PC等でのレイアウト調整 */
        @media (min-width: 768px) {
            #ui-layer {
                /* 幅制限を解除して画面下部全体を使う */
                max-width: none;
                width: 96%;
                bottom: 20px; 
                left: 2%; 
                right: 2%;
                border-radius: 12px;
                padding: 20px;
            }

            .controls-grid {
                display: grid;
                /* 変更: aを追加して4カラムに */
                grid-template-columns: 1fr 2fr 2fr 1fr; /* 関数 | a | 項数 | ズーム */
                gap: 20px;
                align-items: end;
            }
            
            /* 数式は全幅使う */
            #formula-container {
                grid-column: 1 / -1;
                margin-bottom: 10px;
            }
            
            /* グリッド配置の再定義 (aを追加したため調整) */
            .control-group:nth-child(1) { grid-area: 2 / 1 / 3 / 2; } /* Select */
            .control-group:nth-child(3) { grid-area: 2 / 2 / 3 / 3; } /* a (New) */
            .control-group:nth-child(4) { grid-area: 2 / 3 / 3 / 4; } /* Terms */
            .control-group:nth-child(5) { grid-area: 2 / 4 / 3 / 5; } /* Zoom */
        }

        #play-btn {
        background: var(--accent);
        color: #000;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        font-size: 1.1rem;
        cursor: pointer;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
    }
    #play-btn:hover { background: #00e5ff; }
    #play-btn.playing { background: #ff4081; }
    </style>
</head>
<body>

<canvas id="graphCanvas"></canvas>

<!-- 言語切り替えヘッダー -->
<div id="header">
    <label class="lang-option"><input type="radio" name="lang" value="en"> EN</label>
    <label class="lang-option"><input type="radio" name="lang" value="ja" checked> JP</label>
    <label class="lang-option"><input type="radio" name="lang" value="fi"> FI</label>
    <label class="lang-option"><input type="radio" name="lang" value="da"> DA</label>
</div>

<!-- 凡例 -->
<div id="legend">
    <div class="legend-item"><div class="dot" style="background:var(--target)"></div> <span id="legend-original">元の関数 f(x)</span></div>
    <div class="legend-item"><div class="dot" style="background:var(--accent)"></div> <span id="legend-approx">近似多項式 P(x)</span></div>
    <!-- 中心点の凡例追加 -->
    <div class="legend-item"><div class="line-dashed"></div> <span id="legend-center">中心点 (a)</span></div>
</div>

<!-- コントロールパネル -->
<div id="ui-layer">
    <div class="controls-grid">
        <!-- 2. 数式 (PCではgrid-column 1/-1) -->
        <div id="formula-container">
            <span id="formula-text"></span>
        </div>

        <!-- 1. 関数選択 -->
        <div class="control-group">
            <div class="label-row"><span id="lbl-func">関数選択</span></div>
            <select id="funcSelect"></select>
        </div>

        <!-- 新規: 中心点スライダー -->
        <div class="control-group">

           <div class="label-row" style="display:flex; align-items:center; gap:8px;">
               <button id="dance-btn" title="Dance with Maclaurin" style="background:var(--center); border:none; border-radius:12px; padding:2px 8px; cursor:pointer; font-size:0.7rem; color:#000; font-weight:bold;">DANCE</button>
               <span id="lbl-center" style="flex:1">中心点 (a):</span> <b id="aVal">0</b>
           </div>

            <input type="range" id="aSlider" min="-3.2" max="3.2" value="0" step="0.1">
        </div>

        <!-- 3. 項数スライダー -->
        <div class="control-group">
            <div class="label-row" style="display:flex; align-items:center; gap:8px;">
                 <button id="play-btn" title="Auto play">▶</button>
                 <span id="lbl-terms" style="flex:1">項数 (n):</span>
                 <b id="nVal">1</b>
             </div>
            <input type="range" id="nSlider" min="0" max="64" value="1" step="1">
        </div>

        <!-- 4. ズームスライダー -->
        <div class="control-group">
            <div class="label-row"><span id="lbl-zoom">ズーム (表示範囲):</span> <b id="zoomVal">x: ±5</b></div>
            <input type="range" id="zoomSlider" min="2" max="20" value="6" step="0.5">
        </div>
    </div>
</div>


<script>
/**
 * Localization (i18n) Data
 */
const translations = {
    ja: {
        lblFunc: "関数選択", lblTerms: "項数 (n)", lblZoom: "ズーム", lblCenter: "中心点 (a)", btnDance: "Dance!",
        legendOriginal: "元の関数 f(x)", legendApprox: "近似多項式 P(x)", legendCenter: "中心点 (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x (指数関数)",
            log: "ln(1+x) (対数)", inv: "1/(1-x) (幾何級数)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (二項展開)", gauss: "e^(-x²) (ガウス)", inv2: "1/(1+x²)"
        }
    },
    en: {
        lblFunc: "Function", lblTerms: "Terms (n)", lblZoom: "Zoom", lblCenter: "Center (a)", btnDance: "Dance!",
        legendOriginal: "Original f(x)", legendApprox: "Polynomial P(x)", legendCenter: "Center (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binomial)", gauss: "e^(-x²) (Gaussian)", inv2: "1/(1+x²)"
        }
    },
    fi: {
        lblFunc: "Funktio", lblTerms: "Termit (n)", lblZoom: "Zoomaus", lblCenter: "Keskipiste (a)", btnDance: "Dance!",
        legendOriginal: "f(x)", legendApprox: "P(x)", legendCenter: "Keskipiste (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binominen)", gauss: "e^(-x²) (Gaussinen)", inv2: "1/(1+x²)"
        }
    },
    da: {
        lblFunc: "Funktion", lblTerms: "Led (n)", lblZoom: "Zoom", lblCenter: "Centrum (a)", btnDance: "Dance!",
        legendOriginal: "f(x)", legendApprox: "P(x)", legendCenter: "Centrum (a)",
        funcs: {
            sin: "sin(x)", cos: "cos(x)", exp: "e^x",
            log: "ln(1+x)", inv: "1/(1-x)",
            arctan: "arctan(x)", sinh: "sinh(x)", cosh: "cosh(x)",
            tan: "tan(x)", sqrt: "√(1+x) (Binomisk)", gauss: "e^(-x²) (Gaussisk)", inv2: "1/(1+x²)"
        }
    }
};

let currentLang = 'ja';

/**
 * Math Logic & Formatting Helpers
 */
function factorial(n) {
    if (n <= 1) return 1;
    let r = 1;
    for (let i = 2; i <= n; i++) r *= i;
    return r;
}

function binom(n, k) {
    if (k < 0 || k > n) return 0;
    if (k === 0 || k === n) return 1;
    let r = 1;
    for (let i = 0; i < k; i++) r = r * (n - i) / (i + 1);
    return Math.round(r);
}

function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); };

// 数式文字列生成ヘルパー
// symbolStr: "sin(a)" などの記号文字列。nullの場合は数値計算値を使用。
// forceSign: 記号表示時の強制符号 (+1 または -1)。nullなら自動。
function buildTermHtml(n, xVal, a, derivVal, useFactorial = true, symbolStr = null, forceSign = null) {
    // 係数がほぼ0で、かつ記号指定がない場合はスキップ
    if (!symbolStr && Math.abs(derivVal) < 0.0001) return { val: 0, text: "" };

    const isMaclaurin = Math.abs(a) < 0.001;
    let absDeriv = Math.abs(derivVal);

    // --- 1. 変数部分 (x-a)^n ---
    let xPart = "";
    if (n === 0) {
        xPart = ""; 
    } else if (n === 1) {
        xPart = isMaclaurin ? "x" : "(x - a)";
    } else {
        xPart = isMaclaurin ? `x<sup>${n}</sup>` : `(x - a)<sup>${n}</sup>`;
    }

    // --- 2. 表示テキスト生成 ---
    let text = "";

    if (isMaclaurin) {
        // --- マクローリン (a=0) ---
        // 従来通り数値(分数)できれいに表示
        let sign = derivVal >= 0 ? " + " : " - ";
        let showNum = Math.abs(absDeriv - 1) > 0.001;
        let numStr = showNum ? parseFloat(absDeriv.toFixed(4)) : "";
        let top = (numStr + xPart) || "1"; 
        
        if (n === 0) {
            text = sign + (numStr || "1");
        } else if (useFactorial && n > 1) {
            text = `${sign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
        } else {
            text = sign + top;
        }

    } else {
        // --- テイラー (a!=0) ---
        // 記号 (sin(a)など) があればそれを使う
        
        let displaySign = " + ";
        let content = "";
        
        if (symbolStr) {
            // 記号モード (例: sin(a), e^a)
            // forceSignがあればそれに従う (例: -sin(a) の項)
            if (forceSign !== null) {
                displaySign = forceSign >= 0 ? " + " : " - ";
            }
            content = `<span style="font-style:italic; font-family:Times New Roman;">${symbolStr}</span>`;
            
            // 係数部分の構築
            if (n === 0) {
                text = displaySign + content;
            } else {
                // 分子: Symbol(x-a)^n
                let top = content + xPart;
                if (useFactorial && n > 1) {
                    text = `${displaySign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
                } else {
                    text = displaySign + top;
                }
            }
            
        } else {
            // 記号がない場合 (数値フォールバック) - マジックナンバーを避けるため丸める
            // または log/inv のような代数的構造を表示
            let sign = derivVal >= 0 ? " + " : " - ";
            let valStr = parseFloat(absDeriv.toFixed(2));
            let top = valStr + xPart;

            if (n === 0) {
                text = sign + valStr;
            } else if (useFactorial && n > 1) {
                text = `${sign}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${n}!</span></span>`;
            } else {
                text = sign + top;
            }
        }
    }

    // --- 3. 実際の計算値 (グラフ描画用) ---
    let coeff = derivVal;
    if (useFactorial) coeff = derivVal / factorial(n);
    let val = coeff * Math.pow(xVal - a, n);

    return { val, text };
}


// --- Polynomial helpers (グローバルスコープ) ---
function pAdd(p, q) {
   const r = new Array(Math.max(p.length, q.length)).fill(0);
   p.forEach((c,i) => r[i] += c); q.forEach((c,i) => r[i] += c); return r;
}
function pScale(p, s) { return p.map(c => c*s); }
function pDeriv(p) { return p.slice(1).map((c,i) => c*(i+1)); }
function pMulA(p) { return [0, ...p]; }
function pMul1pA2(p) { return pAdd(p, [0,0,...p]); }
function formatPoly(coeffs) {
   const terms = [];
   for (let k = coeffs.length - 1; k >= 0; k--) {
       const c = Math.round(coeffs[k]);
       if (!c) continue;
       const abs = Math.abs(c);
       const sign = c > 0 ? '+' : '-';
       const varPart = k === 0 ? '' : k === 1 ? 'a' : `a<sup>${k}</sup>`;
       const coefPart = (abs === 1 && k > 0) ? '' : `${abs}`;
       terms.push({ sign, term: coefPart + varPart });
   }
   if (!terms.length) return '0';
   return terms.map(({sign, term}, i) =>
       i === 0 ? (sign==='-' ? '-' : '') + term : ` ${sign} ${term}`
   ).join('');
}

function polyConv(p, q) {
   const r = new Array(p.length + q.length - 1).fill(0);
   for (let i = 0; i < p.length; i++)
       for (let j = 0; j < q.length; j++)
           r[i+j] += p[i] * q[j];
   return r;
}
function formatPolyTan(coeffs) {
   const terms = [];
   for (let k = coeffs.length - 1; k >= 0; k--) {
       const c = Math.round(coeffs[k]);
       if (!c) continue;
       const abs = Math.abs(c);
       const sign = c > 0 ? '+' : '-';
       const varPart = k === 0 ? '' : k === 1 ? 'tan(a)' : `tan<sup>${k}</sup>(a)`;
       const coefPart = (abs === 1 && k > 0) ? '' : `${abs}`;
       terms.push({ sign, term: coefPart + varPart });
   }
   if (!terms.length) return '0';
   return terms.map(({sign, term}, i) =>
       i === 0 ? (sign==='-' ? '-' : '') + term : ` ${sign} ${term}`
   ).join('');
}

let hermiteCache = null;
function getHermitePolys(maxN) {
   if (hermiteCache && hermiteCache.length > maxN) return hermiteCache;
   const hs = [[1], [0, 2]]; // H₀=1, H₁=2a
   for (let n = 1; n < maxN; n++) {
       const t1 = pScale(pMulA(hs[n]), 2);          // 2a·Hₙ
       const t2 = pScale(hs[n-1], -2*n);            // -2n·Hₙ₋₁
       hs.push(pAdd(t1, t2));
   }
   hermiteCache = hs;
   return hs;
}


const functions = {
    sin: {
        func: Math.sin,
        getTerm: (n, x, a) => {
            const deriv = Math.sin(a + n * Math.PI / 2);
            // 記号ロジック: sin -> cos -> -sin -> -cos
            const mod = n % 4;
            let sym = "";
            let sign = 1;
            if (mod === 0) { sym = "sin(a)"; sign = 1; }
            else if (mod === 1) { sym = "cos(a)"; sign = 1; }
            else if (mod === 2) { sym = "sin(a)"; sign = -1; } // -sin(a)
            else if (mod === 3) { sym = "cos(a)"; sign = -1; } // -cos(a)
            
            return buildTermHtml(n, x, a, deriv, true, sym, sign);
        }
    },
    cos: {
        func: Math.cos,
        getTerm: (n, x, a) => {
            const deriv = Math.cos(a + n * Math.PI / 2);
            // 記号: cos -> -sin -> -cos -> sin
            const mod = n % 4;
            let sym = "";
            let sign = 1;
            if (mod === 0) { sym = "cos(a)"; sign = 1; }
            else if (mod === 1) { sym = "sin(a)"; sign = -1; }
            else if (mod === 2) { sym = "cos(a)"; sign = -1; }
            else if (mod === 3) { sym = "sin(a)"; sign = 1; }

            return buildTermHtml(n, x, a, deriv, true, sym, sign);
        }
    },
    exp: {
        func: Math.exp,
        getTerm: (n, x, a) => {
            const deriv = Math.exp(a);
            // 常に e^a
            return buildTermHtml(n, x, a, deriv, true, "e<sup>a</sup>", 1);
        }
    },
    sinh: {
        func: Math.sinh,
        getTerm: (n, x, a) => {
            const deriv = (n % 2 === 0) ? Math.sinh(a) : Math.cosh(a);
            let sym = (n % 2 === 0) ? "sinh(a)" : "cosh(a)";
            return buildTermHtml(n, x, a, deriv, true, sym, 1);
        }
    },
    cosh: {
        func: Math.cosh,
        getTerm: (n, x, a) => {
            const deriv = (n % 2 === 0) ? Math.cosh(a) : Math.sinh(a);
            let sym = (n % 2 === 0) ? "cosh(a)" : "sinh(a)";
            return buildTermHtml(n, x, a, deriv, true, sym, 1);
        }
    },
    log: {
        func: (x) => Math.log(1 + x),
        getTerm: (n, x, a) => {
            // logは特殊構造なので個別処理
            if (a <= -1) return { val: 0, text: "" };
            
            // 計算値
            let val;
            let text = "";
            let isMaclaurin = Math.abs(a) < 0.001;

            if (n === 0) {
                // 定数項: ln(1+a)
                val = Math.log(1+a);
                if (isMaclaurin) text = ""; // log(1)=0
                else text = " + ln(1+a)"; 
            } else {
                // 一般項: (-1)^(n-1) / n * (1+a)^-n
                let signVal = (n % 2 === 0) ? -1 : 1;
                let baseDeriv = signVal / Math.pow(1+a, n); // nで割る前
                val = (baseDeriv / n) * Math.pow(x - a, n);

                // テキスト
                if (isMaclaurin) {
                     // 従来のマクローリン表示
                     let signStr = signVal > 0 ? " + " : " - ";
                     let xPart = (n===1) ? "x" : `x<sup>${n}</sup>`;
                     text = (n===1) ? (signStr+"x") : `${signStr}<span class="frac"><span class="frac-top">${xPart}</span><span class="frac-bottom">${n}</span></span>`;
                } else {
                    // テイラー記号表示: (-1)^(n-1) (x-a)^n / n(1+a)^n
                    // 少し複雑になるので、「定数C」的な見せ方として (1+a)^n を分母に置く
                    let signStr = signVal > 0 ? " + " : " - ";
                    let top = `(x - a)<sup>${n}</sup>`;
                    let bottom = (n===1) ? "(1+a)" : `${n}(1+a)<sup>${n}</sup>`;
                    text = `${signStr}<span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${bottom}</span></span>`;
                }
            }
            return { val, text };
        }
    },
    inv: {
        func: (x) => 1 / (1 - x),
        getTerm: (n, x, a) => {
            // 修正: a=1（特異点）の直近のみ計算不能とし、それ以外(1.8など)は許可する
            if (Math.abs(a - 1) < 0.001) return { val: 0, text: "" };
            
            // 係数: 1 / (1-a)^(n+1)
            let coeff = 1 / Math.pow(1 - a, n + 1);
            let val = coeff * Math.pow(x - a, n);
            
            let text = "";
            let isMaclaurin = Math.abs(a) < 0.001;

            if (isMaclaurin) {
                 let xPart = (n===0) ? "1" : (n===1 ? "x" : `x<sup>${n}</sup>`);
                 text = " + " + xPart;
            } else {
                // 表示: (x-a)^n / (1-a)^(n+1)
                // a=1.8の場合、分母が負になりますが、構造として (1-a) を維持します
                let top = (n===0) ? "1" : `(x - a)<sup>${n}</sup>`;
                let bottom = (n+1 === 1) ? "(1-a)" : `(1-a)<sup>${n+1}</sup>`;
                text = ` + <span class="frac"><span class="frac-top">${top}</span><span class="frac-bottom">${bottom}</span></span>`;
            }
            return { val, text };
        }
    },
       arctan: (() => {
       // 数値微分キャッシュ (グラフ描画用)
       let numCache = { a: null, derivs: [] };
       function getDerivs(a, maxN) {
           if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
           const d = [];
           d[0] = Math.atan(a);
           if (maxN >= 1) d[1] = 1 / (1 + a * a);
           for (let k = 1; k < maxN; k++) {
               d[k+1] = -(2*a*k*d[k] + k*(k-1)*(d[k-1] ?? 0)) / (1 + a*a);
           }
           numCache = { a, derivs: d };
           return d;
       }


       let polyCache = null;
       function getPolys(maxN) {
           if (polyCache && polyCache.length > maxN) return polyCache;
           const ps = [null, [1]]; // p_0=special(arctan), p_1=1
           for (let n = 1; n < maxN; n++) {
               ps[n+1] = pAdd(pMul1pA2(pDeriv(ps[n])), pScale(pMulA(ps[n]), -2*n));
           }
           polyCache = ps;
           return ps;
       }


       return {
           func: Math.atan,
           getTerm: (n, x, a) => {
               if (Math.abs(a) < 0.001) {
                   // マクローリン (a=0): 奇数項のみ・従来通り
                   if (n % 2 === 0) return { val: 0, text: "" };
                   const k = (n-1)/2;
                   const signVal = (k%2===0) ? 1 : -1;
                   const val = (signVal/n) * Math.pow(x, n);
                   const signStr = signVal > 0 ? " + " : " - ";
                   const xPart = n===1 ? "x" : `x<sup>${n}</sup>`;
                   const text = n===1 ? (signStr+"x") : `${signStr}<span class="frac"><span class="frac-top">${xPart}</span><span class="frac-bottom">${n}</span></span>`;
                   return { val, text };
               } else {
                   // テイラー (a≠0): 漸化式多項式で記号表示
                   const derivs = getDerivs(a, Math.max(n+1, 2));
                   const deriv = derivs[n] ?? 0;
                   const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                   let text = "";
                   if (n === 0) {
                       text = " + arctan(a)";
                   } else {
                       const ps = getPolys(n+1);
                       const polyStr = formatPoly(ps[n]);
                       const xPart = n===1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                       const denomBase = n===1 ? "(1+a²)" : `(1+a²)<sup>${n}</sup>`;
                       const denom = n===1 ? denomBase : `${n}!·${denomBase}`;
                       const numer = polyStr === '1' ? xPart : `(${polyStr})·${xPart}`;
                       text = ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`;
                   }
                   return { val, text };
               }
           }
       };
   })(),

    tan: (() => {
        // 全微分はtan(a)の多項式: d_n = p_n(tan(a))
        // 漸化式: d_n = Σ C(n-1,k) d_k d_{n-1-k} → 多項式畳み込みで追跡
        let tanPolyCache = null;
        function getTanPolys(maxN) {
            if (tanPolyCache && tanPolyCache.length > maxN) return tanPolyCache;
            const ps = [[0,1], [1,0,1]]; // p0=t, p1=1+t²
            for (let n = 2; n <= maxN; n++) {
                let poly = [0];
                for (let k = 0; k < n; k++) {
                    const term = polyConv(ps[k], ps[n-1-k]).map(c => c * binom(n-1, k));
                    while (poly.length < term.length) poly.push(0);
                    term.forEach((c, i) => poly[i] += c);
                }
                ps.push(poly);
            }
            tanPolyCache = ps;
            return ps;
        }
        let numCache = { a: null, derivs: [] };
        function getDerivs(a, maxN) {
            if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
            const d = [Math.tan(a)];
            d[1] = 1 + d[0] * d[0];
            for (let n = 2; n <= maxN; n++) {
                let s = 0;
                for (let k = 0; k < n; k++) s += binom(n-1, k) * d[k] * d[n-1-k];
                d[n] = s;
            }
            numCache = { a, derivs: d };
            return d;
        }
        return {
            func: Math.tan,
            getTerm: (n, x, a) => {
                const t0 = Math.tan(a);
                if (!isFinite(t0)) return { val: 0, text: "" };
                const derivs = getDerivs(a, Math.max(n+1, 2));
                const deriv = derivs[n] ?? 0;
                const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                const ps = getTanPolys(Math.max(n+1, 2));
                const polyStr = formatPolyTan(ps[n]);
                let text = "";
                if (n === 0) {
                    text = " + tan(a)";
                } else {
                    const xPart = n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                    const numer = polyStr === "1" ? xPart : `(${polyStr})·${xPart}`;
                    const denom = n === 1 ? "" : `${n}!`;
                    text = denom
                        ? ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`
                        : ` + ${numer}`;
                }
                return { val, text };
            }
        };
    })(),

    sqrt: {
        // f^(n)(a) = c_num/c_den · (1+a)^(1/2-n)
        // c_num = product_{j=0}^{n-1}(1-2j), c_den = 2^n
        // 表示: c_num·(x-a)^n / (c_den·n!·√((1+a)^(2n-1)))
        func: (x) => Math.sqrt(1 + x),
        getTerm: (n, x, a) => {
            if (1 + a <= 0) return { val: 0, text: "" };
            // 有理係数を整数で計算 (GCD約分)
            let cNum = 1, cDen = Math.pow(2, n);
            for (let j = 0; j < n; j++) cNum *= (1 - 2*j);
            const g = gcd(Math.abs(cNum), cDen);
            const rNum = cNum / g, rDen = cDen / g;
            const deriv = (cNum / cDen) * Math.pow(1 + a, 0.5 - n);
            const val = (deriv / factorial(n)) * Math.pow(x - a, n);

            let text = "";
            if (n === 0) {
                text = " + √(1+a)";
            } else {
                const signStr = rNum >= 0 ? " + " : " - ";
                const absNum = Math.abs(rNum);
                const xPart = n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                const sqrtExp = 2*n - 1;
                const sqrtPart = sqrtExp === 1 ? "√(1+a)" : `√((1+a)<sup>${sqrtExp}</sup>)`;
                const denomFact = factorial(n);
                const denomNum = rDen * denomFact;
                const fullDenom = denomNum === 1 ? sqrtPart : `${denomNum}·${sqrtPart}`;
                const fullNum = absNum === 1 ? xPart : `${absNum}·${xPart}`;
                text = `${signStr}<span class="frac"><span class="frac-top">${fullNum}</span><span class="frac-bottom">${fullDenom}</span></span>`;
            }
            return { val, text };
        }
    },

    gauss: {
       // f^(n)(a) = (-1)^n · Hₙ(a) · e^(-a²)
       func: (x) => Math.exp(-x * x),
       getTerm: (n, x, a) => {
           const ea2 = Math.exp(-a * a);
           const hs = getHermitePolys(Math.max(n + 1, 2));
           // (-1)^n を Hₙ の係数に折り込む
           const signN = (n % 2 === 0) ? 1 : -1;
           const hSigned = pScale(hs[n], signN);
           const deriv = hSigned.reduce((s, c, i) => s + c * Math.pow(a, i), 0) * ea2;
           const val = (deriv / factorial(n)) * Math.pow(x - a, n);

           let text = "";
           if (Math.abs(a) < 0.001) {
               // マクローリン (a=0): 偶数項のみ、H₂ₖ(0) = (-1)^k (2k)!/k! だが係数は整理済み
               if (n % 2 !== 0) return { val: 0, text: "" };
               const k = n / 2;
               const sv = (k % 2 === 0) ? 1 : -1;
               const signStr = sv > 0 ? " + " : " - ";
               if (n === 0) {
                   text = " + 1";
               } else if (k === 1) {
                   text = ` - x<sup>2</sup>`;
               } else {
                   text = `${signStr}<span class="frac"><span class="frac-top">x<sup>${n}</sup></span><span class="frac-bottom">${k}!</span></span>`;
               }
           } else {
               // テイラー (a≠0): (-1)^n · Hₙ(a) · e^(-a²) / n! · (x-a)^n
               const polyStr = formatPoly(hSigned);
               const xPart = n === 0 ? "" : n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
               const signStr = deriv >= 0 ? " + " : " - ";
               if (n === 0) {
                   text = ` + e<sup>-a²</sup>`;
               } else {
                   const numer = `(${polyStr})·e<sup>-a²</sup>·${xPart}`;
                   const denom = n === 1 ? "" : `${n}!`;
                   text = denom
                       ? ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`
                       : ` + ${numer}`;
               }
           }
           return { val, text };
       }
   },

        inv2: (() => {
        // f = 1/(1+x²) = arctan'(x)
        // f^(n)(a) = p_n(a) / (1+a²)^(n+1)
        // 漸化式: p_{n+1} = -(2n+2)a·p_n - n(n+1)·p_{n-1}·(1+a²)
        let inv2PolyCache = null;
        function getInv2Polys(maxN) {
            if (inv2PolyCache && inv2PolyCache.length > maxN) return inv2PolyCache;
            const ps = [[1], [0, -2]]; // p0=1, p1=-2a
            for (let n = 1; n < maxN; n++) {
                const t1 = pScale(pMulA(ps[n]), -(2*n+2));
                const t2 = pScale(pMul1pA2(ps[n-1]), -n*(n+1));
                ps.push(pAdd(t1, t2));
            }
            inv2PolyCache = ps;
            return ps;
        }
        let numCache = { a: null, derivs: [] };
        function getDerivs(a, maxN) {
            if (numCache.a === a && numCache.derivs.length > maxN) return numCache.derivs;
            const a2 = 1 + a * a;
            const d = [1/a2, -2*a/(a2*a2)];
            for (let n = 1; n < maxN; n++) {
                d[n+1] = (-(2*n+2)*a*d[n] - n*(n+1)*d[n-1]) / a2;
            }
            numCache = { a, derivs: d };
            return d;
        }
        return {
            func: (x) => 1 / (1 + x * x),
            getTerm: (n, x, a) => {
                if (Math.abs(a) < 0.001) {
                    // マクローリン: 偶数項のみ (-1)^k, n=2k
                    if (n % 2 !== 0) return { val: 0, text: "" };
                    const k = n / 2;
                    const signVal = (k % 2 === 0) ? 1 : -1;
                    const val = signVal * Math.pow(x, n);
                    const signStr = signVal > 0 ? " + " : " - ";
                    const text = n === 0 ? " + 1" : `${signStr}x<sup>${n}</sup>`;
                    return { val, text };
                } else {
                    // テイラー: p_n(a) / (1+a²)^(n+1)
                    const derivs = getDerivs(a, Math.max(n+1, 2));
                    const deriv = derivs[n] ?? 0;
                    const val = (deriv / factorial(n)) * Math.pow(x - a, n);

                    const ps = getInv2Polys(Math.max(n+1, 2));
                    const polyStr = formatPoly(ps[n]); // arctan用と共用
                    let text = "";
                    const xPart = n === 0 ? "" : n === 1 ? "(x - a)" : `(x - a)<sup>${n}</sup>`;
                    const denom1 = n === 0 ? "(1+a²)" : n === 1 ? "(1+a²)²" : `(1+a²)<sup>${n+1}</sup>`;
                    const denom = n <= 1 ? denom1 : `${n}!·${denom1}`;
                    const numer = n === 0 ? polyStr : `(${polyStr})·${xPart}`;
                    text = ` + <span class="frac"><span class="frac-top">${numer}</span><span class="frac-bottom">${denom}</span></span>`;
                    return { val, text };
                }
            }
        };
    })(),
};

/**
 * App Elements & Initialization
 */
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
const nSlider = document.getElementById('nSlider');
const aSlider = document.getElementById('aSlider');
const zoomSlider = document.getElementById('zoomSlider');
const funcSelect = document.getElementById('funcSelect');
const formulaText = document.getElementById('formula-text');
const nVal = document.getElementById('nVal');
const aVal = document.getElementById('aVal');
const zoomVal = document.getElementById('zoomVal');
const langRadios = document.getElementsByName('lang');

// Labels
const elLblFunc = document.getElementById('lbl-func');
const elLblCenter = document.getElementById('lbl-center');
const elLblTerms = document.getElementById('lbl-terms');
const elLblZoom = document.getElementById('lbl-zoom');
const elLegendOriginal = document.getElementById('legend-original');
const elLegendApprox = document.getElementById('legend-approx');
const elLegendCenter = document.getElementById('legend-center');

const danceBtn = document.getElementById('dance-btn');

let audioCtx = null;
let width, height;

function updateLanguage(lang) {
    currentLang = lang;
    const t = translations[lang];
    elLblFunc.innerText = t.lblFunc;
    elLblCenter.innerText = t.lblCenter;
    elLblTerms.innerText = t.lblTerms;
    elLblZoom.innerText = t.lblZoom;

    danceBtn.innerText = t.btnDance;

    elLegendOriginal.innerText = t.legendOriginal;
    elLegendApprox.innerText = t.legendApprox;
    elLegendCenter.innerText = t.legendCenter;

    const currentVal = funcSelect.value;
    funcSelect.innerHTML = "";
    for (let key in functions) {
        let opt = document.createElement('option');
        opt.value = key; opt.text = t.funcs[key];
        funcSelect.appendChild(opt);
    }
    funcSelect.value = functions[currentVal] ? currentVal : "sin";
}

langRadios.forEach(radio => radio.addEventListener('change', (e) => updateLanguage(e.target.value)));
updateLanguage('ja');

function playSound(n) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const baseFreq = 261.63; 
    const semiTones = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21, 24, 26, 28, 31, 33, 36]; 
    const cycle = Math.floor(n / semiTones.length);
    const index = n % semiTones.length;
    const note = semiTones[index] + (cycle * 2); 
    osc.frequency.setValueAtTime(baseFreq * Math.pow(2, note/12), audioCtx.currentTime);
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
}

function toCanvasX(x, rangeX) { return (x / rangeX) * (width / 2) + (width / 2); }
function toCanvasY(y, rangeX) { const scale = (width / 2) / rangeX; return (height / 2) - (y * scale); }

function draw() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    
    const rangeX = parseFloat(zoomSlider.value);
    const nMax = parseInt(nSlider.value);
    const a = parseFloat(aSlider.value);
    const funcKey = funcSelect.value;
    const currentFunc = functions[funcKey];
    
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
    ctx.fillRect(0, 0, width, height);
    
    const scale = (width / 2) / rangeX;
    const rangeY = (height / 2) / scale;

    // Grid X
    ctx.font = "12px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "top";
    for (let i = Math.floor(-rangeX); i <= rangeX; i++) {
        const cx = toCanvasX(i, rangeX);
        ctx.beginPath();
        if (i === 0) { ctx.lineWidth = 3; ctx.strokeStyle = "var(--axis)"; }
        else if (i%5===0) { ctx.lineWidth = 1.5; ctx.strokeStyle = "#555"; }
        else { ctx.lineWidth = 0.5; ctx.strokeStyle = "#333"; }
        ctx.moveTo(cx, 0); ctx.lineTo(cx, height); ctx.stroke();
        if (i !== 0 && i % 2 === 0) { ctx.fillStyle = "#888"; ctx.fillText(i, cx, height/2 + 5); }
    }
    // Grid Y
    for (let i = Math.floor(-rangeY); i <= rangeY; i++) {
        const cy = toCanvasY(i, rangeX);
        ctx.beginPath();
        if (i === 0) { ctx.lineWidth = 3; ctx.strokeStyle = "var(--axis)"; }
        else if (i%5===0) { ctx.lineWidth = 1.5; ctx.strokeStyle = "#555"; }
        else { ctx.lineWidth = 0.5; ctx.strokeStyle = "#333"; }
        ctx.moveTo(0, cy); ctx.lineTo(width, cy); ctx.stroke();
    }
    // Center Line
    const cxA = toCanvasX(a, rangeX);
    if (cxA >= 0 && cxA <= width) {
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.lineWidth = 2;
        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--center');
        ctx.moveTo(cxA, 0); ctx.lineTo(cxA, height); ctx.stroke(); ctx.setLineDash([]);
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--center');
        ctx.fillText(`a=${a}`, cxA + 5, height/2 - 20);
    }

    // Original
    ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--target'); ctx.lineWidth = 3;
    let first = true;
    for (let px = 0; px < width; px+=3) {
        const x = (px - width/2) / scale;
        if (funcKey === 'log' && x <= -1) continue;
        if (funcKey === 'inv' && Math.abs(x - 1) < 0.05) { first = true; continue; }
        const y = currentFunc.func(x);
        if (!isFinite(y) || Math.abs(y) > rangeY * 2) { first = true; continue; }//NaN ガード（sqrt の定義域外対策）
        const py = toCanvasY(y, rangeX);
        if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
    }
    ctx.stroke();

    // Approx
    ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--accent'); ctx.lineWidth = 3;
    first = true;
    
    // Formula Text Gen
    let formulaHtml = `P(x) ≈ `;
    let isFirstTerm = true;

    for (let px = 0; px < width; px+=3) {
        const x = (px - width/2) / scale;
        let yApprox = 0;
        
        for (let k = 0; k <= nMax; k++) {
             let t = currentFunc.getTerm(k, x, a);
             yApprox += t.val;
        }
        
        if (!isFinite(yApprox) || Math.abs(yApprox) > rangeY * 2) { first = true; continue; }//NaN ガード（sqrt の定義域外対策）

        const py = toCanvasY(yApprox, rangeX);
        if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
    }
    ctx.stroke();
    
    for (let k = 0; k <= nMax; k++) {
        let t = currentFunc.getTerm(k, 0, a);
        if (t.text) {
            let txt = t.text;
            if (isFirstTerm && txt.trim().startsWith('+')) txt = txt.replace('+','');
            if (isFirstTerm && txt.trim().startsWith(' -')) txt = txt.trim(); // 最初の項のマイナス詰め
            formulaHtml += txt;
            isFirstTerm = false;
        }
    }
    if (isFirstTerm) formulaHtml += "0";
    formulaText.innerHTML = formulaHtml;
}



// --- Animation ---
const playBtn = document.getElementById('play-btn');
let animTimer = null;
let userTouching = false;

function startAnim() {
    if (animTimer) return;
    playBtn.textContent = '⏸';
    playBtn.classList.add('playing');
    animTimer = setInterval(() => {
        if (userTouching) return; // スライダー操作中はスキップ（止めない）
        let cur = parseInt(nSlider.value);
        if (cur >= parseInt(nSlider.max)) {
            cur = 0; // ループ再生
        } else {
            cur++;
        }
        nSlider.value = cur;
        nVal.textContent = cur;
        playSound(cur);
        requestAnimationFrame(draw);
    }, 300); // 300ms間隔（お好みで調整）
}

function stopAnim() {
    clearInterval(animTimer);
    animTimer = null;
    playBtn.textContent = '▶';
    playBtn.classList.remove('playing');
}

playBtn.addEventListener('click', () => {
    animTimer ? stopAnim() : startAnim();
});

// スライダーを触っている間はアニメのコマをスキップ（停止はしない）
nSlider.addEventListener('mousedown', () => userTouching = true);
nSlider.addEventListener('touchstart', () => userTouching = true);
nSlider.addEventListener('mouseup', () => userTouching = false);
nSlider.addEventListener('touchend', () => userTouching = false);


// Dance with Maclaurin (Reset a to 0)
danceBtn.addEventListener('click', () => {
    aSlider.value = 0;
    aVal.textContent = "0";
    requestAnimationFrame(draw);
});

// Events
nSlider.addEventListener('input', (e) => { nVal.textContent = e.target.value; playSound(parseInt(e.target.value)); requestAnimationFrame(draw); });
aSlider.addEventListener('input', (e) => { aVal.textContent = e.target.value; requestAnimationFrame(draw); });
zoomSlider.addEventListener('input', (e) => { zoomVal.textContent = "x: ±" + e.target.value; requestAnimationFrame(draw); });
funcSelect.addEventListener('change', () => { 
    nSlider.value = 1; nVal.textContent = 1; aSlider.value = 0; aVal.textContent = 0; 
    requestAnimationFrame(draw); 
});
window.addEventListener('resize', draw);

draw();
</script>


</body>
</html>