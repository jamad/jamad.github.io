<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-BIT PRECISION</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            /* スクロールバーを隠す */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        body::-webkit-scrollbar {
            display: none;
        }
        .pixelated {
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        .slider-thumb-red::-webkit-slider-thumb {
            background-color: #ef4444;
        }
        .slider-thumb-green::-webkit-slider-thumb {
            background-color: #22c55e;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            transition: background-color 0.15s ease-in-out;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ef4444; 
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            border: none;
        }
        input[type="range"]:disabled::-moz-range-thumb {
            cursor: not-allowed;
        }
        
        /* Hue Slider */
        #hueSlider {
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, 
                hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), 
                hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%)
            );
        }
        #hueSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
            border: 2px solid #1e293b;
        }
        #hueSlider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
            border: 2px solid #1e293b;
        }

        .toast {
            animation: fade-in-slide-down 0.3s ease-out forwards, fade-out-slide-up 0.3s ease-in 2.2s forwards;
        }

        @keyframes fade-in-slide-down {
            from { opacity: 0; transform: translate(-50%, -10px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes fade-out-slide-up {
            from { opacity: 1; transform: translate(-50%, 0); }
            to { opacity: 0; transform: translate(-50%, -10px); }
        }
        
        #stampCanvas {
            background-image: repeating-conic-gradient(#cbd5e1 0% 25%, #f8fafc 0% 50%);
            background-size: 16px 16px; 
        }

        /* SVG Marching Ants */
        @keyframes ants {
            to { stroke-dashoffset: -8; }
        }
        .selection-ants {
            animation: ants 0.5s linear infinite;
        }
    </style>
</head>
<body class="min-h-screen bg-slate-900 text-slate-200 flex flex-col font-mono selection:bg-blue-500/30">

    <div id="toast" class="fixed top-20 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg z-50 flex items-center gap-2 toast hidden">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check"><path d="M4 12.6V16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2"></path><path d="m9 12 2 2 4-4"></path></svg>
        <span id="toast-msg"></span>
    </div>

    <header class="bg-slate-800 p-4 border-b border-slate-700 flex justify-between items-center shadow-md">
        <h1 class="text-xl font-bold tracking-wider text-blue-300">8-BIT PRECISION</h1>
        <div class="flex gap-2 items-center">
            <button id="openBtn" class="p-2 bg-slate-700 rounded hover:bg-slate-600 text-blue-300 transition-colors" title="Open Image (Ctrl+O)">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/><path d="M2 10h20"/></svg>
            </button>
            <input type="file" id="fileInput" accept="image/*" class="hidden">
            
            <button id="downloadBtn" class="p-2 bg-slate-700 rounded hover:bg-slate-600 text-blue-300 transition-colors" title="Download Image (Ctrl+S)">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" x2="12" y1="15" y2="3"></line></svg>
            </button>
            <div class="w-px h-6 bg-slate-600 mx-1"></div>
            <button id="undoBtn" class="p-2 bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-50 transition-colors" title="Undo (Ctrl+Z)" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
            </button>
            <button id="redoBtn" class="p-2 bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-50 transition-colors" title="Redo (Ctrl+Y)" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>
            </button>
            <div class="w-px h-6 bg-slate-600 mx-1"></div>
            <button id="clearBtn" class="p-2 bg-red-900/50 text-red-300 rounded hover:bg-red-800/50 transition-colors" title="Clear Canvas">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg>
            </button>
        </div>
    </header>

    <main class="flex-1 flex flex-col md:flex-row p-4 gap-6 overflow-hidden">
        
        <aside class="flex md:flex-col gap-2 bg-slate-800 p-3 rounded-xl border border-slate-700 justify-start items-center flex-wrap shrink-0 shadow-lg md:w-24 overflow-y-auto">
            <div class="w-full flex flex-wrap justify-center gap-2">
                <button data-tool="pen" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-blue-600 text-white shadow-[0_0_10px_rgba(37,99,235,0.5)]" title="Pen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Pen</span>
                </button>
                <button data-tool="line" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Snap Line">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Line</span>
                </button>
                <button data-tool="circle" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Snap Circle">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Circle</span>
                </button>
                <button data-tool="fill" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Fill Area">
                    <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19.1 11.2l-5.6-7.5c-.8-1-2.3-1.2-3.3-.4l-5.8 4.3c-1 .8-1.2 2.3-.4 3.3l5.6 7.5c.8 1 2.3 1.2 3.3.4l5.8-4.3c1-.8 1.2-2.3.4-3.3z"></path>
                        <path d="M10 5l4 5.5"></path><path d="M4 14l-1.5 1.5c-1 1-1 2.6 0 3.6 1 1 2.6 1 3.6 0l1.5-1.5"></path>
                        <circle cx="4.5" cy="20.5" r="1" fill="currentColor" stroke="none"></circle>
                    </svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Fill</span>
                </button>
                <button data-tool="text" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Text">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" x2="15" y1="20" y2="20"></line><line x1="12" x2="12" y1="4" y2="20"></line></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Text</span>
                </button>
                <button data-tool="select" class="w-[calc(50%-4px)] md:w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Select & Move (WASD)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" stroke-dasharray="4 4"/></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Select</span>
                </button>
                <button data-tool="stamp" class="w-full p-2 md:p-3 rounded-lg flex flex-col items-center justify-center gap-1 transition-all bg-slate-700 hover:bg-slate-600 text-slate-300" title="Place Stamp">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"/><path d="m4.93 10.93 1.41 1.41"/><path d="M2 18h20"/><path d="M20 22H4a2 2 0 0 1-2-2v-2h22v2a2 2 0 0 1-2 2Z"/><path d="M8 22v-4"/><path d="M16 22v-4"/><path d="m19.07 10.93-1.41 1.41"/></svg>
                    <span class="text-[9px] hidden md:block text-center leading-tight">Stamp</span>
                </button>
            </div>
            
            <div class="w-full flex flex-wrap justify-center gap-1 mt-2 mb-2" id="brush-sizes">
                <button data-size="1" class="w-8 h-8 flex items-center justify-center rounded text-xs transition-colors bg-blue-500 text-white font-bold" title="Brush Size: 1px">1</button>
                <button data-size="2" class="w-8 h-8 flex items-center justify-center rounded text-xs transition-colors bg-slate-700 text-slate-400 hover:bg-slate-600" title="Brush Size: 2px">2</button>
                <button data-size="4" class="w-8 h-8 flex items-center justify-center rounded text-xs transition-colors bg-slate-700 text-slate-400 hover:bg-slate-600" title="Brush Size: 4px">4</button>
                <button data-size="8" class="w-8 h-8 flex items-center justify-center rounded text-xs transition-colors bg-slate-700 text-slate-400 hover:bg-slate-600" title="Brush Size: 8px">8</button>
            </div>

            <div class="w-full h-px bg-slate-600 my-1"></div>

            <!-- Stamp Editor (8x8) -->
            <div class="w-full flex flex-col items-center gap-1 my-2 shrink-0">
                <span class="text-[9px] text-slate-400 font-bold tracking-wider">STAMP 8x8</span>
                <canvas id="stampCanvas" width="8" height="8" class="w-16 h-16 border-2 border-slate-600 pixelated cursor-crosshair shadow-lg touch-none rounded-sm"></canvas>
                <button id="clearStampBtn" class="text-[9px] bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded text-slate-300 w-full transition-colors">CLEAR</button>
            </div>

            <div class="w-full h-px bg-slate-600 my-1"></div>
            
            <button id="toggleGridBtn" class="w-full p-2 rounded-lg flex flex-col items-center justify-center transition-all bg-slate-600 text-white" title="Toggle Grid (8x8)">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="7" height="7" x="3" y="3"></rect><rect width="7" height="7" x="14" y="3"></rect><rect width="7" height="7" x="14" y="14"></rect><rect width="7" height="7" x="3" y="14"></rect></svg>
                <span class="text-[9px] hidden md:block mt-1">Grid</span>
            </button>
        </aside>

        <div class="flex-1 flex flex-col items-center justify-center relative touch-none">
            
            <!-- Text Input -->
            <div id="textInputContainer" class="w-full max-w-[min(90vw,70vh)] flex gap-2 p-2 bg-blue-600/90 backdrop-blur-sm rounded-lg shadow-[0_0_20px_rgba(37,99,235,0.6)] border border-blue-400 mb-4 hidden z-20 transition-all">
                <input 
                    type="text" 
                    id="textInput"
                    class="flex-1 bg-slate-900/90 border border-transparent rounded px-3 py-2 text-white font-mono uppercase tracking-widest focus:outline-none focus:border-white/50 placeholder-slate-400"
                    placeholder="TYPE HERE..."
                    maxlength="15"
                    value="HELLO"
                />
            </div>

            <div class="relative bg-black shadow-2xl border-4 border-slate-800 rounded-sm overflow-hidden" 
                 style="width: min(90vw, 70vh); height: min(90vw, 70vh);">
                
                <div class="absolute inset-0 pointer-events-none"
                     style="background-image: repeating-conic-gradient(#334155 0% 25%, #1e293b 0% 50%); background-size: 16px 16px;"
                ></div>

                <canvas
                  id="pixelCanvas"
                  width="64"
                  height="64"
                  class="absolute top-0 left-0 w-full h-full cursor-none z-10 pixelated"
                  style="touch-action: none;"
                ></canvas>

                <div 
                  id="gridOverlay"
                  class="absolute inset-0 pointer-events-none opacity-40 z-20 mix-blend-difference"
                  style="background-size: calc(100% / (64 / 8)) calc(100% / (64 / 8)); background-image: linear-gradient(to right, #94a3b8 1px, transparent 1px), linear-gradient(to bottom, #94a3b8 1px, transparent 1px);" 
                ></div>

                <div id="symXLine" class="absolute top-0 w-px h-full bg-red-500 shadow-[0_0_5px_red] pointer-events-none z-10 hidden" style="left: 50%;"></div>
                <div id="symYLine" class="absolute left-0 h-px w-full bg-green-500 shadow-[0_0_5px_green] pointer-events-none z-10 hidden" style="top: 50%;"></div>
                
                <!-- SVG Selection Outline -->
                <svg id="selectionSvg" class="absolute top-0 left-0 w-full h-full pointer-events-none z-30 hidden" viewBox="0 0 64 64" preserveAspectRatio="none">
                    <rect id="selRectOuter" fill="none" stroke="black" stroke-width="1" vector-effect="non-scaling-stroke" />
                    <rect id="selRectInner" fill="none" stroke="white" stroke-width="1" stroke-dasharray="4 4" vector-effect="non-scaling-stroke" class="selection-ants" />
                </svg>
            </div>

            <!-- コントロールパネル -->
            <div class="w-full max-w-[min(90vw,70vh)] mt-6 flex flex-col gap-4 bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                <!-- シンメトリー -->
                <div class="flex flex-col gap-3 w-full">
                    <div class="flex items-center gap-4 w-full">
                        <button id="toggleSymX" class="flex items-center justify-center gap-2 p-2 rounded w-28 shrink-0 transition-colors bg-slate-700 text-slate-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3V21"></path><path d="M16 3V21"></path><path d="M12 21v-1a2 2 0 0 0-2-2H8c-2.7 0-4-1.3-4-4V8c0-2.7 1.3-4 4-4h2a2 2 0 0 0 2-2V3"></path><path d="M12 21v-1a2 2 0 0 1 2-2h2c2.7 0 4-1.3 4-4V8c0-2.7-1.3-4-4-4h-2a2 2 0 0 1-2-2V3"></path></svg>
                            <span class="text-[10px] font-bold">X-AXIS</span>
                        </button>
                        <input type="range" min="0" max="64" value="32" id="symXPos" class="flex-1 accent-red-500 disabled:opacity-30 slider-thumb-red" disabled>
                        <button id="resetSymX" class="p-1.5 rounded bg-slate-700 text-slate-400 hover:bg-slate-600 hover:text-white transition-colors disabled:opacity-30 disabled:hover:bg-slate-700 disabled:hover:text-slate-400" title="Reset to Center" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </button>
                    </div>
                    <div class="flex items-center gap-4 w-full">
                        <button id="toggleSymY" class="flex items-center justify-center gap-2 p-2 rounded w-28 shrink-0 transition-colors bg-slate-700 text-slate-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V21"></path><path d="M12 3V16"></path><path d="M4 12H2v-2a2 2 0 0 1 2-2h4c2.7 0 4 1.3 4 4v2c0 2.7-1.3 4-4 4H4a2 2 0 0 1-2-2v-2"></path><path d="M20 12H22v-2a2 2 0 0 0-2-2h-4c-2.7 0-4 1.3-4 4v2c0 2.7 1.3 4 4 4h4a2 2 0 0 0 2-2v-2"></path></svg>
                            <span class="text-[10px] font-bold">Y-AXIS</span>
                        </button>
                        <input type="range" min="0" max="64" value="32" id="symYPos" class="flex-1 accent-green-500 disabled:opacity-30 slider-thumb-green" disabled>
                        <button id="resetSymY" class="p-1.5 rounded bg-slate-700 text-slate-400 hover:bg-slate-600 hover:text-white transition-colors disabled:opacity-30 disabled:hover:bg-slate-700 disabled:hover:text-slate-400" title="Reset to Center" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </button>
                    </div>
                </div>

                <div class="w-full h-px bg-slate-700 my-1"></div>

                <!-- マスキング -->
                <div class="flex flex-col gap-3 w-full">
                    <div class="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-400"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                        <span class="text-[10px] text-slate-400 font-bold tracking-wider">PATTERN MASK</span>
                    </div>
                    
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-slate-400 w-12 font-bold tracking-wider">H-LINE</span>
                            <div class="flex bg-slate-900 rounded border border-slate-600 overflow-hidden">
                                <label class="cursor-pointer"><input type="radio" name="maskHorizontal" value="none" class="peer sr-only" checked><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">NONE</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskHorizontal" value="even" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">EVEN</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskHorizontal" value="odd" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">ODD</div></label>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-slate-400 w-12 font-bold tracking-wider">V-LINE</span>
                            <div class="flex bg-slate-900 rounded border border-slate-600 overflow-hidden">
                                <label class="cursor-pointer"><input type="radio" name="maskVertical" value="none" class="peer sr-only" checked><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">NONE</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskVertical" value="even" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">EVEN</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskVertical" value="odd" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">ODD</div></label>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-slate-400 w-12 font-bold tracking-wider">CHECKER</span>
                            <div class="flex bg-slate-900 rounded border border-slate-600 overflow-hidden">
                                <label class="cursor-pointer"><input type="radio" name="maskChecker" value="none" class="peer sr-only" checked><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">NONE</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskChecker" value="even" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">EVEN</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskChecker" value="odd" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">ODD</div></label>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-slate-400 w-12 font-bold tracking-wider">SLASH /</span>
                            <div class="flex bg-slate-900 rounded border border-slate-600 overflow-hidden">
                                <label class="cursor-pointer"><input type="radio" name="maskSlash" value="none" class="peer sr-only" checked><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">NONE</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskSlash" value="0" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">0</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskSlash" value="1" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">1</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskSlash" value="2" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">2</div></label>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-slate-400 w-12 font-bold tracking-wider">B-SLASH \</span>
                            <div class="flex bg-slate-900 rounded border border-slate-600 overflow-hidden">
                                <label class="cursor-pointer"><input type="radio" name="maskBackslash" value="none" class="peer sr-only" checked><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">NONE</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskBackslash" value="0" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">0</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskBackslash" value="1" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">1</div></label>
                                <label class="cursor-pointer border-l border-slate-600"><input type="radio" name="maskBackslash" value="2" class="peer sr-only"><div class="px-2 py-1 text-[9px] text-slate-400 peer-checked:bg-blue-600 peer-checked:text-white hover:bg-slate-700">2</div></label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <aside class="flex md:flex-col gap-3 bg-slate-800 p-3 rounded-xl border border-slate-700 justify-start overflow-x-auto shadow-lg shrink-0 items-center md:w-24" id="paletteSide">
            <div class="flex flex-col items-center w-full gap-1 mb-2 shrink-0">
                <span class="text-[10px] text-slate-400 font-bold tracking-wider">HUE SHIFT</span>
                <input type="range" id="hueSlider" min="0" max="360" value="207" class="w-full h-2 rounded-lg cursor-pointer mt-1">
            </div>
            <div id="palette" class="flex md:flex-col gap-3 items-center w-full">
                <!-- Palette colors will be generated by JS -->
            </div>
        </aside>

    </main>

    <script>
        // --- 設定・定数 ---
        const CANVAS_SIZE = 64;

        // 以前の美しい階調カーブを持つ8色に戻す
        const BASE_COLORS = [
            null, // 0: White (固定)
            {h: 200, s: 100, l: 96}, // 1
            {h: 201, s: 77, l: 86}, // 2
            {h: 203, s: 83, l: 76}, // 3
            {h: 205, s: 80, l: 66}, // 4 
            {h: 207, s: 73, l: 57}, // 5
            {h: 209, s: 62, l: 50}, // 6
            {h: 211, s: 61, l: 43}, // 7
            null, // 8: Black (固定)
            null  // 9: Transparent
        ];

        const BASE_HUE = 207; 
        let hueShift = 0;

        const PALETTE = [
            '#FFFFFF',
            '#ebf8ff', '#bee3f8', '#90cdf4', '#63b3ed', '#4299e1', '#3182ce', '#2b6cb0',
            '#000000', 
            'transparent' 
        ];

        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
        }

        function hexToRgb(hex) {
            if (hex === 'transparent') return {r:0, g:0, b:0};
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            return {r, g, b};
        }

        const FONT_5x3 = {
            'A': [0,1,0, 1,0,1, 1,1,1, 1,0,1, 1,0,1],
            'B': [1,1,0, 1,0,1, 1,1,0, 1,0,1, 1,1,0],
            'C': [0,1,1, 1,0,0, 1,0,0, 1,0,0, 0,1,1],
            'D': [1,1,0, 1,0,1, 1,0,1, 1,0,1, 1,1,0],
            'E': [1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,1,1],
            'F': [1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,0,0],
            'G': [0,1,1, 1,0,0, 1,0,1, 1,0,1, 0,1,1],
            'H': [1,0,1, 1,0,1, 1,1,1, 1,0,1, 1,0,1],
            'I': [1,1,1, 0,1,0, 0,1,0, 0,1,0, 1,1,1],
            'J': [0,0,1, 0,0,1, 0,0,1, 1,0,1, 0,1,0],
            'K': [1,0,1, 1,0,1, 1,1,0, 1,0,1, 1,0,1], 
            'L': [1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,1,1],
            'M': [1,0,1, 1,1,1, 1,0,1, 1,0,1, 1,0,1],
            'N': [1,1,0, 1,0,1, 1,0,1, 1,0,1, 1,0,1],
            'O': [1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], 
            'P': [1,1,0, 1,0,1, 1,1,0, 1,0,0, 1,0,0],
            'Q': [1,1,1, 1,0,1, 1,0,1, 1,1,1, 0,0,1], 
            'R': [1,1,0, 1,0,1, 1,1,0, 1,0,1, 1,0,1],
            'S': [0,1,1, 1,0,0, 0,1,0, 0,0,1, 1,1,0],
            'T': [1,1,1, 0,1,0, 0,1,0, 0,1,0, 0,1,0],
            'U': [1,0,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], 
            'V': [1,0,1, 1,0,1, 1,0,1, 1,0,1, 0,1,0],
            'W': [1,0,1, 1,0,1, 1,1,1, 1,1,1, 1,0,1], 
            'X': [1,0,1, 1,0,1, 0,1,0, 1,0,1, 1,0,1],
            'Y': [1,0,1, 1,0,1, 0,1,0, 0,1,0, 0,1,0],
            'Z': [1,1,1, 0,0,1, 0,1,0, 1,0,0, 1,1,1],
            '0': [0,1,0, 1,0,1, 1,0,1, 1,0,1, 0,1,0],
            '1': [0,1,0, 1,1,0, 0,1,0, 0,1,0, 1,1,1],
            '2': [1,1,0, 0,0,1, 0,1,0, 1,0,0, 1,1,1],
            '3': [1,1,0, 0,0,1, 0,1,0, 0,0,1, 1,1,0],
            '4': [1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1],
            '5': [1,1,1, 1,0,0, 1,1,0, 0,0,1, 1,1,0],
            '6': [0,1,1, 1,0,0, 1,1,0, 1,0,1, 0,1,0],
            '7': [1,1,1, 0,0,1, 0,0,1, 0,1,0, 0,1,0],
            '8': [0,1,0, 1,0,1, 0,1,0, 1,0,1, 0,1,0],
            '9': [0,1,0, 1,0,1, 0,1,1, 0,0,1, 1,1,0],
            ' ': [0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0]
        };

        const ALLOWED_TANGENTS = [0, 1/8, 1/6, 1/4, 1/3, 1/2, 1, 2, 3, 4, 6, 8, Infinity];
        const ALLOWED_ANGLES = ALLOWED_TANGENTS.map(t => Math.atan(t));
        const ALLOWED_RADII = [1, 2, 3, 4, 5, 7, 9, 12, 16, 20, 25, 32];
        const BRUSH_SIZES = [1, 2, 4, 8];

        // --- DOM要素の参照 ---
        const pixelCanvas = document.getElementById('pixelCanvas');
        const ctx = pixelCanvas.getContext('2d');
        const stampCanvas = document.getElementById('stampCanvas');
        const stampCtx = stampCanvas.getContext('2d');
        const selectionSvg = document.getElementById('selectionSvg');
        const selRectOuter = document.getElementById('selRectOuter');
        const selRectInner = document.getElementById('selRectInner');
        
        const toolButtons = document.querySelectorAll('aside button[data-tool]');
        const brushSizeButtons = document.querySelectorAll('#brush-sizes button');
        const paletteContainer = document.getElementById('palette');
        const textInputContainer = document.getElementById('textInputContainer');
        const textInput = document.getElementById('textInput');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const gridOverlay = document.getElementById('gridOverlay');
        const symXLine = document.getElementById('symXLine');
        const symYLine = document.getElementById('symYLine');
        const toggleSymXBtn = document.getElementById('toggleSymX');
        const symXPosSlider = document.getElementById('symXPos');
        const resetSymXBtn = document.getElementById('resetSymX');
        const toggleSymYBtn = document.getElementById('toggleSymY');
        const symYPosSlider = document.getElementById('symYPos');
        const resetSymYBtn = document.getElementById('resetSymY');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const openBtn = document.getElementById('openBtn');
        const fileInput = document.getElementById('fileInput');
        const clearStampBtn = document.getElementById('clearStampBtn');
        const toastElement = document.getElementById('toast');
        const toastMsgElement = document.getElementById('toast-msg');
        const hueSlider = document.getElementById('hueSlider');

        // --- 状態管理 ---
        let currentTool = 'pen';
        let brushSize = 1;
        let colorIndex = 4; 
        let symXEnabled = false;
        let symYEnabled = false;
        let symXPos = 32;
        let symYPos = 32;
        let showGrid = true;
        let currentTextInput = "HELLO";

        let pixelData = new Uint8Array(CANVAS_SIZE * CANVAS_SIZE); 
        let previewData = new Uint8Array(CANVAS_SIZE * CANVAS_SIZE); 
        
        // Stamp Data (8x8)
        let stampData = new Uint8Array(8 * 8).fill(9); // 9=transp
        let internalClipboard = null; // {data, w, h}

        // Select Tool State
        let selectionState = 'none'; 
        let selRect = {x:0, y:0, w:0, h:0};
        let selData = null; 
        let selStartPos = {x:0, y:0};
        let selDragStartPos = {x:0, y:0};
        let selOriginalRect = {x:0, y:0};
        let isDraggingSelection = false;

        let isDrawing = false;
        let startPos = { x: 0, y: 0 };
        let lastPos = { x: -1, y: -1 };
        let lastPreviewKey = ''; 
        let hoverPos = null; 
        let isDrawingStamp = false;

        let history = [];
        let historyIndex = -1;
        let audioCtx = null;

        let lockedColors = new Set();
        let maskHorizontal = 'none';
        let maskVertical = 'none';
        let maskChecker = 'none';
        let maskSlash = 'none';
        let maskBackslash = 'none';

        // --- 初期化処理 ---
        function init() {
            updatePaletteColors(); 
            pixelData.fill(0); 
            history = [new Uint8Array(pixelData)]; 
            historyIndex = 0;

            renderPalette();
            renderStampCanvas();
            renderCanvas();
            updateHistoryState();
            setupEventListeners();
            updateToolUI();
            updateBrushSizeUI();
            updateSymmetryUI();
            updateGridUI();
            updateTextInputUI();
        }

        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            const now = ctx.currentTime;

            if (type === 'draw') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.03);
                gain.gain.setValueAtTime(0.02, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                osc.start(now); osc.stop(now + 0.03);
            } else if (type === 'snap') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'click') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'undo') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
        }

        function showToast(msg) {
            toastMsgElement.textContent = msg;
            toastElement.classList.remove('hidden');
            clearTimeout(toastElement.timeoutId);
            toastElement.timeoutId = setTimeout(() => {
                toastElement.classList.add('hidden');
            }, 2500);
        }

        function updateHistoryState() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function saveHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(new Uint8Array(pixelData));
            if (history.length > 50) history.shift(); 
            else historyIndex++;
            updateHistoryState();
        }

        function handleUndo() {
            if (historyIndex > 0) {
                if (selectionState !== 'none') commitSelection();
                historyIndex--;
                pixelData = new Uint8Array(history[historyIndex]);
                renderCanvas();
                updateHistoryState();
                playSound('undo');
            }
        }

        function handleRedo() {
            if (historyIndex < history.length - 1) {
                if (selectionState !== 'none') commitSelection();
                historyIndex++;
                pixelData = new Uint8Array(history[historyIndex]);
                renderCanvas();
                updateHistoryState();
                playSound('click');
            }
        }

        // --- マスキングロジック ---
        function isPixelLocked(x, y) {
            if (maskHorizontal === 'even' && y % 2 === 0) return true;
            if (maskHorizontal === 'odd' && y % 2 === 1) return true;
            if (maskVertical === 'even' && x % 2 === 0) return true;
            if (maskVertical === 'odd' && x % 2 === 1) return true;
            if (maskChecker === 'even' && (x + y) % 2 === 0) return true;
            if (maskChecker === 'odd' && (x + y) % 2 === 1) return true;
            
            if (maskSlash !== 'none') {
                if ((x + y) % 3 !== parseInt(maskSlash)) return true;
            }
            if (maskBackslash !== 'none') {
                if ((x - y + CANVAS_SIZE * 10) % 3 !== parseInt(maskBackslash)) return true;
            }

            const currentColorIdx = pixelData[y * CANVAS_SIZE + x];
            if (lockedColors.has(currentColorIdx)) return true;

            return false;
        }

        // --- 色相シフトロジック ---
        function updatePaletteColors() {
            let currentHue = parseInt(hueSlider.value);
            hueShift = currentHue - BASE_HUE;
            for (let i = 1; i <= 7; i++) {
                let c = BASE_COLORS[i];
                if (c) {
                    let newH = (c.h + hueShift + 360) % 360;
                    PALETTE[i] = hslToHex(newH, c.s, c.l);
                }
            }
            document.querySelectorAll('#palette button').forEach(btn => {
                let idx = parseInt(btn.dataset.colorIndex);
                if (idx > 0 && idx < 8) {
                    btn.style.backgroundColor = PALETTE[idx];
                    btn.title = `Color ${idx} (${PALETTE[idx]})`;
                }
            });
            renderStampCanvas(); 
        }

        // --- Select Tool Logic ---
        function commitSelection() {
            if (selectionState === 'selected' && selData) {
                for(let dy=0; dy<selRect.h; dy++) {
                    for(let dx=0; dx<selRect.w; dx++) {
                        let c = selData[dy * selRect.w + dx];
                        if (c !== 9) { // 9=transparent
                            let px = selRect.x + dx;
                            let py = selRect.y + dy;
                            if (px>=0 && px<CANVAS_SIZE && py>=0 && py<CANVAS_SIZE) {
                                if (!isPixelLocked(px, py)) {
                                    pixelData[py * CANVAS_SIZE + px] = c;
                                }
                            }
                        }
                    }
                }
                saveHistory();
            }
            selectionState = 'none';
            selData = null;
            selRect = {x:0, y:0, w:0, h:0};
            updateSelectionUI();
        }

        function updateSelectionUI() {
            if (currentTool === 'select') {
                selectionSvg.classList.remove('hidden');
                let sx, sy, sw, sh;
                if (selectionState !== 'none') {
                    sx = selRect.x; sy = selRect.y; sw = selRect.w; sh = selRect.h;
                } else if (hoverPos && !isDrawing) {
                    sx = hoverPos.x; sy = hoverPos.y; sw = 1; sh = 1;
                } else {
                    selectionSvg.classList.add('hidden');
                    return;
                }
                selRectOuter.setAttribute('x', sx);
                selRectOuter.setAttribute('y', sy);
                selRectOuter.setAttribute('width', sw);
                selRectOuter.setAttribute('height', sh);
                selRectInner.setAttribute('x', sx);
                selRectInner.setAttribute('y', sy);
                selRectInner.setAttribute('width', sw);
                selRectInner.setAttribute('height', sh);
            } else {
                selectionSvg.classList.add('hidden');
            }
        }

        // --- 描画コア関数 ---
        function clearPreview() { previewData.fill(0); }
        function setPixelCore(px, py, colorIdx, isPreview = false) {
            if (px >= 0 && px < CANVAS_SIZE && py >= 0 && py < CANVAS_SIZE) {
                if (isPixelLocked(px, py)) return; 
                if (isPreview) previewData[py * CANVAS_SIZE + px] = colorIdx + 1; 
                else pixelData[py * CANVAS_SIZE + px] = colorIdx;
            }
        }
        function drawBrush(cx, cy, colorIdx, isPreview = false, overrideSize = null) {
            const size = overrideSize || brushSize;
            const offset = Math.floor((size - 1) / 2);
            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                    const px = cx - offset + dx;
                    const py = cy - offset + dy;
                    setPixelCore(px, py, colorIdx, isPreview);
                    if (symXEnabled) setPixelCore(symXPos * 2 - px - 1, py, colorIdx, isPreview);
                    if (symYEnabled) setPixelCore(px, symYPos * 2 - py - 1, colorIdx, isPreview);
                    if (symXEnabled && symYEnabled) setPixelCore(symXPos * 2 - px - 1, symYPos * 2 - py - 1, colorIdx, isPreview);
                }
            }
        }
        function drawLine(x0, y0, x1, y1, colorIdx, isPreview = false) {
            let dx = Math.abs(x1 - x0); let dy = Math.abs(y1 - y0);
            let sx = (x0 < x1) ? 1 : -1; let sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            while (true) {
                drawBrush(x0, y0, colorIdx, isPreview);
                if (x0 === x1 && y0 === y1) break;
                let e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }
        function getSnappedEndPoint(x0, y0, x1, y1) {
            const dx = x1 - x0; const dy = y1 - y0;
            if (dx === 0 && dy === 0) return { x: x0, y: y0 };
            const angle = Math.atan2(Math.abs(dy), Math.abs(dx));
            let closestAngle = ALLOWED_ANGLES[0]; let minDiff = Math.abs(angle - ALLOWED_ANGLES[0]);
            for (let i = 1; i < ALLOWED_ANGLES.length; i++) {
                const diff = Math.abs(angle - ALLOWED_ANGLES[i]);
                if (diff < minDiff) { minDiff = diff; closestAngle = ALLOWED_ANGLES[i]; }
            }
            const dist = Math.sqrt(dx * dx + dy * dy);
            let snappedDx = Math.round(dist * Math.cos(closestAngle));
            let snappedDy = Math.round(dist * Math.sin(closestAngle));
            if (dx < 0) snappedDx = -snappedDx; if (dy < 0) snappedDy = -snappedDy;
            return { x: x0 + snappedDx, y: y0 + snappedDy };
        }
        function drawCircle(xc, yc, r, colorIdx, isPreview = false) {
            if (r === 0) { drawBrush(xc, yc, colorIdx, isPreview); return; }
            let x = 0, y = r, d = 3 - 2 * r;
            const draw8 = (cx, cy, px, py) => {
                drawBrush(cx + px, cy + py, colorIdx, isPreview); drawBrush(cx - px, cy + py, colorIdx, isPreview);
                drawBrush(cx + px, cy - py, colorIdx, isPreview); drawBrush(cx - px, cy - py, colorIdx, isPreview);
                drawBrush(cx + py, cy + px, colorIdx, isPreview); drawBrush(cx - py, cy + px, colorIdx, isPreview);
                drawBrush(cx + py, cy - px, colorIdx, isPreview); drawBrush(cx - py, cy - px, colorIdx, isPreview);
            };
            draw8(xc, yc, x, y);
            while (y >= x) {
                x++; if (d > 0) { y--; d = d + 4 * (x - y) + 10; } else { d = d + 4 * x + 6; }
                draw8(xc, yc, x, y);
            }
        }
        function getSnappedRadius(r) { return ALLOWED_RADII.reduce((prev, curr) => Math.abs(curr - r) < Math.abs(prev - r) ? curr : prev); }
        function drawText(startX, startY, text, colorIdx, isPreview = false) {
            let cx = startX;
            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase();
                const fontData = FONT_5x3[char] || FONT_5x3[' '];
                for (let py = 0; py < 5; py++) {
                    for (let px = 0; px < 3; px++) {
                        if (fontData[py * 3 + px] === 1) drawBrush(cx + px, startY + py, colorIdx, isPreview, 1);
                    }
                }
                cx += 4; 
            }
        }
        function floodFill(startX, startY, fillColor, isPreview = false) {
            if (isPixelLocked(startX, startY)) return; 
            const targetColor = pixelData[startY * CANVAS_SIZE + startX];
            if (targetColor === fillColor) return; 
            const queue = [{ x: startX, y: startY }];
            const visited = new Uint8Array(CANVAS_SIZE * CANVAS_SIZE); 
            const getColor = (px, py) => {
                if (px < 0 || px >= CANVAS_SIZE || py < 0 || py >= CANVAS_SIZE) return -1; 
                return pixelData[py * CANVAS_SIZE + px];
            };
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                const idx = y * CANVAS_SIZE + x;
                if (x < 0 || x >= CANVAS_SIZE || y < 0 || y >= CANVAS_SIZE) continue;
                if (visited[idx] === 1) continue; 
                if (getColor(x, y) !== targetColor) continue; 
                if (isPixelLocked(x, y)) continue; 
                setPixelCore(x, y, fillColor, isPreview);
                visited[idx] = 1; 
                queue.push({ x: x + 1, y: y }); queue.push({ x: x - 1, y: y });
                queue.push({ x: x, y: y + 1 }); queue.push({ x: x, y: y - 1 });
            }
            playSound('click');
        }

        // --- Stamp Logic ---
        function renderStampCanvas() {
            const imgData = stampCtx.createImageData(8, 8);
            for(let i=0; i<64; i++) {
                let c = stampData[i];
                if(c === 9) imgData.data[i*4+3] = 0;
                else {
                    let rgb = hexToRgb(PALETTE[c]);
                    imgData.data[i*4] = rgb.r; imgData.data[i*4+1] = rgb.g; imgData.data[i*4+2] = rgb.b; imgData.data[i*4+3] = 255;
                }
            }
            stampCtx.putImageData(imgData, 0, 0);
        }
        function handleStampInput(e) {
            const rect = stampCanvas.getBoundingClientRect();
            const scaleX = stampCanvas.width / rect.width;
            const scaleY = stampCanvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            if (x>=0 && x<8 && y>=0 && y<8) {
                stampData[y*8+x] = colorIndex; renderStampCanvas();
                if(e.type==='pointerdown') playSound('draw');
            }
        }
        function drawStamp(cx, cy, isPreview = false) {
            let offset = 4;
            for(let sy=0; sy<8; sy++) {
                for(let sx=0; sx<8; sx++) {
                    let c = stampData[sy*8+sx];
                    if (c !== 9) drawBrush(cx - offset + sx, cy - offset + sy, c, isPreview, 1);
                }
            }
        }

        // --- キャンバスイベントハンドラ ---
        function handlePointerDown(e) {
            e.preventDefault(); initAudio();
            const pos = getCanvasPos(e);
            hoverPos = null; 
            if (currentTool === 'select') {
                if (selectionState === 'selected') {
                    if (pos.x >= selRect.x && pos.x < selRect.x + selRect.w &&
                        pos.y >= selRect.y && pos.y < selRect.y + selRect.h) {
                        isDraggingSelection = true; selDragStartPos = pos; selOriginalRect = {x: selRect.x, y: selRect.y};
                        return; 
                    } else commitSelection();
                }
                selectionState = 'selecting'; selStartPos = pos; selRect = {x: pos.x, y: pos.y, w: 1, h: 1};
                isDrawing = true; updateSelectionUI(); return;
            }
            if (selectionState !== 'none') commitSelection();
            isDrawing = true; startPos = pos; lastPos = pos; lastPreviewKey = '';
            saveHistory();
            if (currentTool === 'pen') { drawBrush(pos.x, pos.y, colorIndex); playSound('draw'); }
            else if (currentTool === 'text') { drawText(pos.x, pos.y, currentTextInput, colorIndex); playSound('click'); saveHistory(); isDrawing = false; }
            else if (currentTool === 'fill') { floodFill(pos.x, pos.y, colorIndex); saveHistory(); isDrawing = false; }
            else if (currentTool === 'stamp') { drawStamp(pos.x, pos.y, false); playSound('click'); saveHistory(); isDrawing = false; }
        }

        function handlePointerMove(e) {
            e.preventDefault();
            const pos = getCanvasPos(e);
            if (!isDrawing && !isDraggingSelection) {
                hoverPos = pos;
                updateSelectionUI(); // Hover 1x1 ants
                return;
            }
            if (currentTool === 'select') {
                if (selectionState === 'selecting') {
                    selRect.x = Math.min(selStartPos.x, pos.x); selRect.y = Math.min(selStartPos.y, pos.y);
                    selRect.w = Math.abs(pos.x - selStartPos.x) + 1; selRect.h = Math.abs(pos.y - selStartPos.y) + 1;
                    updateSelectionUI();
                } else if (isDraggingSelection) {
                    selRect.x = selOriginalRect.x + (pos.x - selDragStartPos.x); selRect.y = selOriginalRect.y + (pos.y - selDragStartPos.y);
                    updateSelectionUI();
                }
                return;
            }
            if (currentTool === 'pen') {
                if (pos.x !== lastPos.x || pos.y !== lastPos.y) { drawLine(lastPos.x, lastPos.y, pos.x, pos.y, colorIndex); lastPos = pos; playSound('draw'); }
            } else if (currentTool === 'line') {
                clearPreview();
                const endPos = getSnappedEndPoint(startPos.x, startPos.y, pos.x, pos.y);
                drawLine(startPos.x, startPos.y, endPos.x, endPos.y, colorIndex, true);
                const pk = `${endPos.x},${endPos.y}`; if (pk !== lastPreviewKey) { playSound('snap'); lastPreviewKey = pk; }
            } else if (currentTool === 'circle') {
                clearPreview();
                const r = Math.round(Math.sqrt(Math.pow(pos.x - startPos.x, 2) + Math.pow(pos.y - startPos.y, 2)));
                const sr = getSnappedRadius(r);
                drawCircle(startPos.x, startPos.y, sr, colorIndex, true);
                if (sr !== parseInt(lastPreviewKey)) { playSound('snap'); lastPreviewKey = sr.toString(); }
            }
        }

        function handlePointerUp(e) {
            if (isDraggingSelection) { isDraggingSelection = false; playSound('click'); hoverPos = getCanvasPos(e); updateSelectionUI(); return; }
            if (!isDrawing) return;
            isDrawing = false; e.preventDefault(); const pos = getCanvasPos(e); hoverPos = pos;
            if (currentTool === 'select') {
                if (selectionState === 'selecting') {
                    if (selRect.w > 0 && selRect.h > 0) {
                        selectionState = 'selected'; selData = new Uint8Array(selRect.w * selRect.h);
                        for(let dy=0; dy<selRect.h; dy++) {
                            for(let dx=0; dx<selRect.w; dx++) {
                                let px = selRect.x + dx; let py = selRect.y + dy;
                                if (px>=0 && px<CANVAS_SIZE && py>=0 && py<CANVAS_SIZE) {
                                    selData[dy * selRect.w + dx] = pixelData[py * CANVAS_SIZE + px];
                                    if (!isPixelLocked(px, py)) pixelData[py * CANVAS_SIZE + px] = 0;
                                } else selData[dy * selRect.w + dx] = 9;
                            }
                        }
                        playSound('snap');
                    } else selectionState = 'none';
                    updateSelectionUI();
                }
                return;
            }
            if (currentTool === 'line') {
                const endPos = getSnappedEndPoint(startPos.x, startPos.y, pos.x, pos.y);
                drawLine(startPos.x, startPos.y, endPos.x, endPos.y, colorIndex); playSound('click');
            } else if (currentTool === 'circle') {
                const r = Math.round(Math.sqrt(Math.pow(pos.x - startPos.x, 2) + Math.pow(pos.y - startPos.y, 2)));
                drawCircle(startPos.x, startPos.y, getSnappedRadius(r), colorIndex); playSound('click');
            }
            saveHistory(); clearPreview(); renderCanvas(); 
        }

        function handlePointerOut(e) { hoverPos = null; updateSelectionUI(); if (isDrawing) handlePointerUp(e); }

        function renderCanvas() {
            const imgData = ctx.createImageData(CANVAS_SIZE, CANVAS_SIZE);
            const data = imgData.data;
            for (let i = 0; i < CANVAS_SIZE * CANVAS_SIZE; i++) {
                const x = i % CANVAS_SIZE; const y = Math.floor(i / CANVAS_SIZE);
                let cIdx = pixelData[i]; const pvVal = previewData[i];
                if (pvVal > 0) cIdx = pvVal - 1; 
                const hex = PALETTE[cIdx]; const locked = isPixelLocked(x, y);
                if (hex === 'transparent') {
                    if (locked) { data[i * 4] = 128; data[i * 4 + 1] = 0; data[i * 4 + 2] = 0; data[i * 4 + 3] = 128; }
                    else data[i * 4 + 3] = 0; 
                } else {
                    let rgb = hexToRgb(hex);
                    if (locked) { rgb.r = Math.floor(rgb.r*0.5+127); rgb.g = Math.floor(rgb.g*0.5); rgb.b = Math.floor(rgb.b*0.5); }
                    data[i * 4] = rgb.r; data[i * 4 + 1] = rgb.g; data[i * 4 + 2] = rgb.b; data[i * 4 + 3] = 255; 
                }
            }
            if (selectionState === 'selected' && selData) {
                for(let dy=0; dy<selRect.h; dy++) {
                    for(let dx=0; dx<selRect.w; dx++) {
                        let c = selData[dy * selRect.w + dx];
                        if (c !== 9) {
                            let px = selRect.x + dx; let py = selRect.y + dy;
                            if (px>=0 && px<CANVAS_SIZE && py>=0 && py<CANVAS_SIZE) {
                                let rgb = hexToRgb(PALETTE[c]); let idx = (py * CANVAS_SIZE + px) * 4;
                                data[idx] = rgb.r; data[idx+1] = rgb.g; data[idx+2] = rgb.b; data[idx+3] = 255;
                            }
                        }
                    }
                }
            }
            ctx.putImageData(imgData, 0, 0);
            if (hoverPos && !isDrawing && currentTool !== 'select') {
                ctx.save();
                const drawPixelPreview = (px, py) => { ctx.globalCompositeOperation = 'difference'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(px, py, 1, 1); };
                const drawMirroredPixelPreview = (px, py) => {
                    drawPixelPreview(px, py);
                    if (symXEnabled) drawPixelPreview(symXPos * 2 - px - 1, py);
                    if (symYEnabled) drawPixelPreview(px, symYPos * 2 - py - 1);
                    if (symXEnabled && symYEnabled) drawPixelPreview(symXPos * 2 - px - 1, symYPos * 2 - py - 1);
                };
                if (currentTool === 'text') {
                    let cx = hoverPos.x; let cy = hoverPos.y;
                    for (let i = 0; i < currentTextInput.length; i++) {
                        const fd = FONT_5x3[currentTextInput[i].toUpperCase()] || FONT_5x3[' '];
                        for (let py = 0; py < 5; py++) { for (let px = 0; px < 3; px++) { if (fd[py * 3 + px] === 1) drawMirroredPixelPreview(cx + px, cy + py); } }
                        cx += 4;
                    }
                } else if (currentTool === 'fill') drawMirroredPixelPreview(hoverPos.x, hoverPos.y);
                else if (currentTool === 'stamp') {
                    let offset = 4;
                    for(let sy=0; sy<8; sy++) { for(let sx=0; sx<8; sx++) { if (stampData[sy*8+sx] !== 9) drawMirroredPixelPreview(hoverPos.x-offset+sx, hoverPos.y-offset+sy); } }
                } else {
                    let size = brushSize; let offset = Math.floor((size - 1) / 2);
                    for (let dy = 0; dy < size; dy++) { for (let dx = 0; dx < size; dx++) { if (dx === 0 || dx === size - 1 || dy === 0 || dy === size - 1) drawMirroredPixelPreview(hoverPos.x - offset + dx, hoverPos.y - offset + dy); } }
                }
                ctx.restore();
            }
            animationId = requestAnimationFrame(renderCanvas);
        }

        // --- UI更新関数 ---
        function updateToolUI() {
            if (selectionState !== 'none' && currentTool !== 'select') commitSelection();
            toolButtons.forEach(btn => {
                if (btn.dataset.tool === currentTool) { btn.classList.add('bg-blue-600', 'text-white', 'shadow-[0_0_10px_rgba(37,99,235,0.5)]'); btn.classList.remove('bg-slate-700', 'hover:bg-slate-600', 'text-slate-300'); }
                else { btn.classList.remove('bg-blue-600', 'text-white', 'shadow-[0_0_10px_rgba(37,99,235,0.5)]'); btn.classList.add('bg-slate-700', 'hover:bg-slate-600', 'text-slate-300'); }
            });
            textInputContainer.classList.toggle('hidden', currentTool !== 'text');
            updateSelectionUI();
        }
        function updateBrushSizeUI() {
            brushSizeButtons.forEach(btn => {
                if (parseInt(btn.dataset.size) === brushSize) { btn.classList.add('bg-blue-500', 'text-white', 'font-bold'); btn.classList.remove('bg-slate-700', 'text-slate-400', 'hover:bg-slate-600'); }
                else { btn.classList.remove('bg-blue-500', 'text-white', 'font-bold'); btn.classList.add('bg-slate-700', 'text-slate-400', 'hover:bg-slate-600'); }
            });
        }
        function renderPalette() {
            paletteContainer.innerHTML = `<div class="text-[10px] text-slate-400 mb-1 hidden md:block text-center font-bold tracking-wider w-full">PALETTE</div>`;
            PALETTE.forEach((color, idx) => {
                const wrapper = document.createElement('div'); wrapper.className = 'flex items-center gap-1 md:w-full md:justify-start justify-center shrink-0';
                const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.className = 'w-3 h-3 md:w-4 md:h-4 accent-red-500 cursor-pointer shrink-0'; checkbox.title = 'Lock color'; checkbox.checked = lockedColors.has(idx); checkbox.addEventListener('change', (e) => { if (e.target.checked) lockedColors.add(idx); else lockedColors.delete(idx); playSound('click'); });
                const btn = document.createElement('button'); btn.dataset.colorIndex = idx; btn.className = `relative w-8 h-8 md:w-10 md:h-10 rounded-full border-2 transition-all shrink-0 ${colorIndex === idx ? 'border-orange-500 scale-110 shadow-[0_0_12px_rgba(249,115,22,0.8)] z-10' : 'border-slate-600 scale-100 hover:scale-105'}`;
                if (color === 'transparent') { btn.style.backgroundImage = 'repeating-conic-gradient(#cbd5e1 0% 25%, #f8fafc 0% 50%)'; btn.style.backgroundSize = '8px 8px'; btn.title = 'Eraser'; if (colorIndex !== idx) btn.innerHTML = `<div class="absolute inset-0 flex items-center justify-center"><div class="w-6 h-px bg-red-500/50 rotate-45"></div></div>`; }
                else { btn.style.backgroundColor = color; btn.title = `Color ${idx} (${color})`; }
                btn.addEventListener('click', () => { colorIndex = idx; playSound('click'); updatePaletteUI(); });
                wrapper.appendChild(checkbox); wrapper.appendChild(btn); paletteContainer.appendChild(wrapper);
            });
        }
        function updatePaletteUI() {
            paletteContainer.querySelectorAll('button').forEach(btn => {
                const idx = parseInt(btn.dataset.colorIndex);
                if (colorIndex === idx) { btn.classList.add('border-orange-500', 'scale-110', 'shadow-[0_0_12px_rgba(249,115,22,0.8)]', 'z-10'); btn.classList.remove('border-slate-600', 'scale-100', 'hover:scale-105'); }
                else { btn.classList.remove('border-orange-500', 'scale-110', 'shadow-[0_0_12px_rgba(249,115,22,0.8)]', 'z-10'); btn.classList.add('border-slate-600', 'scale-100', 'hover:scale-105'); }
                if (PALETTE[idx] === 'transparent') { if (colorIndex !== idx && btn.querySelector('.w-6.h-px') === null) btn.innerHTML = `<div class="absolute inset-0 flex items-center justify-center"><div class="w-6 h-px bg-red-500/50 rotate-45"></div></div>`; else if (colorIndex === idx && btn.querySelector('.w-6.h-px')) btn.innerHTML = ''; }
            });
        }
        function updateGridUI() { gridOverlay.classList.toggle('hidden', !showGrid); toggleGridBtn.classList.toggle('bg-slate-600', showGrid); toggleGridBtn.classList.toggle('bg-slate-700', !showGrid); }
        function updateSymmetryUI() {
            symXLine.classList.toggle('hidden', !symXEnabled); toggleSymXBtn.classList.toggle('bg-red-900/50', symXEnabled); symXPosSlider.disabled = !symXEnabled; resetSymXBtn.disabled = !symXEnabled; symXLine.style.left = `${(symXPos / CANVAS_SIZE) * 100}%`;
            symYLine.classList.toggle('hidden', !symYEnabled); toggleSymYBtn.classList.toggle('bg-green-900/50', symYEnabled); symYPosSlider.disabled = !symYEnabled; resetSymYBtn.disabled = !symYEnabled; symYLine.style.top = `${(symYPos / CANVAS_SIZE) * 100}%`;
        }
        function updateTextInputUI() { textInput.value = currentTextInput; }

        // --- イベントリスナー設定 ---
        function setupEventListeners() {
            pixelCanvas.addEventListener('pointerdown', handlePointerDown);
            pixelCanvas.addEventListener('pointermove', handlePointerMove);
            pixelCanvas.addEventListener('pointerup', handlePointerUp);
            pixelCanvas.addEventListener('pointercancel', handlePointerUp);
            pixelCanvas.addEventListener('pointerout', handlePointerOut);
            stampCanvas.addEventListener('pointerdown', (e) => { isDrawingStamp=true; handleStampInput(e); });
            stampCanvas.addEventListener('pointermove', (e) => { if(isDrawingStamp) handleStampInput(e); });
            stampCanvas.addEventListener('pointerup', () => { isDrawingStamp=false; });
            stampCanvas.addEventListener('pointerout', () => { isDrawingStamp=false; });
            clearStampBtn.addEventListener('click', () => { stampData.fill(9); renderStampCanvas(); playSound('click'); });
            toolButtons.forEach(button => button.addEventListener('click', () => { currentTool = button.dataset.tool; playSound('click'); updateToolUI(); }));
            brushSizeButtons.forEach(button => button.addEventListener('click', () => { brushSize = parseInt(button.dataset.size); playSound('click'); updateBrushSizeUI(); }));
            textInput.addEventListener('input', (e) => { currentTextInput = e.target.value.toUpperCase(); updateTextInputUI(); });
            toggleGridBtn.addEventListener('click', () => { showGrid = !showGrid; playSound('click'); updateGridUI(); });
            toggleSymXBtn.addEventListener('click', () => { symXEnabled = !symXEnabled; playSound('click'); updateSymmetryUI(); });
            symXPosSlider.addEventListener('input', (e) => { symXPos = parseInt(e.target.value); playSound('snap'); updateSymmetryUI(); });
            resetSymXBtn.addEventListener('click', () => { symXPos = 32; symXPosSlider.value = 32; playSound('click'); updateSymmetryUI(); });
            toggleSymYBtn.addEventListener('click', () => { symYEnabled = !symYEnabled; playSound('click'); updateSymmetryUI(); });
            symYPosSlider.addEventListener('input', (e) => { symYPos = parseInt(e.target.value); playSound('snap'); updateSymmetryUI(); });
            resetSymYBtn.addEventListener('click', () => { symYPos = 32; symYPosSlider.value = 32; playSound('click'); updateSymmetryUI(); });
            undoBtn.addEventListener('click', handleUndo); redoBtn.addEventListener('click', handleRedo);
            clearBtn.addEventListener('click', () => { pixelData.fill(0); playSound('click'); saveHistory(); });
            openBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0]; if (!file) return;
                const url = URL.createObjectURL(file); const img = new Image();
                img.onload = () => {
                    const offCanvas = document.createElement('canvas'); offCanvas.width = CANVAS_SIZE; offCanvas.height = CANVAS_SIZE;
                    const offCtx = offCanvas.getContext('2d'); offCtx.fillStyle = '#FFFFFF'; offCtx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE); offCtx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
                    const imgD = offCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE).data;
                    for(let i=0; i<CANVAS_SIZE*CANVAS_SIZE; i++) {
                        let r = imgD[i*4], g = imgD[i*4+1], b = imgD[i*4+2], a = imgD[i*4+3];
                        if (a < 128) { pixelData[i] = 9; continue; }
                        let minDist = Infinity, clIdx = 0;
                        for(let j=0; j<9; j++) {
                            let rgb = hexToRgb(PALETTE[j]); let d = (r-rgb.r)**2 + (g-rgb.g)**2 + (b-rgb.b)**2;
                            if(d < minDist) { minDist = d; clIdx = j; }
                        }
                        pixelData[i] = clIdx;
                    }
                    saveHistory(); playSound('snap'); URL.revokeObjectURL(url); fileInput.value = ''; 
                };
                img.src = url;
            });
            downloadBtn.addEventListener('click', () => { if (selectionState !== 'none') commitSelection(); const link = document.createElement('a'); link.download = 'pixel_art.png'; link.href = pixelCanvas.toDataURL('image/png'); link.click(); showToast('Image downloaded!'); playSound('snap'); });
            hueSlider.addEventListener('input', () => updatePaletteColors());
            document.querySelectorAll('input[name="maskHorizontal"]').forEach(r => r.addEventListener('change', (e) => { if(e.target.checked) { maskHorizontal = e.target.value; playSound('click'); }}));
            document.querySelectorAll('input[name="maskVertical"]').forEach(r => r.addEventListener('change', (e) => { if(e.target.checked) { maskVertical = e.target.value; playSound('click'); }}));
            document.querySelectorAll('input[name="maskChecker"]').forEach(r => r.addEventListener('change', (e) => { if(e.target.checked) { maskChecker = e.target.value; playSound('click'); }}));
            document.querySelectorAll('input[name="maskSlash"]').forEach(r => r.addEventListener('change', (e) => { if(e.target.checked) { maskSlash = e.target.value; playSound('click'); }}));
            document.querySelectorAll('input[name="maskBackslash"]').forEach(r => r.addEventListener('change', (e) => { if(e.target.checked) { maskBackslash = e.target.value; playSound('click'); }}));
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' && e.target.type !== 'checkbox' && e.target.type !== 'radio' && e.target.type !== 'range') return;
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) handleRedo(); else handleUndo(); }
                else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { e.preventDefault(); downloadBtn.click(); }
                else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') { e.preventDefault(); openBtn.click(); }
                else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') { if (selectionState === 'selected') { internalClipboard = {data: new Uint8Array(selData), w: selRect.w, h: selRect.h}; showToast('Selection Copied!'); playSound('snap'); } }
                else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
                    if (internalClipboard) {
                        commitSelection(); currentTool = 'select'; selectionState = 'selected';
                        selRect = {x: Math.floor((CANVAS_SIZE - internalClipboard.w)/2), y: Math.floor((CANVAS_SIZE - internalClipboard.h)/2), w: internalClipboard.w, h: internalClipboard.h};
                        selData = new Uint8Array(internalClipboard.data); updateToolUI(); playSound('click');
                    }
                }
                else if (e.key === 'Enter') { if (currentTool === 'select' && selectionState !== 'none') { e.preventDefault(); commitSelection(); playSound('snap'); } }
                if (currentTool === 'select' && selectionState === 'selected') {
                    let dx = 0, dy = 0;
                    if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') dy = -1; if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') dy = 1;
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') dx = -1; if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') dx = 1;
                    if (dx !== 0 || dy !== 0) { e.preventDefault(); selRect.x += dx; selRect.y += dy; updateSelectionUI(); }
                }
            });
        }
        window.addEventListener('load', init);
    </script>
</body>
</html>