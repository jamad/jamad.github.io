<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper-Scale Calendar Prototype</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            touch-action: none; /* スマホでのスクロール無効化 */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        #current-date {
            font-size: 2.5rem;
            font-weight: 700;
            margin-top: 5px;
            font-variant-numeric: tabular-nums;
        }

        #instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            pointer-events: none;
            animation: blink 3s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.2; }
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="calendarCanvas"></canvas>
    <div id="ui-layer">
        <h1>TIME LENS // 120 YEARS</h1>
        <div id="current-date">Initializing...</div>
    </div>
    <div id="instruction">Drag / Hover to Explore Time</div>
</div>

<script>
/**
 * Audio Engine (Web Audio API)
 */
class SoundEngine {
    constructor() {
        this.ctx = null;
        this.isReady = false;
        this.frequencies = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];
        this.lastDecade = -1;
    }

    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.isReady = true;
            this.playStartSound();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type = 'sine', duration = 0.1, vol = 0.1) {
        if (!this.isReady) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playStartSound() {
        this.playTone(440, 'triangle', 0.5, 0.2);
        setTimeout(() => this.playTone(880, 'sine', 1.0, 0.1), 100);
    }

    playHover() {
        if (Math.random() > 0.8) {
            const f = this.frequencies[Math.floor(Math.random() * this.frequencies.length)];
            this.playTone(f * 2, 'sine', 0.05, 0.02);
        }
    }

    playDecadeCross(year) {
        const decade = Math.floor(year / 10);
        if (this.lastDecade !== decade) {
            this.playTone(110 + (decade % 10) * 20, 'square', 0.1, 0.05);
            this.lastDecade = decade;
        }
    }
}

/**
 * Calendar Logic & Rendering
 */
class HyperCalendar {
    constructor() {
        this.canvas = document.getElementById('calendarCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        this.dateDisplay = document.getElementById('current-date');
        
        this.years = 120;
        this.days = 366;
        this.startYear = 1950;
        this.rowPadding = 2;
        
        this.rowHeights = new Float32Array(this.years);
        this.colWidths = new Float32Array(this.days);
        this.rowY = new Float32Array(this.years + 1);
        this.colX = new Float32Array(this.days + 1);

        this.idealTotalWeightX = 0;
        this.idealTotalWeightY = 0;
        
        this.sound = new SoundEngine();
        this.isInteracting = true; 
        
        this.monthColors = [
            [200, 230, 255], [220, 240, 255], [255, 200, 220], [255, 180, 200],
            [180, 255, 180], [100, 220, 100], [100, 200, 255], [50, 150, 255],
            [255, 200, 100], [255, 150, 50], [200, 100, 50], [220, 220, 255]
        ];
        this.monthDays = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

        this.resize();
        this.precalculateIdealWeights();
        this.setInitialDate();
        this.initEvents();
        this.loop();
    }

    precalculateIdealWeights() {
        const centerX = this.days / 2;
        const centerY = this.years / 2;
        this.idealTotalWeightX = this.calculateWeightSum(this.days, centerX, 40, 40);
        this.idealTotalWeightY = this.calculateWeightSum(this.years, centerY, 20, 15);
    }

    calculateWeightSum(count, centerIndex, intensity, spread) {
        let total = 0;
        for(let i=0; i<count; i++) {
            let w = 1.0;
            const dist = Math.abs(i - centerIndex);
            if(dist < spread) {
                const factor = Math.exp(-(dist * dist) / (2 * (spread * 0.3) * (spread * 0.3)));
                w += factor * intensity;
            }
            total += w;
        }
        return total;
    }

    setInitialDate() {
        const now = new Date();
        const currentYear = now.getFullYear();
        let targetYearIndex = currentYear - this.startYear;
        if (targetYearIndex < 0 || targetYearIndex >= this.years) targetYearIndex = Math.floor(this.years / 2);
        const startOfYear = new Date(currentYear, 0, 1);
        const dayOfYear = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
        const targetDayIndex = Math.min(dayOfYear, this.days - 1);
        this.pointerX = (targetDayIndex / this.days) * this.width;
        this.pointerY = (targetYearIndex / this.years) * this.height;
        this.targetPointerX = this.pointerX;
        this.targetPointerY = this.pointerY;
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
    }

    initEvents() {
        window.addEventListener('resize', () => this.resize());
        const updatePointer = (x, y) => {
            this.targetPointerX = x;
            this.targetPointerY = y;
            this.isInteracting = true;
            this.sound.init(); 
        };
        this.canvas.addEventListener('mousemove', e => updatePointer(e.clientX, e.clientY));
        this.canvas.addEventListener('mouseleave', () => { this.isInteracting = false; });
        this.canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            updatePointer(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            updatePointer(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
    }

    // ★ 修正後の分布計算メソッド
    calculateDistribution(totalSize, pointerPos, itemsCount, intensity, spread, idealTotalWeight) {
        const weights = new Float32Array(itemsCount);
        const estimatedIndex = (pointerPos / totalSize) * itemsCount;
        let currentLensWeightSum = 0;

        for (let i = 0; i < itemsCount; i++) {
            let w = 0; 
            if (this.isInteracting) {
                const dist = Math.abs(i - estimatedIndex);
                if (dist < spread) {
                    w = Math.exp(-(dist * dist) / (2 * (spread * 0.3) * (spread * 0.3))) * intensity;
                }
            }
            weights[i] = w;
            currentLensWeightSum += w;
        }

        const scale = totalSize / idealTotalWeight;
        const idealLensWeightSum = idealTotalWeight - itemsCount;
        const missingWeight = idealLensWeightSum - currentLensWeightSum;
        const baseSize = (1.0 + (missingWeight / itemsCount)) * scale;

        const results = new Float32Array(itemsCount);
        const positions = new Float32Array(itemsCount + 1);
        let currentPos = 0;
        positions[0] = 0;
        for (let i = 0; i < itemsCount; i++) {
            const size = baseSize + (weights[i] * scale);
            results[i] = size;
            currentPos += size;
            positions[i+1] = currentPos;
        }
        positions[itemsCount] = totalSize;
        return { sizes: results, positions: positions };
    }

    update() {
        this.pointerX += (this.targetPointerX - this.pointerX) * 0.15;
        this.pointerY += (this.targetPointerY - this.pointerY) * 0.15;

        const xDist = this.calculateDistribution(
            this.width, this.pointerX, this.days, 
            this.isInteracting ? 40 : 0, 40, this.idealTotalWeightX
        );
        this.colWidths = xDist.sizes;
        this.colX = xDist.positions;

        const yDist = this.calculateDistribution(
            this.height, this.pointerY, this.years, 
            this.isInteracting ? 20 : 0, 15, this.idealTotalWeightY
        );
        this.rowHeights = yDist.sizes;
        this.rowY = yDist.positions;

        if (this.isInteracting) {
            let focusedYearIdx = 0;
            for(let i=0; i<this.years; i++) {
                if(this.rowY[i] < this.pointerY && this.rowY[i+1] > this.pointerY) {
                    focusedYearIdx = i;
                    break;
                }
            }
            this.sound.playDecadeCross(this.startYear + focusedYearIdx);
            if (Math.abs(this.targetPointerX - this.pointerX) > 5) this.sound.playHover();
        }
    }

    draw() {
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, 0, this.width, this.height);

        for (let m = 0; m < 12; m++) {
            const startDay = this.monthDays[m];
            const endDay = (m === 11) ? 366 : this.monthDays[m+1];
            const startX = this.colX[startDay];
            const endX = this.colX[endDay];
            const width = endX - startX;
            if (width < 1) continue;
            const color = this.monthColors[m];
            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.globalAlpha = 0.3;
            this.ctx.fillRect(startX, 0, width, this.height);
        }

        this.ctx.globalAlpha = 1.0;
        let hoverYear = -1;
        let hoverDay = -1;

        for (let y = 0; y < this.years; y++) {
            const h = this.rowHeights[y];
            const py = this.rowY[y];
            if (py > this.height || py + h < 0) continue;
            const isRowActive = (this.isInteracting && this.pointerY >= py && this.pointerY < py + h);
            if (isRowActive) hoverYear = y;
            const drawHeight = Math.max(h - this.rowPadding, 0.5);

            if (this.rowPadding > 0) {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, py + drawHeight, this.width, this.rowPadding);
            }

            if (h > 10 || isRowActive) {
                if (h > 15 || isRowActive) {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = `${Math.min(h * 0.8, 20)}px Arial`;
                    this.ctx.fillText(this.startYear + y, 10, py + drawHeight - (drawHeight*0.2));
                }
            }

            if (h > 20 || isRowActive) {
                if (isRowActive) {
                    for (let d = 0; d < this.days; d++) {
                        const w = this.colWidths[d];
                        const px = this.colX[d];
                        const isColActive = (this.pointerX >= px && this.pointerX < px + w);
                        if (isColActive) hoverDay = d;
                        if (w > 2) {
                            this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            this.ctx.fillRect(px + w - 1, py, 1, drawHeight);
                        }
                        if (w > 30 && h > 20) {
                            let m = 0;
                            for(let k=11; k>=0; k--) { if(d >= this.monthDays[k]) { m=k; break; } }
                            const dayOfMonth = d - this.monthDays[m] + 1;
                            this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
                            this.ctx.font = '10px Arial';
                            this.ctx.fillText(`${m+1}/${dayOfMonth}`, px + 2, py + 12);
                        }
                    }
                }
            }
        }

        if (hoverYear !== -1 && hoverDay !== -1) {
            const hx = this.colX[hoverDay];
            const hy = this.rowY[hoverYear];
            const hw = this.colWidths[hoverDay];
            const hh = this.rowHeights[hoverYear];
            const drawH = Math.max(hh - this.rowPadding, 0.5);
            this.ctx.fillStyle = '#fff';
            this.ctx.globalAlpha = 0.5;
            this.ctx.fillRect(hx, hy, hw, drawH);
            this.ctx.strokeStyle = '#0ff';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(hx, hy, hw, drawH);
            this.updateInfo(hoverYear, hoverDay);
        } else if (!this.isInteracting) {
            this.dateDisplay.textContent = "120 YEARS VIEW";
            this.dateDisplay.style.color = "#888";
        }
    }

    updateInfo(yIdx, dIdx) {
        let m = 0;
        for(let k=11; k>=0; k--) { if(dIdx >= this.monthDays[k]) { m=k; break; } }
        const dayOfMonth = dIdx - this.monthDays[m] + 1;
        const year = this.startYear + yIdx;
        this.dateDisplay.textContent = `${year}年 ${m+1}月 ${dayOfMonth}日`;
        const c = this.monthColors[m];
        this.dateDisplay.style.color = `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => {
    new HyperCalendar();
};
</script>
</body>
</html>