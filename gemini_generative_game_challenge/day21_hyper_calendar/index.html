<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper-Scale Calendar</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: none;
        }
        #canvas-container { position: relative; width: 100%; height: 100%; }
        canvas { display: block; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            pointer-events: none; color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 { font-size: 1.2rem; margin: 0; font-weight: 300; letter-spacing: 2px; }
        #current-date { font-size: 2.5rem; font-weight: 700; margin-top: 5px; font-variant-numeric: tabular-nums; }
        #instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.5); font-size: 0.9rem;
            pointer-events: none; animation: blink 3s infinite;
        }
        #version {
            position: absolute; bottom: 15px; right: 20px;
            color: rgba(255, 255, 255, 0.3); font-size: 0.7rem;
            font-family: monospace; pointer-events: none;
        }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 0.2; } }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="calendarCanvas"></canvas>
    <div id="ui-layer">
        <h1>TIME LENS // 120 YEARS</h1>
        <div id="current-date">Initializing...</div>
    </div>
    <div id="instruction">Drag / Hover to Explore Time</div>
    <div id="version">v20260128.1</div>
</div>

<script>
/**
 * 定数データ
 */
const MONTH_DATA = {
    days: [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
    colors: [
        [200, 230, 255], [220, 240, 255], [255, 200, 220], [255, 180, 200],
        [180, 255, 180], [100, 220, 100], [100, 200, 255], [50, 150, 255],
        [255, 200, 100], [255, 150, 50], [200, 100, 50], [220, 220, 255]
    ]
};

class SoundEngine {
    constructor() {
        this.ctx = null;
        this.frequencies = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];
        this.lastDecade = -1;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.playTone(440, 'triangle', 0.5, 0.2);
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type = 'sine', duration = 0.1, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playHover() {
        if (Math.random() > 0.8) {
            const f = this.frequencies[Math.floor(Math.random() * this.frequencies.length)];
            this.playTone(f * 2, 'sine', 0.05, 0.02);
        }
    }

    playDecadeCross(year) {
        const decade = Math.floor(year / 10);
        if (this.lastDecade !== decade) {
            this.playTone(110 + (decade % 10) * 20, 'square', 0.1, 0.05);
            this.lastDecade = decade;
        }
    }
}

class HyperCalendar {
    constructor() {
        this.canvas = document.getElementById('calendarCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        this.dateDisplay = document.getElementById('current-date');
        
        this.config = { years: 120, days: 366, startYear: 1950, padding: 2 };
        this.state = {
            pointer: { x: 0, y: 0, targetX: 0, targetY: 0 },
            isInteracting: true,
            rowHeights: new Float32Array(this.config.years),
            colWidths: new Float32Array(this.config.days),
            rowY: new Float32Array(this.config.years + 1),
            colX: new Float32Array(this.config.days + 1)
        };

        this.sound = new SoundEngine();
        this.resize();

        // 理想的な重みの計算（中央値で固定）
        this.idealWeightX = this.calculateWeightSum(this.config.days, this.config.days / 2, 40, 40);
        this.idealWeightY = this.calculateWeightSum(this.config.years, this.config.years / 2, 20, 15);

        this.setInitialDate();
        this.initEvents();
        this.loop();
    }

    calculateWeightSum(count, center, intensity, spread) {
        let sum = 0;
        const s = spread * 0.3;
        const denom = 2 * s * s;
        for (let i = 0; i < count; i++) {
            const dist = i - center;
            sum += 1.0 + Math.exp(-(dist * dist) / denom) * intensity;
        }
        return sum;
    }

    getMonthInfo(dayIdx) {
        for (let i = 11; i >= 0; i--) {
            if (dayIdx >= MONTH_DATA.days[i]) return { month: i + 1, date: dayIdx - MONTH_DATA.days[i] + 1 };
        }
    }

    setInitialDate() {
        const now = new Date();
        const yIdx = Math.max(0, Math.min(this.config.years - 1, now.getFullYear() - this.config.startYear));
        const dIdx = Math.floor((now - new Date(now.getFullYear(), 0, 1)) / 86400000);
        
        this.state.pointer.x = this.state.pointer.targetX = (dIdx / this.config.days) * this.width;
        this.state.pointer.y = this.state.pointer.targetY = (yIdx / this.config.years) * this.height;
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
    }

    initEvents() {
        window.addEventListener('resize', () => this.resize());
        const move = (e) => {
            const t = e.touches ? e.touches[0] : e;
            this.state.pointer.targetX = t.clientX;
            this.state.pointer.targetY = t.clientY;
            this.state.isInteracting = true;
            this.sound.init();
        };
        this.canvas.addEventListener('mousemove', move);
        this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); move(e); }, { passive: false });
        this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, { passive: false });
        this.canvas.addEventListener('mouseleave', () => this.state.isInteracting = false);
    }

    calculateDistribution(totalSize, pointerPos, itemsCount, intensity, spread, idealWeight) {
        const weights = new Float32Array(itemsCount);
        const center = (pointerPos / totalSize) * itemsCount;
        const s = spread * 0.3;
        const denom = 2 * s * s;
        let currentLensSum = 0;

        for (let i = 0; i < itemsCount; i++) {
            let w = 0;
            if (this.state.isInteracting) {
                const dist = i - center;
                if (Math.abs(dist) < spread) w = Math.exp(-(dist * dist) / denom) * intensity;
            }
            weights[i] = w;
            currentLensSum += w;
        }

        const scale = totalSize / idealWeight;
        const baseSize = (1.0 + (idealWeight - itemsCount - currentLensSum) / itemsCount) * scale;

        const sizes = new Float32Array(itemsCount);
        const positions = new Float32Array(itemsCount + 1);
        let cur = 0;
        for (let i = 0; i < itemsCount; i++) {
            sizes[i] = baseSize + weights[i] * scale;
            positions[i] = cur;
            cur += sizes[i];
        }
        positions[itemsCount] = totalSize;
        return { sizes, positions };
    }

    update() {
        const p = this.state.pointer;
        p.x += (p.targetX - p.x) * 0.15;
        p.y += (p.targetY - p.y) * 0.15;

        const xDist = this.calculateDistribution(this.width, p.x, this.config.days, 40, 40, this.idealWeightX);
        const yDist = this.calculateDistribution(this.height, p.y, this.config.years, 20, 15, this.idealWeightY);

        this.state.colWidths = xDist.sizes;
        this.state.colX = xDist.positions;
        this.state.rowHeights = yDist.sizes;
        this.state.rowY = yDist.positions;

        if (this.state.isInteracting) {
            const yIdx = this.state.rowY.findIndex((pos, i) => p.y >= pos && p.y < this.state.rowY[i+1]);
            this.sound.playDecadeCross(this.config.startYear + yIdx);
            if (Math.abs(p.targetX - p.x) > 5) this.sound.hoverY = yIdx, this.sound.playHover();
        }
    }

    draw() {
        const { ctx, width, height, config, state } = this;
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        // 背景（月）
        MONTH_DATA.days.forEach((startDay, m) => {
            const endDay = MONTH_DATA.days[m + 1] || 366;
            const x = state.colX[startDay], w = state.colX[endDay] - x;
            if (w < 1) return;
            ctx.fillStyle = `rgb(${MONTH_DATA.colors[m].join(',')})`;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x, 0, w, height);
        });

        ctx.globalAlpha = 1.0;
        let hover = { y: -1, d: -1 };

        for (let y = 0; y < config.years; y++) {
            const h = state.rowHeights[y], py = state.rowY[y];
            if (py > height || py + h < 0) continue;

            const isActiveRow = state.isInteracting && state.pointer.y >= py && state.pointer.y < py + h;
            if (isActiveRow) hover.y = y;

            const drawH = Math.max(h - config.padding, 0.5);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, py + drawH, width, config.padding);

            if (h > 10 || isActiveRow) {
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.min(h * 0.8, 20)}px Arial`;
                ctx.fillText(config.startYear + y, 10, py + drawH * 0.8);
            }

            if (isActiveRow && h > 20) {
                for (let d = 0; d < config.days; d++) {
                    const w = state.colWidths[d], px = state.colX[d];
                    if (state.pointer.x >= px && state.pointer.x < px + w) hover.d = d;
                    if (w > 2) {
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(px + w - 1, py, 1, drawH);
                    }
                    if (w > 30) {
                        const info = this.getMonthInfo(d);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.font = '10px Arial';
                        ctx.fillText(`${info.month}/${info.date}`, px + 2, py + 12);
                    }
                }
            }
        }

        if (hover.y !== -1 && hover.d !== -1) {
            this.drawHighlight(hover.y, hover.d);
        } else if (!state.isInteracting) {
            this.dateDisplay.textContent = "120 YEARS VIEW";
            this.dateDisplay.style.color = "#888";
        }
    }

    drawHighlight(yIdx, dIdx) {
        const x = this.state.colX[dIdx], y = this.state.rowY[yIdx];
        const w = this.state.colWidths[dIdx], h = Math.max(this.state.rowHeights[yIdx] - this.config.padding, 0.5);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.globalAlpha = 0.5;
        this.ctx.fillRect(x, y, w, h);
        this.ctx.strokeStyle = '#0ff';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(x, y, w, h);
        this.ctx.globalAlpha = 1.0;

        const info = this.getMonthInfo(dIdx);
        this.dateDisplay.textContent = `${this.config.startYear + yIdx}年 ${info.month}月 ${info.date}日`;
        this.dateDisplay.style.color = `rgb(${MONTH_DATA.colors[info.month-1].join(',')})`;
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => new HyperCalendar();
</script>
</body>
</html>