<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper-Scale Calendar</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #1a1a1a;
            font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: none;
        }
        #canvas-container { position: relative; width: 100%; height: 100%; }
        canvas { display: block; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            pointer-events: none; color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 { font-size: 1.2rem; margin: 0; font-weight: 300; letter-spacing: 2px; }
        #current-date { font-size: 2.5rem; font-weight: 700; margin-top: 5px; font-variant-numeric: tabular-nums; }
        #instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.5); font-size: 0.9rem;
            pointer-events: none; animation: blink 3s infinite;
        }
        #version {
            position: absolute; bottom: 15px; right: 20px;
            color: rgba(255, 255, 255, 0.3); font-size: 0.7rem;
            font-family: monospace; pointer-events: none;
        }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 0.2; } }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="calendarCanvas"></canvas>
    <div id="ui-layer">
        <h1>TIME LENS // 120 YEARS</h1>
        <div id="current-date">Initializing...</div>
    </div>
    <div id="instruction">Drag / Hover to Explore Time</div>
    <div id="version">v20260128.12</div>
</div>

<script>
/**
 * [CRITICAL PROTOCOL FOR AI ASSISTANTS]
 * ... (省略) ...
 * CHANGELOG:
 * - v20260128.11: ABSOLUTE SLOT ALLOCATION.
 * - v20260128.12: FUNDAMENTAL RESET: POWER-MAPPING MODEL. 
 *                 Discarded Gaussian approach for an analytic power-function mapping to 
 *                 guarantee 100% constant pixel-size and zero-jitter performance.
 */

const MONTH_DATA = {
    days: [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
    colors: [
        [200, 230, 255], [220, 240, 255], [255, 200, 220], [255, 180, 200],
        [180, 255, 180], [100, 220, 100], [100, 200, 255], [50, 150, 255],
        [255, 200, 100], [255, 150, 50], [200, 100, 50], [220, 220, 255]
    ]
};

class SoundEngine {
    constructor() {
        this.ctx = null;
        this.frequencies = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];
        this.lastDecade = -1;
    }
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        else if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    playTone(freq, type = 'sine', duration = 0.1, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    }
    playHover() {
        if (Math.random() > 0.8) {
            const f = this.frequencies[Math.floor(Math.random() * this.frequencies.length)];
            this.playTone(f * 2, 'sine', 0.05, 0.02);
        }
    }
    playDecadeCross(year) {
        const decade = Math.floor(year / 10);
        if (this.lastDecade !== decade) {
            this.playTone(110 + (decade % 10) * 20, 'square', 0.1, 0.05);
            this.lastDecade = decade;
        }
    }
}

class HyperCalendar {
    constructor() {
        this.canvas = document.getElementById('calendarCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        this.dateDisplay = document.getElementById('current-date');
        this.config = { years: 120, days: 366, startYear: 1950, padding: 2 };
        this.state = {
            pointer: { x: 0, y: 0, targetX: 0, targetY: 0 },
            isInteracting: true,
            rowHeights: new Float32Array(this.config.years),
            colWidths: new Float32Array(this.config.days),
            rowY: new Float32Array(this.config.years + 1),
            colX: new Float32Array(this.config.days + 1)
        };
        this.sound = new SoundEngine();
        this.resize();
        this.setInitialDate();
        this.initEvents();
        this.loop();
    }

    getMonthInfo(dayIdx) {
        for (let i = 11; i >= 0; i--) {
            if (dayIdx >= MONTH_DATA.days[i]) return { month: i + 1, date: dayIdx - MONTH_DATA.days[i] + 1 };
        }
    }

    setInitialDate() {
        const now = new Date();
        const yIdx = Math.max(0, Math.min(this.config.years - 1, now.getFullYear() - this.config.startYear));
        const dIdx = Math.floor((now - new Date(now.getFullYear(), 0, 1)) / 86400000);
        this.state.pointer.x = this.state.pointer.targetX = (dIdx / this.config.days) * this.width;
        this.state.pointer.y = this.state.pointer.targetY = (yIdx / this.config.years) * this.height;
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
    }

    initEvents() {
        window.addEventListener('resize', () => this.resize());
        const move = (e) => {
            const t = e.touches ? e.touches[0] : e;
            this.state.pointer.targetX = t.clientX;
            this.state.pointer.targetY = t.clientY;
            this.state.isInteracting = true;
            this.sound.init();
        };
        this.canvas.addEventListener('mousemove', move);
        this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); move(e); }, { passive: false });
        this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, { passive: false });
        this.canvas.addEventListener('mouseleave', () => this.state.isInteracting = false);
    }

    /**
     * 【根本解決】パワー・マッピング分布
     * 拡大率（M）を維持したまま、ポインタを境に左右を指数関数で圧縮する
     */
    calculateDistribution(totalSize, pointerPos, itemsCount, peakPx) {
        const positions = new Float32Array(itemsCount + 1);
        const sizes = new Float32Array(itemsCount);
        
        // 正規化されたポインタ位置 p [0, 1]
        const p = Math.max(0.001, Math.min(0.999, pointerPos / totalSize));
        // 必要とされる拡大率 M
        const M = peakPx / (totalSize / itemsCount);

        /**
         * 写像関数 f(x): [0, 1] -> [0, 1]
         * pを境にべき乗関数を使い、f'(p) = M を実現する
         */
        const f = (x) => {
            if (x < p) {
                // 左側: y = p * (x/p)^M
                return p * Math.pow(x / p, M);
            } else {
                // 右側: y = 1 - (1-p) * ((1-x)/(1-p))^M
                return 1 - (1 - p) * Math.pow((1 - x) / (1 - p), M);
            }
        };

        positions[0] = 0;
        for (let i = 0; i < itemsCount; i++) {
            const x0 = i / itemsCount;
            const x1 = (i + 1) / itemsCount;
            
            // ピクセル座標への変換
            const y0 = f(x0) * totalSize;
            const y1 = f(x1) * totalSize;
            
            sizes[i] = y1 - y0;
            positions[i + 1] = y1;
        }

        return { sizes, positions };
    }

    update() {
        const p = this.state.pointer;
        p.x += (p.targetX - p.x) * 0.15;
        p.y += (p.targetY - p.y) * 0.15;

        // セルサイズを物理的に指定（日付 60px / 年 50px）
        // どの場所でもこのサイズが数学的に維持されます
        const xDist = this.calculateDistribution(this.width, p.x, this.config.days, 60);
        const yDist = this.calculateDistribution(this.height, p.y, this.config.years, 50);

        this.state.colWidths = xDist.sizes;
        this.state.colX = xDist.positions;
        this.state.rowHeights = yDist.sizes;
        this.state.rowY = yDist.positions;

        if (this.state.isInteracting) {
            const yIdx = this.state.rowY.findIndex((pos, i) => p.y >= pos && p.y < this.state.rowY[i+1]);
            if (yIdx !== -1) {
                this.sound.playDecadeCross(this.config.startYear + yIdx);
                if (Math.abs(p.targetX - p.x) > 5) this.sound.playHover();
            }
        }
    }

    draw() {
        const { ctx, width, height, config, state } = this;
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        MONTH_DATA.days.forEach((startDay, m) => {
            const endDay = MONTH_DATA.days[m + 1] || 366;
            const x = state.colX[startDay], w = state.colX[endDay] - x;
            if (w < 0.1) return;
            ctx.fillStyle = `rgb(${MONTH_DATA.colors[m].join(',')})`;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x, 0, w, height);
        });

        ctx.globalAlpha = 1.0;
        let hover = { y: -1, d: -1 };
        for (let y = 0; y < config.years; y++) {
            const h = state.rowHeights[y], py = state.rowY[y];
            if (py > height || py + h < 0) continue;
            const isActiveRow = state.isInteracting && state.pointer.y >= py && state.pointer.y < py + h;
            if (isActiveRow) hover.y = y;
            const drawH = Math.max(h - config.padding, 0.5);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, py + drawH, width, config.padding);

            if (h > 12 || isActiveRow) {
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.max(8, Math.min(h * 0.7, 18))}px Arial`;
                ctx.fillText(config.startYear + y, 10, py + drawH * 0.75);
            }
            if (isActiveRow && h > 20) {
                for (let d = 0; d < config.days; d++) {
                    const w = state.colWidths[d], px = state.colX[d];
                    if (state.pointer.x >= px && state.pointer.x < px + w) hover.d = d;
                    if (w > 2) {
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(px + w - 1, py, 1, drawH);
                    }
                    if (w > 32) {
                        const info = this.getMonthInfo(d);
                        ctx.fillStyle = 'rgba(255,255,255,0.8)';
                        ctx.font = '10px Arial';
                        ctx.fillText(`${info.month}/${info.date}`, px + 4, py + 14);
                    }
                }
            }
        }
        if (hover.y !== -1 && hover.d !== -1) this.drawHighlight(hover.y, hover.d);
        else if (!state.isInteracting) {
            this.dateDisplay.textContent = "120 YEARS VIEW";
            this.dateDisplay.style.color = "#888";
        }
    }

    drawHighlight(yIdx, dIdx) {
        const x = this.state.colX[dIdx], y = this.state.rowY[yIdx];
        const w = this.state.colWidths[dIdx], h = Math.max(this.state.rowHeights[yIdx] - this.config.padding, 0.5);
        this.ctx.fillStyle = '#fff';
        this.ctx.globalAlpha = 0.4;
        this.ctx.fillRect(x, y, w, h);
        this.ctx.strokeStyle = '#0ff';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(x, y, w, h);
        this.ctx.globalAlpha = 1.0;
        const info = this.getMonthInfo(dIdx);
        this.dateDisplay.textContent = `${this.config.startYear + yIdx}年 ${info.month}月 ${info.date}日`;
        this.dateDisplay.style.color = `rgb(${MONTH_DATA.colors[info.month-1].join(',')})`;
    }

    loop() {
        this.update(); this.draw();
        requestAnimationFrame(() => this.loop());
    }
}
window.onload = () => new HyperCalendar();
</script>
</body>
</html>