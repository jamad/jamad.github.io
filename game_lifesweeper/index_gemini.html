<!-- https://lmarena.ai/c/019ae067-66d5-7420-87a8-beb7b796206e -->



<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>LIFE GAME PUZZLE: TORUS WORLD</title>
    <style>
        body {
            font-family: 'Courier New', sans-serif;
            background-color: #050505;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 1rem;
            color: #666;
        }

        canvas {
            background-color: #000;
            border: 1px solid #333;
            /* 画面に収まらない場合は縮小表示するレスポンシブ対応 */
            max-width: 95vw;
            max-height: 85vh;
            box-shadow: 0 0 20px rgba(0, 100, 0, 0.2);
            image-rendering: pixelated;
        }

        .info {
            margin-top: 10px;
            text-align: center;
            font-size: 0.8rem;
            color: #888;
        }

        .key {
            display: inline-block;
            padding: 1px 5px;
            border: 1px solid #444;
            border-radius: 3px;
            background: #222;
            color: #ddd;
        }

        #status {
            font-weight: bold;
            color: #ff4444;
            height: 1.2em;
            margin-bottom: 5px;
        }

        #level-info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.8rem;
            color: #444;
        }
    </style>
</head>

<body>

    <div id="level-info">Level 1: 128x128 (Wrapping)</div>
    <h1>LIFE GAME PUZZLE</h1>
    <div id="status">TARGET: ELIMINATE ALL LIFE</div>

    <canvas id="gameCanvas"></canvas>

    <div class="info">
        <span class="key">ARROWS</span> Move &nbsp; <span class="key">SPACE</span> Place/Remove Dot &nbsp; <span
            class="key">R</span> Retry
    </div>

    <script>
        /**
         * 設定・定数
         */
        const CELL_SIZE = 6;     // セル数が多いので少し小さめに設定
        const SIMULATION_SPEED = 80; // 更新間隔(ms) - 少し速く

        // レベル設定（拡張性確保）
        const LEVELS = [
            { w: 128, h: 128 },
            { w: 256, h: 128 },
            { w: 256, h: 256 }
        ];
        let currentLevelIndex = 0; // 現在のレベル（0番目を使用）

        // グローバル変数
        let COLS, ROWS;
        let grid = [];
        let player = { x: 0, y: 0 };
        let isGameClear = false;
        let lastTime = 0;
        let simulationTimer = 0;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const levelInfoEl = document.getElementById('level-info');

        /**
         * 初期化処理
         * @param {number} levelIdx - LEVELS配列のインデックス
         */
        function initGame(levelIdx) {
            const lvl = LEVELS[levelIdx];
            COLS = lvl.w;
            ROWS = lvl.h;

            // キャンバスサイズ設定
            canvas.width = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;

            levelInfoEl.innerText = `Level ${levelIdx + 1}: ${COLS}x${ROWS} (Wrapping)`;

            isGameClear = false;
            statusEl.innerText = "TARGET: ELIMINATE ALL LIFE";
            statusEl.style.color = "#ff4444";

            // グリッド作成 & 初期配置
            grid = new Array(ROWS).fill(null).map(() => new Array(COLS).fill(0));

            // ランダム配置（中央に寄せる）
            // 全画面埋めると128x128は手動で消すのが大変すぎるため、
            // 中央 50% 程度の領域にランダム生成します。
            const marginX = Math.floor(COLS * 0.25);
            const marginY = Math.floor(ROWS * 0.25);

            for (let r = marginY; r < ROWS - marginY; r++) {
                for (let c = marginX; c < COLS - marginX; c++) {
                    if (Math.random() > 0.80) grid[r][c] = 1;
                }
            }

            // プレイヤー初期位置（中央）
            player.x = Math.floor(COLS / 2);
            player.y = Math.floor(ROWS / 2);

            // ループ開始（初回のみ）
            if (lastTime === 0) requestAnimationFrame(gameLoop);
        }

        /**
         * ゲームループ
         */
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        /**
         * 更新処理
         */
        function update(deltaTime) {
            if (isGameClear) return;

            // ライフゲーム進行
            simulationTimer += deltaTime;
            if (simulationTimer >= SIMULATION_SPEED) {
                simulationTimer = 0;
                computeNextGen();
                checkWinCondition();
            }
        }

        /**
         * 描画処理
         */
        function draw() {
            // 背景
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // セル描画
            // 生存セルのみ描画（高速化のため）
            ctx.fillStyle = isGameClear ? '#4CAF50' : '#0f0';

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] === 1) {
                        // グリッド線なしでシンプルに塗りつぶし
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                    }
                }
            }

            // プレイヤーカーソル描画（ラッピング対応不要、表示位置はそのまま）
            if (!isGameClear) {
                const px = player.x * CELL_SIZE;
                const py = player.y * CELL_SIZE;

                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 1, py - 1, CELL_SIZE + 1, CELL_SIZE + 1); // 少し外側に枠

                // 視認性向上のための半透明塗り
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
            }
        }

        /**
         * ライフゲーム世代更新（Wrapping対応）
         */
        function computeNextGen() {
            const nextGrid = new Array(ROWS); // 最適化のため都度行のみ作成
            let hasLiveCell = false;

            for (let r = 0; r < ROWS; r++) {
                nextGrid[r] = new Array(COLS);
                for (let c = 0; c < COLS; c++) {
                    const neighbors = countNeighborsWrapped(r, c);
                    const cell = grid[r][c];
                    let nextState = 0;

                    if (cell === 1) {
                        if (neighbors === 2 || neighbors === 3) nextState = 1;
                    } else {
                        if (neighbors === 3) nextState = 1;
                    }

                    nextGrid[r][c] = nextState;
                }
            }
            grid = nextGrid;
        }

        /**
         * 隣人数え上げ（トーラス型：端がつながる）
         */
        function countNeighborsWrapped(r, c) {
            let sum = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;

                    // モジュロ演算で座標をラップさせる
                    // (c + j + COLS) % COLS は、-1になっても COLS-1 になる計算式
                    const y = (r + i + ROWS) % ROWS;
                    const x = (c + j + COLS) % COLS;

                    sum += grid[y][x];
                }
            }
            return sum;
        }

        /**
         * 勝利判定
         */
        function checkWinCondition() {
            // フラットにして合計を計算（高速化の余地ありだが現状維持）
            let population = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    population += grid[r][c];
                }
            }

            if (population === 0) {
                gameClear();
            }
        }

        function gameClear() {
            isGameClear = true;
            statusEl.innerText = "MISSION ACCOMPLISHED";
            statusEl.style.color = "#4CAF50";
            drawTextToGrid("CLEARED");
            draw(); // 最終描画
        }

        /**
         * テキストをドット化して配置（サイズに合わせてフォントサイズ自動調整）
         */
        function drawTextToGrid(text) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = COLS;
            tempCanvas.height = ROWS;
            const tCtx = tempCanvas.getContext('2d');

            tCtx.fillStyle = '#000';
            tCtx.fillRect(0, 0, COLS, ROWS);
            tCtx.fillStyle = '#fff';

            // グリッドサイズに応じてフォントサイズを調整
            const fontSize = Math.floor(Math.min(COLS, ROWS) / 5);
            tCtx.font = `bold ${fontSize}px sans-serif`;

            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            tCtx.fillText(text, COLS / 2, ROWS / 2);

            const imageData = tCtx.getImageData(0, 0, COLS, ROWS);
            const data = imageData.data;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const index = (r * COLS + c) * 4;
                    if (data[index] > 100) {
                        grid[r][c] = 1;
                    } else {
                        grid[r][c] = 0;
                    }
                }
            }
        }

        /**
         * キー入力（プレイヤー移動もWrappingさせる）
         */
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                initGame(currentLevelIndex);
                return;
            }

            // レベル切り替えデバッグ用（Lキー）
            if (e.code === 'KeyL') {
                currentLevelIndex = (currentLevelIndex + 1) % LEVELS.length;
                initGame(currentLevelIndex);
                return;
            }

            if (isGameClear) return;

            let moved = false;

            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    // 上端を超えたら下端へ
                    player.y = (player.y - 1 + ROWS) % ROWS;
                    moved = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    // 下端を超えたら上端へ
                    player.y = (player.y + 1) % ROWS;
                    moved = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    // 左端を超えたら右端へ
                    player.x = (player.x - 1 + COLS) % COLS;
                    moved = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    // 右端を超えたら左端へ
                    player.x = (player.x + 1) % COLS;
                    moved = true;
                    break;
                case 'Space':
                case 'Enter':
                    grid[player.y][player.x] = grid[player.y][player.x] ? 0 : 1;
                    e.preventDefault();
                    break;
            }
        });

        // ゲーム開始
        initGame(currentLevelIndex);

    </script>
</body>

</html>