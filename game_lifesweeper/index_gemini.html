<!-- https://lmarena.ai/c/019ae067-66d5-7420-87a8-beb7b796206e -->

<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>LIFE GAME PUZZLE: TIME ATTACK</title>
    <style>
        body {
            font-family: 'Courier New', sans-serif;
            background-color: #050505;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* UIレイアウト */
        .header {
            display: flex;
            justify-content: space-between;
            width: 640px;
            /* canvas幅に合わせる */
            margin-bottom: 5px;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #888;
        }

        #score-board {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
        }

        canvas {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0, 100, 0, 0.1);
            image-rendering: pixelated;
        }

        #status {
            margin-top: 10px;
            font-weight: bold;
            color: #ff4444;
            height: 1.2em;
            font-size: 1.1rem;
        }

        .info {
            margin-top: 5px;
            text-align: center;
            font-size: 0.8rem;
            color: #666;
        }

        .key {
            display: inline-block;
            padding: 1px 6px;
            border: 1px solid #444;
            border-radius: 3px;
            background: #222;
            color: #ddd;
        }
    </style>
</head>

<body>

    <div class="header">
        <h1>LIFE GAME PUZZLE</h1>
        <div id="score-board">GEN: 0</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="status">WAITING FOR INPUT...</div>

    <div class="info">
        <span class="key">ARROWS</span> Move &nbsp; <span class="key">SPACE</span> Place Dot & Start &nbsp; <span
            class="key">R</span> Retry
    </div>

    <script>
        /**
         * 設定・定数
         */
        const CELL_SIZE = 20;    // 32x32用に見やすく大きく
        const SIMULATION_SPEED = 80;

        const LEVELS = [
            { w: 32, h: 32 },
            { w: 64, h: 64 },
            { w: 128, h: 128 }
        ];
        let currentLevelIndex = 0;

        // グローバル変数
        let COLS, ROWS;
        let grid = [];
        let player = { x: 0, y: 0 };

        // ゲーム進行フラグ
        let isGameStarted = false; // 最初の入力があるまでfalse
        let isGameClear = false;
        let generationCount = 0;   // スコア（経過世代数）

        let lastTime = 0;
        let simulationTimer = 0;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const scoreEl = document.getElementById('score-board');

        /**
         * 初期化処理
         */
        function initGame(levelIdx) {
            const lvl = LEVELS[levelIdx];
            COLS = lvl.w;
            ROWS = lvl.h;

            canvas.width = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;

            // 変数リセット
            isGameClear = false;
            isGameStarted = false;
            generationCount = 0;
            scoreEl.innerText = "GEN: 0";

            statusEl.innerText = "PRESS SPACE TO START";
            statusEl.style.color = "#ffff00"; // 黄色で注意喚起

            // グリッド初期化
            grid = new Array(ROWS).fill(null).map(() => new Array(COLS).fill(0));

            // ★初期パターンをテキストで生成
            drawTextToGrid("STAGE\n1");

            // プレイヤー初期位置（邪魔にならないよう左上に）
            player.x = 2;
            player.y = 2;

            if (lastTime === 0) requestAnimationFrame(gameLoop);
        }

        /**
         * ゲームループ
         */
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        /**
         * 更新処理
         */
        function update(deltaTime) {
            if (isGameClear) return;

            // ★ゲーム開始（最初の入力）済みの場合のみ時間を進める
            if (isGameStarted) {
                simulationTimer += deltaTime;

                if (simulationTimer >= SIMULATION_SPEED) {
                    simulationTimer = 0;
                    computeNextGen();

                    // 世代カウントアップ（スコア）
                    generationCount++;
                    scoreEl.innerText = "GEN: " + generationCount;

                    checkWinCondition();
                }
            }
        }

        /**
         * 描画処理
         */
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // セル描画
            ctx.fillStyle = isGameClear ? '#4CAF50' : '#0f0';

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] === 1) {
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                    }
                }
            }

            // プレイヤー描画
            if (!isGameClear) {
                const px = player.x * CELL_SIZE;
                const py = player.y * CELL_SIZE;

                // 待機中は白っぽく、開始したら赤くする演出
                ctx.strokeStyle = isGameStarted ? '#ff0000' : '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 1, py - 1, CELL_SIZE + 1, CELL_SIZE + 1);

                ctx.fillStyle = isGameStarted ? 'rgba(255, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
            }
        }

        /**
         * ライフゲーム世代更新（Wrappingあり）
         */
        function computeNextGen() {
            const nextGrid = new Array(ROWS);
            for (let r = 0; r < ROWS; r++) {
                nextGrid[r] = new Array(COLS);
                for (let c = 0; c < COLS; c++) {
                    const neighbors = countNeighborsWrapped(r, c);
                    const cell = grid[r][c];

                    // シンプル化されたロジック
                    if (cell === 1) {
                        nextGrid[r][c] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        nextGrid[r][c] = (neighbors === 3) ? 1 : 0;
                    }
                }
            }
            grid = nextGrid;
        }

        function countNeighborsWrapped(r, c) {
            let sum = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const y = (r + i + ROWS) % ROWS;
                    const x = (c + j + COLS) % COLS;
                    sum += grid[y][x];
                }
            }
            return sum;
        }

        /**
         * 勝利判定
         */
        function checkWinCondition() {
            let population = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    population += grid[r][c];
                }
            }

            if (population === 0) {
                gameClear();
            }
        }

        function gameClear() {
            isGameClear = true;

            // 最終スコア表示
            statusEl.innerText = "CLEAR! SCORE: " + generationCount;
            statusEl.style.color = "#4CAF50";

            drawTextToGrid("STAGE\nCLEAR");
            draw();
        }

        /**
         * テキストをグリッドに書き込む関数（初期配置・クリア画面兼用）
         */
        function drawTextToGrid(text) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = COLS;
            tempCanvas.height = ROWS;
            const tCtx = tempCanvas.getContext('2d');

            tCtx.fillStyle = '#000';
            tCtx.fillRect(0, 0, COLS, ROWS);
            tCtx.fillStyle = '#fff';

            const lines = text.split('\n');
            // フォントサイズ：32px幅なら8px程度
            const fontSize = Math.floor(COLS / 4);
            tCtx.font = `bold ${fontSize}px sans-serif`;
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';

            const lineHeight = fontSize;
            const totalHeight = lines.length * lineHeight;
            const startY = (ROWS / 2) - (totalHeight / 2) + (lineHeight / 2);

            lines.forEach((line, i) => {
                tCtx.fillText(line, COLS / 2, startY + (i * lineHeight));
            });

            const imageData = tCtx.getImageData(0, 0, COLS, ROWS);
            const data = imageData.data;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const index = (r * COLS + c) * 4;
                    if (data[index] > 100) {
                        grid[r][c] = 1;
                    } else {
                        grid[r][c] = 0; // テキストを描くときは既存セルを上書き
                    }
                }
            }
        }

        /**
         * 入力ハンドリング
         */
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                initGame(currentLevelIndex);
                return;
            }

            // レベル変更隠しコマンド (L)
            if (e.code === 'KeyL') {
                currentLevelIndex = (currentLevelIndex + 1) % LEVELS.length;
                initGame(currentLevelIndex);
                return;
            }

            if (isGameClear) return;

            let moved = false;

            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    player.y = (player.y - 1 + ROWS) % ROWS;
                    moved = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    player.y = (player.y + 1) % ROWS;
                    moved = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    player.x = (player.x - 1 + COLS) % COLS;
                    moved = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    player.x = (player.x + 1) % COLS;
                    moved = true;
                    break;
                case 'Space':
                case 'Enter':
                    // ★最初の入力ならゲーム開始
                    if (!isGameStarted) {
                        isGameStarted = true;
                        statusEl.innerText = "ELIMINATE ALL!";
                        statusEl.style.color = "#ff4444";
                    }

                    // 点を打つ
                    grid[player.y][player.x] = grid[player.y][player.x] ? 0 : 1;
                    e.preventDefault();
                    break;
            }
        });

        // 開始
        initGame(currentLevelIndex);

    </script>
</body>

</html>