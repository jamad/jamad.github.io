<!DOCTYPE html>
<html lang="ja">
<!-- 
  Word Tower 100
  Version: 1.3 (Sine Curve Logic + History Graph)
-->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Word Tower 100 (Ver 1.3)</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: #2c3e50;
        touch-action: none;
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
    }
    canvas { display: block; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- 外部ファイル読み込み -->
<script src="words.js"></script>

<script>
// ==========================================
//  データ読み込み
// ==========================================
let sourceData = [];

if (typeof rawData !== 'undefined') {
    sourceData = rawData;
} else {
    alert("【エラー】words.js が見つかりません。");
    sourceData = [["Error","データなし",1]];
}

const wordData = sourceData.map(d => ({ en: d[0], jp: d[1], lv: d[2] }));

const dummyWords = [
    "美しい", "静かな", "巨大な", "小さな", "速い", "遅い", "賢い", "愚かな", "強い", "弱い",
    "食べる", "眠る", "走る", "歩く", "考える", "知る", "作る", "壊す", "笑う", "泣く",
    "犬", "猫", "鳥", "魚", "山", "川", "海", "空", "太陽", "月", "星",
    "赤い", "青い", "白い", "黒い", "黄色い", "緑の", "明るい", "暗い", "重い", "軽い",
    "愛", "平和", "戦争", "自由", "希望", "夢", "友達", "家族", "学校", "仕事",
    "概念", "理論", "哲学", "経済", "政治", "法律", "医学", "芸術", "宗教", "歴史"
];

// ==========================================
//  システム定義
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TOTAL_LEVELS = 100;
const MAX_ENERGY = 100;

const COLORS = {
    bg: '#2c3e50', text: '#ecf0f1', accent: '#f1c40f',
    correct: '#2ecc71', wrong: '#e74c3c', btnDefault: '#34495e',
    graphLine: 'rgba(241, 196, 15, 0.5)', // グラフの色（半透明の金）
    graphFill: 'rgba(241, 196, 15, 0.1)'  // グラフの下塗り
};

const STATE = { TITLE: 0, PLAY: 1, RESULT: 2 };

let currentState = STATE.TITLE; 
let level = 1;
let energy = 100;
let currentQuestion = null;
let buttons = [];
let particles = [];
let feedbackTimer = 0;
let feedbackColor = null;
let usedWordEn = []; 
let wrongHistory = [];

// ★レベルの履歴を記録する配列（グラフ用）
let levelHistory = [1]; 

// ==========================================
//  画面サイズ & 入力管理
// ==========================================
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (currentState === STATE.PLAY && currentQuestion) {
        layoutButtons();
    }
}
window.addEventListener('resize', resize);
resize(); 

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;
    if (type === 'correct') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'wrong') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    } else if (type === 'tap') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, now);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    }
}

// ==========================================
//  ゲームロジック
// ==========================================
function startGame() {
    level = 1;
    energy = MAX_ENERGY;
    usedWordEn = []; 
    wrongHistory = [];
    levelHistory = [1]; // 履歴リセット
    currentState = STATE.PLAY;
    nextQuestion();
}

function getQuestionData(currentLv) {
    let ranges = [5, 15, 30, 50];
    for (let r of ranges) {
        let candidates = wordData.filter(w => Math.abs(w.lv - currentLv) <= r && !usedWordEn.includes(w.en));
        if (candidates.length > 0) return candidates[Math.floor(Math.random() * candidates.length)];
    }
    return wordData[Math.floor(Math.random() * wordData.length)];
}

function nextQuestion() {
    energy--;
    if (energy < 0) {
        currentState = STATE.RESULT;
        return;
    }

    let q = getQuestionData(level);
    usedWordEn.push(q.en);

    let options = [q.jp];
    while (options.length < 5) {
        let d = dummyWords[Math.floor(Math.random() * dummyWords.length)];
        if (!options.includes(d) && d !== q.jp) options.push(d);
    }
    options.sort(() => Math.random() - 0.5);

    currentQuestion = { word: q, options: options };
    layoutButtons();
}

function layoutButtons() {
    if (!currentQuestion) return;
    buttons = [];
    const margin = 10;
    const btnHeight = 55;
    const startY = canvas.height - (btnHeight * 5) - (margin * 5) - 40; 
    
    // タワーは右端に配置（画面の20%幅）
    const towerWidth = canvas.width * 0.2;
    
    // ボタンは左側〜タワー手前まで
    const btnX = 20;
    const btnW = canvas.width - towerWidth - 40; 

    currentQuestion.options.forEach((opt, i) => {
        buttons.push({
            x: btnX,
            y: startY + (btnHeight + margin) * i,
            w: btnW,
            h: btnHeight,
            text: opt,
            isCorrect: opt === currentQuestion.word.jp
        });
    });
}

function handleAnswer(btn) {
    if (feedbackTimer > 0) return;

    if (btn.isCorrect) {
        playSound('correct');
        
        // ★サインカーブ的上昇ロジック
        // レベル0で最大値、レベル100に近づくほど1に収束する
        // cos(0) = 1, cos(PI/2) = 0
        const maxIncrement = 5; // 最大上昇幅
        const radian = (level / 100) * (Math.PI / 2); // 0 〜 1.57(90度)
        
        // cosカーブに合わせて上昇幅を決定 (最低でも1は上がる)
        let increment = Math.max(1, Math.round(maxIncrement * Math.cos(radian)));
        
        level += increment;
        
        feedbackColor = COLORS.correct;
        spawnParticles(canvas.width / 2, canvas.height / 2, COLORS.correct);
        
        // 履歴追加
        levelHistory.push(level);

        if (level > TOTAL_LEVELS) {
            currentState = STATE.RESULT;
            return;
        }
    } else {
        playSound('wrong');
        wrongHistory.unshift({ en: currentQuestion.word.en, jp: currentQuestion.word.jp });
        if (wrongHistory.length > 6) wrongHistory.pop();

        if (level > 1) level--; 
        
        // 履歴追加（下がったことも記録）
        levelHistory.push(level);

        feedbackColor = COLORS.wrong;
        spawnParticles(canvas.width / 2, canvas.height / 2, COLORS.wrong);
    }
    feedbackTimer = 35;
}

function spawnParticles(x, y, color) {
    for (let i = 0; i < 25; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 1.0, color: color
        });
    }
}

function update() {
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
    particles = particles.filter(p => p.life > 0);

    if (feedbackTimer > 0) {
        feedbackTimer--;
        if (feedbackTimer === 0) {
            feedbackColor = null;
            nextQuestion();
        }
    }
}

// ==========================================
//  描画関数
// ==========================================
function draw() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (currentState === STATE.TITLE) drawTitle();
    else if (currentState === STATE.PLAY) drawGame();
    else if (currentState === STATE.RESULT) drawResult();

    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });
    requestAnimationFrame(loop);
}
function loop() { update(); draw(); }

// ★背景に折れ線グラフを描く関数
function drawGraph() {
    if (levelHistory.length < 2) return;

    const graphAreaW = canvas.width * 0.8; // タワー以外の左側エリア
    const startY = canvas.height - 50;
    const endY = 50;
    const heightRange = startY - endY;

    // X軸のステップ幅（履歴が増えるほど狭くなる）
    // 最低でも20ステップ分の幅は確保して見た目を整える
    const maxSteps = Math.max(20, levelHistory.length);
    const stepX = graphAreaW / maxSteps;

    ctx.strokeStyle = COLORS.graphLine;
    ctx.lineWidth = 3;
    ctx.beginPath();

    levelHistory.forEach((lv, i) => {
        const x = i * stepX;
        // レベル100が一番上(endY)、レベル0が一番下(startY)
        // グラフが上限突破しても描画は続ける（クリア演出用）
        const ratio = Math.min(1.0, lv / TOTAL_LEVELS);
        const y = startY - (ratio * heightRange);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // 下側を塗りつぶして山のように見せる
    ctx.lineTo((levelHistory.length - 1) * stepX, startY);
    ctx.lineTo(0, startY);
    ctx.fillStyle = COLORS.graphFill;
    ctx.fill();
}

// ★タワー描画（右端・半身表示）
function drawTower() {
    const w = canvas.width * 0.2; // 画面幅の20%
    const h = canvas.height;
    
    // タワーの中心X座標を「画面の右端」にする
    const towerCenterX = canvas.width; 
    
    const bottomW = w * 1.5; // 少し太めに
    const topW = w * 0.4;
    const startY = h - 50;
    const endY = 50;

    // タワー本体（台形）
    ctx.fillStyle = '#34495e';
    ctx.beginPath();
    ctx.moveTo(towerCenterX - bottomW, startY); // 左下
    ctx.lineTo(towerCenterX, startY);           // 右下（画面端）
    ctx.lineTo(towerCenterX, endY);             // 右上（画面端）
    ctx.lineTo(towerCenterX - topW, endY);      // 左上
    ctx.closePath();
    ctx.fill();

    // 現在レベルの矢印とライン
    const progress = Math.min(1.0, (level - 1) / 99);
    const currentY = startY - (progress * (startY - endY));
    
    // 矢印の先端X座標（タワーの左斜辺に合わせる簡易計算）
    // 斜辺のX座標 = 下底X + (上底X - 下底X) * progress
    const leftEdgeX = (towerCenterX - bottomW) + ((towerCenterX - topW) - (towerCenterX - bottomW)) * progress;

    // 矢印 (左向き ⬅)
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath();
    ctx.moveTo(leftEdgeX - 5, currentY);
    ctx.lineTo(leftEdgeX - 20, currentY - 10);
    ctx.lineTo(leftEdgeX - 20, currentY + 10);
    ctx.fill();

    // レベルテキスト
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'right'; // 右寄せ
    ctx.font = '12px sans-serif';
    ctx.fillText('Lv.100', canvas.width - 5, endY - 10);
    ctx.fillText('Start', canvas.width - 5, startY + 20);
    
    // 現在地ライン
    ctx.strokeStyle = '#f1c40f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftEdgeX - 25, currentY); // 矢印の尻から
    ctx.lineTo(canvas.width, currentY);   // 画面右端まで
    ctx.stroke();
}

function drawWrongList() {
    if (wrongHistory.length === 0) return;
    const startX = 20;
    const startY = 60;
    ctx.textAlign = 'left';
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#e74c3c';
    ctx.fillText("--- MISSED ---", startX, startY);

    wrongHistory.forEach((item, i) => {
        ctx.fillStyle = '#ecf0f1';
        ctx.font = '16px sans-serif';
        const y = startY + 25 + (i * 25);
        ctx.fillText(`${item.en} : ${item.jp}`, startX, y);
    });
}

function drawTitle() {
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = 'center';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillText('WORD TOWER', canvas.width / 2, canvas.height / 2 - 60);
    
    // バージョン表示
    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#95a5a6';
    ctx.fillText("Ver 1.3", canvas.width / 2, canvas.height / 2 - 20);
    
    drawButton({
        x: canvas.width / 2 - 100, y: canvas.height / 2 + 50,
        w: 200, h: 60, text: 'START'
    }, COLORS.accent);
}

function drawGame() {
    // 1. 背景グラフを描画
    drawGraph();
    // 2. タワーを描画
    drawTower();
    // 3. UIパーツ
    drawWrongList();
    
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = 'center'; 
    ctx.font = 'bold 24px sans-serif';
    // 現在レベルを画面上部中央へ
    ctx.fillText(`Lv.${level}`, canvas.width / 2, 40);
    
    // HP表示
    ctx.textAlign = 'right';
    ctx.font = '20px sans-serif';
    // タワーに被らないよう少し左へ
    ctx.fillText(`HP ${energy}`, canvas.width - (canvas.width * 0.2) - 20, 40);

    const gameAreaW = canvas.width - (canvas.width * 0.2);
    const cx = gameAreaW / 2;
    
    ctx.textAlign = 'center';
    ctx.fillStyle = feedbackColor || COLORS.text;
    ctx.font = 'bold 40px sans-serif';
    if (currentQuestion) {
        ctx.fillText(currentQuestion.word.en, cx, canvas.height / 3);
        ctx.font = '14px sans-serif';
        ctx.fillStyle = '#7f8c8d';
        ctx.fillText(`(Lv.${currentQuestion.word.lv})`, cx, canvas.height / 3 + 40);
    }
    buttons.forEach(btn => {
        let color = COLORS.btnDefault;
        if (feedbackColor && btn.isCorrect) color = COLORS.correct;
        drawButton(btn, color);
    });
}

function drawResult() {
    drawGraph();
    drawTower();
    drawWrongList();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 暗転後にもう一度描画して浮き上がらせる
    drawGraph();
    drawTower();
    drawWrongList();

    const gameAreaW = canvas.width - (canvas.width * 0.2);
    const cx = gameAreaW / 2;

    ctx.fillStyle = COLORS.text;
    ctx.textAlign = 'center';
    if (level > TOTAL_LEVELS) {
        ctx.fillStyle = COLORS.correct;
        ctx.font = 'bold 50px sans-serif';
        ctx.fillText('ALL CLEAR!!', cx, canvas.height / 2 - 60);
        ctx.fillStyle = COLORS.text;
        ctx.font = '24px sans-serif';
        ctx.fillText(`Tower Conquered!`, cx, canvas.height / 2 - 10);
    } else {
        ctx.fillStyle = COLORS.wrong;
        ctx.font = 'bold 50px sans-serif';
        ctx.fillText('GAME OVER', cx, canvas.height / 2 - 60);
        ctx.fillStyle = COLORS.text;
        ctx.font = '24px sans-serif';
        ctx.fillText(`Reached: Lv.${level}`, cx, canvas.height / 2 - 10);
    }
    drawButton({
        x: cx - 100, y: canvas.height / 2 + 80,
        w: 200, h: 60, text: 'RETRY'
    }, COLORS.accent);
}

function drawButton(btn, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(btn.x, btn.y, btn.w, btn.h, 12);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(btn.text, btn.x + btn.w / 2, btn.y + btn.h / 2);
    ctx.textBaseline = 'alphabetic';
}

canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    if (currentState === STATE.TITLE) {
        if (y > canvas.height / 2 && y < canvas.height / 2 + 110) {
            playSound('tap'); startGame();
        }
    } else if (currentState === STATE.PLAY) {
        for (let btn of buttons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                handleAnswer(btn); break;
            }
        }
    } else if (currentState === STATE.RESULT) {
        if (y > canvas.height / 2 + 50) {
            playSound('tap'); startGame();
        }
    }
});
requestAnimationFrame(loop);
</script>
</body>
</html>
